[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "src/allocation/AddressAllocation.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n// import MessageFactory from '../../resources/MessageFactory';\r\n\r\nimport {isURL} from '../utils/utils';\r\n\r\n// TODO: this could not be the best way to do a Singleton but at this moment it works;\r\n\r\nlet instance;\r\n\r\n/**\r\n * Class will ask to the message node for addresses\r\n */\r\nclass AddressAllocation {\r\n  /* private\r\n  _url: URL\r\n  _bus: MiniBus\r\n  */\r\n\r\n  /**\r\n   * Create an Address Allocation\r\n   * @param  {URL.URL}      url - url from who is sending the message\r\n   * @param  {MiniBus}      bus - MiniBus used for address allocation\r\n   */\r\n  constructor(url, bus, registry) {\r\n\r\n    if (!instance) {\r\n      this._url = url + '/address-allocation';\r\n      this._bus = bus;\r\n      this._registry = registry;\r\n      instance = this;\r\n    } else {\r\n      return instance;\r\n    }\r\n  }\r\n\r\n  static get instance() {\r\n    if (!instance) {\r\n      throw new Error('The address allocation was not instaniated');\r\n    }\r\n\r\n    return instance\r\n  }\r\n\r\n  /**\r\n   * get the URL value\r\n   * @return {string} The url value;\r\n   */\r\n  get url() { return this._url; }\r\n\r\n\r\n  /**\r\n   *\r\n   * Ask for creation of a number of Hyperty addresses, to the domain message node.\r\n   *\r\n   * @param {Domain} domain - domain of the message node\r\n   * @param {Number} number - number of address to be allocated\r\n   * @param {Descriptor} info - descriptor to search for the hyperty (TODO:// this should be confirmed)\r\n   * @see https://github.com/reTHINK-project/specs/blob/master/datamodel/core/hyperty-catalogue/readme.md#catalogue-data-model\r\n   * @param {scheme} scheme - scheme of address to be created or reused, like: hyperty, comm, context, etc;\r\n   * @param {boolean|URL.HypertyURL} reuseURL - reuseURL is used to reuse the hypertyURL previously registred;\r\n   * @returns {Promise<Object, Error>} this is Promise and returns an object with the address information\r\n   *\r\n   * @memberOf AddressAllocation\r\n   */\r\n  create(domain, number, info, scheme, reuseURL) {\r\n\r\n    console.log('typeof(reuseURL)', typeof(reuseURL), reuseURL);\r\n\r\n    if (reuseURL) {\r\n\r\n      if (typeof(reuseURL) === 'boolean') {\r\n\r\n        if (reuseURL) {\r\n          return this._reuseAllocatedAddress(domain, number, info, scheme, reuseURL);\r\n        } else {\r\n          return this._allocateNewAddress(domain, scheme, number);\r\n        }\r\n\r\n      }\r\n\r\n      if (typeof(reuseURL) === 'string' && isURL(reuseURL)) {\r\n        return this._reuseAllocatedAddress(domain, number, info, scheme, reuseURL);\r\n      }\r\n\r\n    } else {\r\n      console.info('[AddressAllocation] - new address will be allocated');\r\n\r\n      // if there is no URL saved request a new URL\r\n      return this._allocateNewAddress(domain, scheme, number);\r\n    }\r\n\r\n  }\r\n\r\n  _reuseAllocatedAddress(domain, number, info, scheme, reuseURL) {\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      this._registry.checkRegisteredURLs(info, reuseURL).then((urls) => {\r\n\r\n        if (urls) {\r\n          console.info('[AddressAllocation - ' + scheme + '] - Reuse URL');\r\n          let value = {newAddress: false, address: urls};\r\n          resolve(value);\r\n        } else {\r\n\r\n          if (typeof(reuseURL) === 'string') {\r\n            console.info('[AddressAllocation - reuseURL] - Object ' + reuseURL + ' not found');\r\n            reject('URL Not Found');\r\n          } else if (typeof(reuseURL) === 'boolean') {\r\n            this._allocateNewAddress(domain, scheme, number).then(resolve).catch(reject);\r\n          } else {\r\n            reject('URL Not Found');\r\n          }\r\n\r\n        }\r\n\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  _allocateNewAddress(domain, scheme, number) {\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let msg = {\r\n        type: 'create', from: this._url, to: 'domain://msg-node.' + domain + '/address-allocation',\r\n        body: {value: { number: number } }\r\n      };\r\n\r\n      if (scheme !== 'hyperty') msg.body.scheme = scheme;\r\n\r\n      console.info('[AddressAllocation - ' + scheme + '] - Request new URL');\r\n\r\n      // TODO: change this response Message using the MessageFactory\r\n      this._bus.postMessage(msg, (reply) => {\r\n        if (reply.body.code === 200) {\r\n          let result = {newAddress: true, address: reply.body.value.allocated};\r\n          resolve(result);\r\n        } else {\r\n          reject(reply.body.desc);\r\n        }\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * Send a request to the domain message node, to deallocate one or more addresses\r\n  * @param  {Domain} domain - Domain of the message node.\r\n  * @param  {addresses} addresses to request the deallocation\r\n  * @returns {Promise}  the response by the message node\r\n  */\r\n  delete(domain, addresses) {\r\n    let _this = this;\r\n\r\n    let message = {\r\n      type: 'delete', from: _this._url, to: 'domain://msg-node.' + domain + '/address-allocation',\r\n      body: {childrenResources: addresses}\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      _this._bus.postMessage(message, (reply) => {\r\n        console.log('reply', reply);\r\n        if (reply.body.code === 200) {\r\n          resolve(reply.body.code);\r\n        } else {\r\n          reject(reply.body.desc);\r\n        }\r\n      });\r\n    });\r\n\r\n  }\r\n}\r\n\r\nexport default AddressAllocation;\r\n",
    "static": true,
    "longname": "src/allocation/AddressAllocation.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "class",
    "name": "AddressAllocation",
    "memberof": "src/allocation/AddressAllocation.js",
    "static": true,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/allocation/AddressAllocation.js",
    "importStyle": "AddressAllocation",
    "description": "Class will ask to the message node for addresses",
    "lineNumber": 34,
    "interface": false
  },
  {
    "__docId__": 2,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation#constructor",
    "access": null,
    "description": "Create an Address Allocation",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "url from who is sending the message"
      },
      {
        "nullable": null,
        "types": [
          "MiniBus"
        ],
        "spread": false,
        "optional": false,
        "name": "bus",
        "description": "MiniBus used for address allocation"
      }
    ]
  },
  {
    "__docId__": 3,
    "kind": "member",
    "name": "_url",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "static": false,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation#_url",
    "access": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "member",
    "name": "_bus",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "static": false,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation#_bus",
    "access": null,
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "name": "_registry",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "static": false,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation#_registry",
    "access": null,
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "get",
    "name": "instance",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation.instance",
    "access": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "get",
    "name": "url",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation#url",
    "access": null,
    "description": "get the URL value",
    "lineNumber": 69,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The url value;"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 8,
    "kind": "method",
    "name": "create",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation#create",
    "access": null,
    "description": "\nAsk for creation of a number of Hyperty addresses, to the domain message node.",
    "see": [
      "https://github.com/reTHINK-project/specs/blob/master/datamodel/core/hyperty-catalogue/readme.md#catalogue-data-model"
    ],
    "lineNumber": 86,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Object, Error>} this is Promise and returns an object with the address information"
      },
      {
        "tagName": "@memberOf",
        "tagValue": "AddressAllocation"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "domain of the message node"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "number",
        "description": "number of address to be allocated"
      },
      {
        "nullable": null,
        "types": [
          "Descriptor"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "descriptor to search for the hyperty (TODO:// this should be confirmed)"
      },
      {
        "nullable": null,
        "types": [
          "scheme"
        ],
        "spread": false,
        "optional": false,
        "name": "scheme",
        "description": "scheme of address to be created or reused, like: hyperty, comm, context, etc;"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "URL.HypertyURL"
        ],
        "spread": false,
        "optional": false,
        "name": "reuseURL",
        "description": "reuseURL is used to reuse the hypertyURL previously registred;"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object, Error>"
      ],
      "spread": false,
      "description": "this is Promise and returns an object with the address information"
    }
  },
  {
    "__docId__": 9,
    "kind": "method",
    "name": "_reuseAllocatedAddress",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation#_reuseAllocatedAddress",
    "access": null,
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "domain",
        "types": [
          "*"
        ]
      },
      {
        "name": "number",
        "types": [
          "*"
        ]
      },
      {
        "name": "info",
        "types": [
          "*"
        ]
      },
      {
        "name": "scheme",
        "types": [
          "*"
        ]
      },
      {
        "name": "reuseURL",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 10,
    "kind": "method",
    "name": "_allocateNewAddress",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation#_allocateNewAddress",
    "access": null,
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "domain",
        "types": [
          "*"
        ]
      },
      {
        "name": "scheme",
        "types": [
          "*"
        ]
      },
      {
        "name": "number",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 11,
    "kind": "method",
    "name": "delete",
    "memberof": "src/allocation/AddressAllocation.js~AddressAllocation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/allocation/AddressAllocation.js~AddressAllocation#delete",
    "access": null,
    "description": "Send a request to the domain message node, to deallocate one or more addresses",
    "lineNumber": 176,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}  the response by the message node"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "Domain of the message node."
      },
      {
        "nullable": null,
        "types": [
          "addresses"
        ],
        "spread": false,
        "optional": false,
        "name": "addresses",
        "description": "to request the deallocation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "the response by the message node"
    }
  },
  {
    "__docId__": 12,
    "kind": "file",
    "name": "src/bus/Bus.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\n/**\r\n* @author micaelpedrosa@gmail.com\r\n* Minimal interface and implementation to send and receive messages. It can be reused in many type of components.\r\n* Components that need a message system should receive this class as a dependency or extend it.\r\n* Extensions should implement the following private methods: _onPostMessage and _registerExternalListener\r\n*/\r\nclass Bus {\r\n  /* private\r\n  _msgId: number;\r\n  _subscriptions: <url: MsgListener[]>\r\n\r\n  _responseTimeOut: number\r\n  _responseCallbacks: <url+id: (msg) => void>\r\n\r\n  */\r\n\r\n  constructor() {\r\n    let _this = this;\r\n    _this._msgId = 0;\r\n    _this._subscriptions = {};\r\n\r\n    _this._responseTimeOut = 5000; //default to 3s\r\n    _this._responseCallbacks = {};\r\n\r\n    _this._registerExternalListener();\r\n  }\r\n\r\n  /**\r\n  * Register listener to receive message when \"msg.to === url\".\r\n  * Special url \"*\" for default listener is accepted to intercept all messages.\r\n  * @param {URL} url Address to intercept, tha is in the message \"to\"\r\n  * @param {Listener} listener listener\r\n  * @return {MsgListener} instance of MsgListener\r\n  */\r\n  addListener(url, listener) {\r\n    let _this = this;\r\n\r\n    let item = new MsgListener(_this._subscriptions, url, listener);\r\n    let itemList = _this._subscriptions[url];\r\n    if (!itemList) {\r\n      itemList = [];\r\n      _this._subscriptions[url] = itemList;\r\n    }\r\n\r\n    itemList.push(item);\r\n    return item;\r\n  }\r\n\r\n  /**\r\n   * Manually add a response listener. Only one listener per message ID should exist.\r\n   * ATENTION, there is no timeout for this listener.\r\n   * The listener should be removed with a removeResponseListener, failing to do this will result in a unreleased memory problem.\r\n   * @param {URL} url Origin address of the message sent, \"msg.from\".\r\n   * @param {number} msgId Message ID that is returned from the postMessage.\r\n   * @param {Function} responseListener Callback function for the response\r\n   */\r\n  addResponseListener(url, msgId, responseListener) {\r\n    this._responseCallbacks[url + msgId] = responseListener;\r\n  }\r\n\r\n  /**\r\n   * Remove the response listener.\r\n   * @param {URL} url Origin address of the message sent, \"msg.from\".\r\n   * @param {number} msgId  Message ID that is returned from the postMessage\r\n   */\r\n  removeResponseListener(url, msgId) {\r\n    delete this._responseCallbacks[url + msgId];\r\n  }\r\n\r\n  /**\r\n   * Remove all existent listeners for the URL\r\n   * @param  {URL} url Address registered\r\n   */\r\n  removeAllListenersOf(url) {\r\n    delete this._subscriptions[url];\r\n  }\r\n\r\n  /**\r\n   * Helper method to bind listeners (in both directions) into other MiniBus target.\r\n   * @param  {URL} outUrl Outbound URL, register listener for url in direction \"this -> target\"\r\n   * @param  {URL} inUrl Inbound URL, register listener for url in direction \"target -> this\"\r\n   * @param  {MiniBus} target The other target MiniBus\r\n   * @return {Bound} an object that contains the properties [thisListener, targetListener] and the unbind method.\r\n   */\r\n  bind(outUrl, inUrl, target) {\r\n    let _this = this;\r\n\r\n    let thisListn = _this.addListener(outUrl, (msg) => {\r\n      target.postMessage(msg);\r\n    });\r\n\r\n    let targetListn = target.addListener(inUrl, (msg) => {\r\n      _this.postMessage(msg);\r\n    });\r\n\r\n    return {\r\n      thisListener: thisListn,\r\n      targetListener: targetListn,\r\n      unbind: () => {\r\n        this.thisListener.remove();\r\n        this.targetListener.remove();\r\n      }\r\n    };\r\n  }\r\n\r\n  //publish on default listeners\r\n  _publishOnDefault(msg) {\r\n    //is there any \"*\" (default) listeners?\r\n    let itemList = this._subscriptions['*'];\r\n    if (itemList) {\r\n      this._publishOn(itemList, msg);\r\n    }\r\n  }\r\n\r\n  //publish on a subscription list.\r\n  _publishOn(itemList, msg) {\r\n    itemList.forEach((sub) => {\r\n      sub._callback(msg);\r\n    });\r\n  }\r\n\r\n  _responseCallback(inMsg, responseCallback) {\r\n    let _this = this;\r\n\r\n    //automatic management of response handlers\r\n    if (responseCallback) {\r\n      let responseId = inMsg.from + inMsg.id;\r\n      _this._responseCallbacks[responseId] = responseCallback;\r\n\r\n      setTimeout(() => {\r\n        let responseFun = _this._responseCallbacks[responseId];\r\n        delete _this._responseCallbacks[responseId];\r\n\r\n        if (responseFun) {\r\n          let errorMsg = {\r\n            id: inMsg.id, type: 'response',\r\n            body: { code: 408, desc: 'Response timeout!', value: inMsg }\r\n          };\r\n\r\n          responseFun(errorMsg);\r\n        }\r\n      }, _this._responseTimeOut);\r\n    }\r\n  }\r\n\r\n  _onResponse(msg) {\r\n    let _this = this;\r\n\r\n    if (msg.type === 'response') {\r\n      let responseId = msg.to + msg.id;\r\n      let responseFun = _this._responseCallbacks[responseId];\r\n\r\n      //if it's a provisional response, don't delete response listener\r\n      if (msg.body.code >= 200) {\r\n        delete _this._responseCallbacks[responseId];\r\n      }\r\n\r\n      if (responseFun) {\r\n        responseFun(msg);\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  //receive messages from external interface\r\n  _onMessage(msg) {\r\n    let _this = this;\r\n\r\n    if (!_this._onResponse(msg)) {\r\n      let itemList = _this._subscriptions[msg.to];\r\n      if (itemList) {\r\n        _this._publishOn(itemList, msg);\r\n      } else {\r\n        _this._publishOnDefault(msg);\r\n      }\r\n    }\r\n  }\r\n\r\n  _genId(inMsg) {\r\n    //TODO: how do we manage message ID's? Should it be a global runtime counter, or per URL address?\r\n    //Global counter will not work, because there will be multiple MiniBus instances!\r\n    //Per URL, can be a lot of data to maintain!\r\n    //Maybe a counter per MiniBus instance. This is the assumed solution for now.\r\n    if (!inMsg.id || inMsg.id === 0) {\r\n      this._msgId++;\r\n      inMsg.id = this._msgId;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Send messages to local listeners, or if not exists to external listeners.\r\n  * It's has an optional mechanism for automatic management of response handlers.\r\n  * The response handler will be unregistered after receiving the response, or after response timeout (default to 3s).\r\n  * @param  {Message} msg Message to send. Message ID is automatically added to the message.\r\n  * @param  {Function} responseCallback Optional parameter, if the developer what's automatic response management.\r\n  * @return {number} Returns the message ID, in case it should be needed for manual management of the response handler.\r\n  */\r\n  postMessage(inMsg, responseCallback) { }\r\n\r\n  /**\r\n   * Not public available, used by the class extension implementation, to process messages from the public \"postMessage\" without a registered listener.\r\n   * Used to send the message to an external interface, like a WebWorker, IFrame, etc.\r\n   * @param  {Message.Message} msg Message\r\n   */\r\n  _onPostMessage(msg) { /*implementation will send message to external system*/ }\r\n\r\n  /**\r\n   * Not public available, used by the class extension implementation, to process all messages that enter the MiniBus from an external interface, like a WebWorker, IFrame, etc.\r\n   * This method is called one time in the constructor to register external listeners.\r\n   * The implementation will probably call the \"_onMessage\" method to publish in the local listeners.\r\n   * DO NOT call \"postMessage\", there is a danger that the message enters in a cycle!\r\n   */\r\n  _registerExternalListener() { /*implementation will register external listener and call \"this._onMessage(msg)\" */ }\r\n\r\n}\r\n\r\nclass MsgListener {\r\n  /* private\r\n  _subscriptions: <string: MsgListener[]>;\r\n  _url: string;\r\n  _callback: (msg) => void;\r\n  */\r\n\r\n  constructor(subscriptions, url, callback) {\r\n    let _this = this;\r\n\r\n    _this._subscriptions = subscriptions;\r\n    _this._url = url;\r\n    _this._callback = callback;\r\n  }\r\n\r\n  get url() { return this._url; }\r\n\r\n  /**\r\n   * Remove this listener from the Bus\r\n   */\r\n  remove() {\r\n    let _this = this;\r\n\r\n    let subs = _this._subscriptions[_this._url];\r\n    if (subs) {\r\n      let index = subs.indexOf(_this);\r\n      subs.splice(index, 1);\r\n\r\n      //if there are no listeners, remove the subscription entirely.\r\n      if (subs.length === 0) {\r\n        delete _this._subscriptions[_this._url];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Bus;\r\n",
    "static": true,
    "longname": "src/bus/Bus.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 13,
    "kind": "class",
    "name": "MsgListener",
    "memberof": "src/bus/Bus.js",
    "static": true,
    "longname": "src/bus/Bus.js~MsgListener",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/bus/Bus.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 14,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Bus.js~MsgListener",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~MsgListener#constructor",
    "access": null,
    "description": null,
    "lineNumber": 249,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "subscriptions",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 15,
    "kind": "get",
    "name": "url",
    "memberof": "src/bus/Bus.js~MsgListener",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~MsgListener#url",
    "access": null,
    "description": null,
    "lineNumber": 257,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 16,
    "kind": "method",
    "name": "remove",
    "memberof": "src/bus/Bus.js~MsgListener",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~MsgListener#remove",
    "access": null,
    "description": "Remove this listener from the Bus",
    "lineNumber": 262,
    "params": []
  },
  {
    "__docId__": 17,
    "kind": "class",
    "name": "Bus",
    "memberof": "src/bus/Bus.js",
    "static": true,
    "longname": "src/bus/Bus.js~Bus",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/bus/Bus.js",
    "importStyle": "Bus",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nMinimal interface and implementation to send and receive messages. It can be reused in many type of components.\nComponents that need a message system should receive this class as a dependency or extend it.\nExtensions should implement the following private methods: _onPostMessage and _registerExternalListener"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 18,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#constructor",
    "access": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 19,
    "kind": "method",
    "name": "addListener",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#addListener",
    "access": null,
    "description": "Register listener to receive message when \"msg.to === url\".\nSpecial url \"*\" for default listener is accepted to intercept all messages.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Address to intercept, tha is in the message \"to\""
      },
      {
        "nullable": null,
        "types": [
          "Listener"
        ],
        "spread": false,
        "optional": false,
        "name": "listener",
        "description": "listener"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MsgListener"
      ],
      "spread": false,
      "description": "instance of MsgListener"
    }
  },
  {
    "__docId__": 20,
    "kind": "method",
    "name": "addResponseListener",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#addResponseListener",
    "access": null,
    "description": "Manually add a response listener. Only one listener per message ID should exist.\nATENTION, there is no timeout for this listener.\nThe listener should be removed with a removeResponseListener, failing to do this will result in a unreleased memory problem.",
    "lineNumber": 80,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Origin address of the message sent, \"msg.from\"."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "msgId",
        "description": "Message ID that is returned from the postMessage."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "responseListener",
        "description": "Callback function for the response"
      }
    ]
  },
  {
    "__docId__": 21,
    "kind": "method",
    "name": "removeResponseListener",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#removeResponseListener",
    "access": null,
    "description": "Remove the response listener.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Origin address of the message sent, \"msg.from\"."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "msgId",
        "description": "Message ID that is returned from the postMessage"
      }
    ]
  },
  {
    "__docId__": 22,
    "kind": "method",
    "name": "removeAllListenersOf",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#removeAllListenersOf",
    "access": null,
    "description": "Remove all existent listeners for the URL",
    "lineNumber": 97,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Address registered"
      }
    ]
  },
  {
    "__docId__": 23,
    "kind": "method",
    "name": "bind",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#bind",
    "access": null,
    "description": "Helper method to bind listeners (in both directions) into other MiniBus target.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "outUrl",
        "description": "Outbound URL, register listener for url in direction \"this -> target\""
      },
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "inUrl",
        "description": "Inbound URL, register listener for url in direction \"target -> this\""
      },
      {
        "nullable": null,
        "types": [
          "MiniBus"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The other target MiniBus"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Bound"
      ],
      "spread": false,
      "description": "an object that contains the properties [thisListener, targetListener] and the unbind method."
    }
  },
  {
    "__docId__": 24,
    "kind": "method",
    "name": "_publishOnDefault",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_publishOnDefault",
    "access": null,
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 25,
    "kind": "method",
    "name": "_publishOn",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_publishOn",
    "access": null,
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "itemList",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 26,
    "kind": "method",
    "name": "_responseCallback",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_responseCallback",
    "access": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "inMsg",
        "types": [
          "*"
        ]
      },
      {
        "name": "responseCallback",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 27,
    "kind": "method",
    "name": "_onResponse",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_onResponse",
    "access": null,
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 28,
    "kind": "method",
    "name": "_onMessage",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_onMessage",
    "access": null,
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 29,
    "kind": "method",
    "name": "_genId",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_genId",
    "access": null,
    "description": null,
    "lineNumber": 204,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "inMsg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 30,
    "kind": "method",
    "name": "postMessage",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#postMessage",
    "access": null,
    "description": "Send messages to local listeners, or if not exists to external listeners.\nIt's has an optional mechanism for automatic management of response handlers.\nThe response handler will be unregistered after receiving the response, or after response timeout (default to 3s).",
    "lineNumber": 223,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message to send. Message ID is automatically added to the message."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "responseCallback",
        "description": "Optional parameter, if the developer what's automatic response management."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Returns the message ID, in case it should be needed for manual management of the response handler."
    }
  },
  {
    "__docId__": 31,
    "kind": "method",
    "name": "_onPostMessage",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_onPostMessage",
    "access": null,
    "description": "Not public available, used by the class extension implementation, to process messages from the public \"postMessage\" without a registered listener.\nUsed to send the message to an external interface, like a WebWorker, IFrame, etc.",
    "lineNumber": 230,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message.Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message"
      }
    ]
  },
  {
    "__docId__": 32,
    "kind": "method",
    "name": "_registerExternalListener",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_registerExternalListener",
    "access": null,
    "description": "Not public available, used by the class extension implementation, to process all messages that enter the MiniBus from an external interface, like a WebWorker, IFrame, etc.\nThis method is called one time in the constructor to register external listeners.\nThe implementation will probably call the \"_onMessage\" method to publish in the local listeners.\nDO NOT call \"postMessage\", there is a danger that the message enters in a cycle!",
    "lineNumber": 238,
    "params": []
  },
  {
    "__docId__": 33,
    "kind": "file",
    "name": "src/bus/MessageBus.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\nimport Bus from './Bus';\r\nimport Pipeline from './Pipeline';\r\n\r\n/**\r\n* @author micaelpedrosa@gmail.com\r\n* Message BUS Interface is an extension of the Bus\r\n* It doesn't support the default '*' listener, instead it uses the registry.resolve(..)\r\n*/\r\nclass MessageBus extends Bus {\r\n  /* private\r\n  _registry: Registry\r\n  _forwards: { <from-url>: { fl: MsgListener, sandboxToUrls: Map(Sandbox, [to-url]), urlToSandbox: { to-url: Sandbox } } }\r\n\r\n  _pipeline: Pipeline\r\n  */\r\n\r\n  //TODO: future optimization\r\n  //1. message batch processing with setInterval\r\n  //2. resolve default gateway/protostub with register.resolve\r\n\r\n  constructor(registry) {\r\n    super();\r\n    this._registry = registry;\r\n    this._forwards = {};\r\n\r\n    this._pipeline = new Pipeline((error) => {\r\n      console.log('PIPELINE-ERROR: ', JSON.stringify(error));\r\n    });\r\n  }\r\n\r\n  get pipeline() { return this._pipeline; }\r\n\r\n  /**\r\n   * Post a message for routing. It will first search for a listener, if there is no one, it sends to a external routing using the _onPostMessage.\r\n   * External routing use the registry.resolve(..) method to decide the destination sandbox.\r\n   * @param  {Message} inMsg            JSON with mandatory Message structure {id, type, from, to}\r\n   * @param  {Callback} responseCallback Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\".\r\n   * @return {number}                  the Message id\r\n   */\r\n  postMessage(inMsg, responseCallback) {\r\n    console.log('onPOSTMessage: ', inMsg);\r\n    let _this = this;\r\n\r\n    _this._genId(inMsg);\r\n\r\n    _this._pipeline.process(inMsg, (msg) => {\r\n\r\n      _this._responseCallback(inMsg, responseCallback);\r\n\r\n      if (!_this._onResponse(msg)) {\r\n        let itemList = _this._subscriptions[msg.to];\r\n        if (itemList) {\r\n          //do not publish on default address, because of loopback cycle\r\n          _this._publishOn(itemList, msg);\r\n        } else {\r\n          //if there is no listener, send to external interface\r\n          _this._onPostMessage(msg);\r\n        }\r\n      }\r\n    });\r\n\r\n    return inMsg.id;\r\n  }\r\n\r\n  /**\r\n   * Adds an external publish address listener. Every message for the address will be forwarded to the external routing by _onPostMessage.\r\n   * This means, even if there is a listener for the address, it will also send the message to the external routing.\r\n   * @param {URL} from Publish address.\r\n   */\r\n  addPublish(from) {\r\n    let _this = this;\r\n\r\n    //verify if forward exist\r\n    let refCount = _this._forwards[from];\r\n    if (!refCount) {\r\n      let forwardListener = _this.addListener(from, (msg) => {\r\n        console.log('MB-PUBLISH: ( ' + from + ' )');\r\n        _this._onPostMessage(msg);\r\n      });\r\n\r\n      refCount = {\r\n        counter: 0,\r\n        fl: forwardListener,\r\n        remove: () => {\r\n          this.counter--;\r\n          if (this.counter === 0) {\r\n            this.fl.remove();\r\n            delete _this._forwards[from];\r\n          }\r\n        }\r\n      };\r\n\r\n     _this._forwards[from] = refCount;\r\n   }\r\n\r\n   refCount.counter++;\r\n   return refCount;\r\n  }\r\n\r\n  /**\r\n   * Adds a forward listener for a message destination. Every message reaching an address will be also sent to the forward address.\r\n   * @param {URL} from Message destination, it's actually the field \"to\" of the message.\r\n   * @param {URL} to   Forward address.\r\n   */\r\n   addForward(from, to) {\r\n     let _this = this;\r\n\r\n     return _this.addListener(from, (msg) => {\r\n       console.log('MB-FORWARD: ( ' + from + ' to ' + to + ' )');\r\n       _this.forward(to, msg);\r\n     });\r\n   }\r\n\r\n   /**\r\n    * Just forward's a message to the forward address. Listeners should be available for the forward address.\r\n    * @param  {URL} url Forward address.\r\n    * @param  {Message} msg Message to forward\r\n    */\r\n   forward(url, msg) {\r\n     let _this = this;\r\n\r\n     let itemList = _this._subscriptions[url];\r\n     if (itemList) {\r\n       _this._publishOn(itemList, msg);\r\n     }\r\n   }\r\n\r\n   //default route, if there are no listeners available for a message destination.\r\n   _onPostMessage(msg) {\r\n     let _this = this;\r\n\r\n     //resolve external protostub...\r\n     _this._registry.resolve(msg.to).then((route) => {\r\n       _this.forward(route, msg);\r\n     }).catch(function(e) {\r\n       console.log('RESOLVE-ERROR: ', e);\r\n     });\r\n   }\r\n}\r\n\r\nexport default MessageBus;\r\n",
    "static": true,
    "longname": "src/bus/MessageBus.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 34,
    "kind": "class",
    "name": "MessageBus",
    "memberof": "src/bus/MessageBus.js",
    "static": true,
    "longname": "src/bus/MessageBus.js~MessageBus",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/bus/MessageBus.js",
    "importStyle": "MessageBus",
    "description": "",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nMessage BUS Interface is an extension of the Bus\nIt doesn't support the default '*' listener, instead it uses the registry.resolve(..)"
      }
    ],
    "interface": false,
    "extends": [
      "src/bus/Bus.js~Bus"
    ]
  },
  {
    "__docId__": 35,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#constructor",
    "access": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "registry",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 36,
    "kind": "member",
    "name": "_registry",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#_registry",
    "access": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 37,
    "kind": "member",
    "name": "_forwards",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#_forwards",
    "access": null,
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 38,
    "kind": "member",
    "name": "_pipeline",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#_pipeline",
    "access": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 39,
    "kind": "get",
    "name": "pipeline",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#pipeline",
    "access": null,
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 40,
    "kind": "method",
    "name": "postMessage",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#postMessage",
    "access": null,
    "description": "Post a message for routing. It will first search for a listener, if there is no one, it sends to a external routing using the _onPostMessage.\nExternal routing use the registry.resolve(..) method to decide the destination sandbox.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "inMsg",
        "description": "JSON with mandatory Message structure {id, type, from, to}"
      },
      {
        "nullable": null,
        "types": [
          "Callback"
        ],
        "spread": false,
        "optional": false,
        "name": "responseCallback",
        "description": "Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\"."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the Message id"
    }
  },
  {
    "__docId__": 41,
    "kind": "method",
    "name": "addPublish",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#addPublish",
    "access": null,
    "description": "Adds an external publish address listener. Every message for the address will be forwarded to the external routing by _onPostMessage.\nThis means, even if there is a listener for the address, it will also send the message to the external routing.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "Publish address."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 42,
    "kind": "method",
    "name": "addForward",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#addForward",
    "access": null,
    "description": "Adds a forward listener for a message destination. Every message reaching an address will be also sent to the forward address.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "Message destination, it's actually the field \"to\" of the message."
      },
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "Forward address."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 43,
    "kind": "method",
    "name": "forward",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#forward",
    "access": null,
    "description": "Just forward's a message to the forward address. Listeners should be available for the forward address.",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Forward address."
      },
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message to forward"
      }
    ]
  },
  {
    "__docId__": 44,
    "kind": "method",
    "name": "_onPostMessage",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#_onPostMessage",
    "access": null,
    "description": null,
    "lineNumber": 151,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 45,
    "kind": "file",
    "name": "src/bus/MiniBus.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\nimport Bus from './Bus';\r\n\r\n/**\r\n* @author micaelpedrosa@gmail.com\r\n* Message BUS Interface is an extension of the Bus\r\n* It is used mainly in the internal sandbox routing.\r\n*/\r\nclass MiniBus extends Bus {\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Post a message for routing. Message is routed directly to the external routing _onPostMessage.\r\n   * @param  {Message} inMsg            JSON with mandatory Message structure {id, type, from, to}\r\n   * @param  {Callback} responseCallback Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\".\r\n   * @return {number}                  the Message id\r\n   */\r\n  postMessage(inMsg, responseCallback) {\r\n    let _this = this;\r\n\r\n    _this._genId(inMsg);\r\n    _this._responseCallback(inMsg, responseCallback);\r\n\r\n    //always send to external (to core MessageBus)\r\n    _this._onPostMessage(inMsg);\r\n\r\n    return inMsg.id;\r\n  }\r\n\r\n  //internal method used when a message is received by an external routing system\r\n  _onMessage(msg) {\r\n    let _this = this;\r\n\r\n    if (!_this._onResponse(msg)) {\r\n      let itemList = _this._subscriptions[msg.to];\r\n      if (itemList) {\r\n        _this._publishOn(itemList, msg);\r\n        if (!msg.to.startsWith('hyperty')) {\r\n          _this._publishOnDefault(msg);\r\n        }\r\n      } else {\r\n        _this._publishOnDefault(msg);\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default MiniBus;\r\n",
    "static": true,
    "longname": "src/bus/MiniBus.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 46,
    "kind": "class",
    "name": "MiniBus",
    "memberof": "src/bus/MiniBus.js",
    "static": true,
    "longname": "src/bus/MiniBus.js~MiniBus",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/bus/MiniBus.js",
    "importStyle": "MiniBus",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nMessage BUS Interface is an extension of the Bus\nIt is used mainly in the internal sandbox routing."
      }
    ],
    "interface": false,
    "extends": [
      "src/bus/Bus.js~Bus"
    ]
  },
  {
    "__docId__": 47,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/MiniBus.js~MiniBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MiniBus.js~MiniBus#constructor",
    "access": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 48,
    "kind": "method",
    "name": "postMessage",
    "memberof": "src/bus/MiniBus.js~MiniBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MiniBus.js~MiniBus#postMessage",
    "access": null,
    "description": "Post a message for routing. Message is routed directly to the external routing _onPostMessage.",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "inMsg",
        "description": "JSON with mandatory Message structure {id, type, from, to}"
      },
      {
        "nullable": null,
        "types": [
          "Callback"
        ],
        "spread": false,
        "optional": false,
        "name": "responseCallback",
        "description": "Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\"."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the Message id"
    }
  },
  {
    "__docId__": 49,
    "kind": "method",
    "name": "_onMessage",
    "memberof": "src/bus/MiniBus.js~MiniBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MiniBus.js~MiniBus#_onMessage",
    "access": null,
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 50,
    "kind": "file",
    "name": "src/bus/Pipeline.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\n/**\r\n* @author micaelpedrosa@gmail.com\r\n* Sequencial processor of methods. Similar to how Sequential Promise's work, but better fit for message processing.\r\n* Normal use for this, is to intercept all messages with configured handlers, and act accordingly.\r\n*/\r\nclass Pipeline {\r\n  /* public\r\n    handlers: ((PipeContext) => void)[]\r\n    onFail: (error) => void\r\n  */\r\n\r\n  constructor(_onFail) {\r\n    let _this = this;\r\n\r\n    _this.handlers = [];\r\n    _this.onFail = _onFail;\r\n  }\r\n\r\n  /**\r\n   * Insert a message in the pipeline queue. All messages are wrapped with a PipeContext.\r\n   * @param  {Message} msg       Message for the queue\r\n   * @param  {Callback} onDeliver When message is finished processing from all handlers, it will be delivered in this callback.\r\n   */\r\n  process(msg, onDeliver) {\r\n    let _this = this;\r\n\r\n    if (_this.handlers.length > 0) {\r\n      let iter = new Iterator(_this.handlers);\r\n      iter.next(new PipeContext(_this, iter, msg, onDeliver));\r\n    } else {\r\n      onDeliver(msg);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n* @author micaelpedrosa@gmail.com\r\n* Wrapper around a message that adds actions that can be fired by any interceptor handler.\r\n* The Pipeline is asynchronous, so an handler should always call an action, the default one is \"next()\"\r\n*/\r\nclass PipeContext {\r\n  /* private\r\n    _inStop: boolean\r\n\r\n    _pipeline: Pipeline\r\n    _iter: Iterator\r\n    _msg: Message\r\n  */\r\n\r\n  constructor(pipeline, iter, msg, onDeliver) {\r\n    let _this = this;\r\n\r\n    _this._inStop = false;\r\n\r\n    _this._pipeline = pipeline;\r\n    _this._iter = iter;\r\n    _this._msg = msg;\r\n    _this._onDeliver = onDeliver;\r\n  }\r\n\r\n  get pipeline() { return this._pipeline; }\r\n\r\n  get msg() { return this._msg; }\r\n  set msg(inMsg) { this._msg = inMsg; }\r\n\r\n  /**\r\n   * Proceed to the next interceptor handler, unless there was an error. If it's the last one, proceed to onDeliver handler.\r\n   */\r\n  next() {\r\n    let _this = this;\r\n\r\n    if (!_this._inStop) {\r\n      if (_this._iter.hasNext) {\r\n        _this._iter.next(_this);\r\n      } else {\r\n        _this._onDeliver(_this._msg);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Proceed directly to the onDeliver handler, unless there was an error.\r\n   */\r\n  deliver() {\r\n    let _this = this;\r\n    if (!_this._inStop) {\r\n      _this._inStop = true;\r\n      _this._onDeliver(_this._msg);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark the context with an error and proceed to the onFail handler.\r\n   * @param  {[type]} error [description]\r\n   */\r\n  fail(error) {\r\n    let _this = this;\r\n\r\n    if (!_this._inStop) {\r\n      _this._inStop = true;\r\n      if (_this._pipeline.onFail) {\r\n        _this._pipeline.onFail(error);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass Iterator {\r\n  /* private\r\n    _index: number\r\n    _array: []\r\n  */\r\n\r\n  constructor(array) {\r\n    this._index = -1;\r\n    this._array = array;\r\n  }\r\n\r\n  get hasNext() {\r\n    return this._index < this._array.length - 1;\r\n  }\r\n\r\n  get next() {\r\n    this._index++;\r\n    return this._array[this._index];\r\n  }\r\n}\r\n\r\nexport default Pipeline;\r\n",
    "static": true,
    "longname": "src/bus/Pipeline.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 51,
    "kind": "class",
    "name": "PipeContext",
    "memberof": "src/bus/Pipeline.js",
    "static": true,
    "longname": "src/bus/Pipeline.js~PipeContext",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/bus/Pipeline.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nWrapper around a message that adds actions that can be fired by any interceptor handler.\nThe Pipeline is asynchronous, so an handler should always call an action, the default one is \"next()\""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 52,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#constructor",
    "access": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pipeline",
        "types": [
          "*"
        ]
      },
      {
        "name": "iter",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "onDeliver",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 53,
    "kind": "get",
    "name": "pipeline",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#pipeline",
    "access": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "get",
    "name": "msg",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#msg",
    "access": null,
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "set",
    "name": "msg",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#msg",
    "access": null,
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "member",
    "name": "_msg",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#_msg",
    "access": null,
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "next",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#next",
    "access": null,
    "description": "Proceed to the next interceptor handler, unless there was an error. If it's the last one, proceed to onDeliver handler.",
    "lineNumber": 92,
    "params": []
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "deliver",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#deliver",
    "access": null,
    "description": "Proceed directly to the onDeliver handler, unless there was an error.",
    "lineNumber": 107,
    "params": []
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "fail",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#fail",
    "access": null,
    "description": "Mark the context with an error and proceed to the onFail handler.",
    "lineNumber": 119,
    "params": [
      {
        "nullable": null,
        "types": [
          "[type]"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": "[description]"
      }
    ]
  },
  {
    "__docId__": 60,
    "kind": "class",
    "name": "Iterator",
    "memberof": "src/bus/Pipeline.js",
    "static": true,
    "longname": "src/bus/Pipeline.js~Iterator",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/bus/Pipeline.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 61,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#constructor",
    "access": null,
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_index",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#_index",
    "access": null,
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_array",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#_array",
    "access": null,
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "get",
    "name": "hasNext",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#hasNext",
    "access": null,
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "get",
    "name": "next",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#next",
    "access": null,
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "class",
    "name": "Pipeline",
    "memberof": "src/bus/Pipeline.js",
    "static": true,
    "longname": "src/bus/Pipeline.js~Pipeline",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/bus/Pipeline.js",
    "importStyle": "Pipeline",
    "description": "",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nSequencial processor of methods. Similar to how Sequential Promise's work, but better fit for message processing.\nNormal use for this, is to intercept all messages with configured handlers, and act accordingly."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 67,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Pipeline.js~Pipeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Pipeline#constructor",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "_onFail",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "process",
    "memberof": "src/bus/Pipeline.js~Pipeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Pipeline#process",
    "access": null,
    "description": "Insert a message in the pipeline queue. All messages are wrapped with a PipeContext.",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message for the queue"
      },
      {
        "nullable": null,
        "types": [
          "Callback"
        ],
        "spread": false,
        "optional": false,
        "name": "onDeliver",
        "description": "When message is finished processing from all handlers, it will be delivered in this callback."
      }
    ]
  },
  {
    "__docId__": 69,
    "kind": "file",
    "name": "src/graphconnector/BloomFilter.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n/*\r\nAdapted from https://github.com/jasondavies/bloomfilter.js\r\n\r\nOriginal License:\r\n\r\nCopyright (c) 2011, Jason Davies\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without\r\nmodification, are permitted provided that the following conditions are met:\r\n\r\n  * Redistributions of source code must retain the above copyright notice, this\r\n    list of conditions and the following disclaimer.\r\n\r\n  * Redistributions in binary form must reproduce the above copyright notice,\r\n    this list of conditions and the following disclaimer in the documentation\r\n    and/or other materials provided with the distribution.\r\n\r\n  * The name Jason Davies may not be used to endorse or promote products\r\n    derived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\nDISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,\r\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\n/**\r\n* Implements a Bloom filter.\r\n* @author Jason Davies; adapted and extended by beierle@tu-berlin.de\r\n*/\r\nclass BloomFilter {\r\n\r\n  //var typedArrays = typeof ArrayBuffer !== 'undefined';\r\n\r\n  // Creates a new bloom filter.  If *m* is an array-like object, with a length\r\n  // property, then the bloom filter is loaded with data from the array, where\r\n  // each element is a 32-bit integer.  Otherwise, *m* should specify the\r\n  // number of bits.  Note that *m* is rounded up to the nearest multiple of\r\n  // 32.  *k* specifies the number of hashing functions.\r\n  constructor(m,k) {\r\n\r\n    var typedArrays = typeof ArrayBuffer !== 'undefined';\r\n\r\n    var a;\r\n    if (typeof m !== 'number') {\r\n      a = m;\r\n      m = a.length * 32;\r\n    }\r\n\r\n    var n = Math.ceil(m / 32);\r\n    var i = -1;\r\n    this.m = m = n * 32;\r\n    this.k = k;\r\n\r\n    if (typedArrays) {\r\n      var kbytes = 1 << Math.ceil(Math.log(Math.ceil(Math.log(m) / Math.LN2 / 8)) / Math.LN2);\r\n      var array = kbytes === 1 ? Uint8Array : kbytes === 2 ? Uint16Array : Uint32Array;\r\n      var kbuffer = new ArrayBuffer(kbytes * k);\r\n      this.buckets = new Int32Array(n);\r\n      if (a) while (++i < n) buckets[i] = a[i];\r\n      this._locations = new Array(kbuffer);\r\n    } else {\r\n      //var buckets = this.buckets = [];\r\n      this.buckets = [];\r\n      if (a) while (++i < n) buckets[i] = a[i];\r\n      else while (++i < n) buckets[i] = 0;\r\n      this._locations = [];\r\n    }\r\n  }\r\n\r\n  // See http://willwhim.wpengine.com/2011/09/03/producing-n-hash-functions-by-hashing-only-once/\r\n  locations(v) {\r\n    var k = this.k;\r\n    var m = this.m;\r\n    var r = this._locations;\r\n    var a = this.fnv1a(v);\r\n    var b = this.fnv1ab(a);\r\n    var x = a % m;\r\n    for (var i = 0; i < k; ++i) {\r\n      r[i] = x < 0 ? (x + m) : x;\r\n      x = (x + b) % m;\r\n    }\r\n    return r;\r\n  }\r\n\r\n  add(v) {\r\n    var l = this.locations(v + '');\r\n    var k = this.k;\r\n    var buckets = this.buckets;\r\n    for (var i = 0; i < k; ++i) buckets[Math.floor(l[i] / 32)] |= 1 << (l[i] % 32);\r\n  }\r\n\r\n  test(v) {\r\n    var l = this.locations(v + '');\r\n    var k = this.k;\r\n    var buckets = this.buckets;\r\n    for (var i = 0; i < k; ++i) {\r\n      var b = l[i];\r\n      if ((buckets[Math.floor(b / 32)] & (1 << (b % 32))) === 0) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // NEW: ORs the BloomFilter from the parameter\r\n  // param has to be a BF; BFs should be same length\r\n  addBloomFilter(v) {\r\n    var buckets = this.buckets;\r\n    var bucketsParam = v.buckets;\r\n    for (var i = 0, n = buckets.length; i < n; ++i) {\r\n      buckets[i] = (buckets[i] | bucketsParam[i]);\r\n    }\r\n  }\r\n\r\n  // Estimated cardinality.\r\n  size() {\r\n    var buckets = this.buckets;\r\n    var bits = 0;\r\n    for (var i = 0, n = buckets.length; i < n; ++i) bits += this.popcnt(buckets[i]);\r\n    return -this.m * Math.log(1 - bits / this.m) / this.k;\r\n  }\r\n\r\n  // http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\r\n  popcnt(v) {\r\n    v -= (v >> 1) & 0x55555555;\r\n    v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\r\n    return ((v + (v >> 4) & 0xf0f0f0f) * 0x1010101) >> 24;\r\n  }\r\n\r\n  // Fowler/Noll/Vo hashing.\r\n  fnv1a(v) {\r\n    var a = 2166136261;\r\n    for (var i = 0, n = v.length; i < n; ++i) {\r\n      var c = v.charCodeAt(i);\r\n      var d = c & 0xff00;\r\n      if (d) a = this.fnvmultiply(a ^ d >> 8);\r\n      a = this.fnvmultiply(a ^ c & 0xff);\r\n    }\r\n    return this.fnvmix(a);\r\n  }\r\n\r\n  // a * 16777619 mod 2**32\r\n  fnvmultiply(a) {\r\n    return a + (a << 1) + (a << 4) + (a << 7) + (a << 8) + (a << 24);\r\n  }\r\n\r\n  // One additional iteration of FNV, given a hash.\r\n  fnv1ab(a) {\r\n    return this.fnvmix(this.fnvmultiply(a));\r\n  }\r\n\r\n  // See https://web.archive.org/web/20131019013225/http://home.comcast.net/~bretm/hash/6.html\r\n  fnvmix(a) {\r\n    a += a << 13;\r\n    a ^= a >>> 7;\r\n    a += a << 3;\r\n    a ^= a >>> 17;\r\n    a += a << 5;\r\n    return a & 0xffffffff;\r\n  }\r\n}\r\n\r\nexport default BloomFilter;\r\n",
    "static": true,
    "longname": "src/graphconnector/BloomFilter.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 70,
    "kind": "class",
    "name": "BloomFilter",
    "memberof": "src/graphconnector/BloomFilter.js",
    "static": true,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/graphconnector/BloomFilter.js",
    "importStyle": "BloomFilter",
    "description": "Implements a Bloom filter.",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "Jason Davies; adapted and extended by beierle@tu-berlin.de"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 71,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#constructor",
    "access": null,
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "m",
        "types": [
          "*"
        ]
      },
      {
        "name": "k",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "m",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#m",
    "access": null,
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "k",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#k",
    "access": null,
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "buckets",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#buckets",
    "access": null,
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "_locations",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#_locations",
    "access": null,
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "buckets",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#buckets",
    "access": null,
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "member",
    "name": "_locations",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#_locations",
    "access": null,
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "locations",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#locations",
    "access": null,
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "v",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "add",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#add",
    "access": null,
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "v",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "test",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#test",
    "access": null,
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "v",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "addBloomFilter",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#addBloomFilter",
    "access": null,
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "v",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "size",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#size",
    "access": null,
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "popcnt",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#popcnt",
    "access": null,
    "description": null,
    "lineNumber": 154,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "v",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "fnv1a",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#fnv1a",
    "access": null,
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "v",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "fnvmultiply",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#fnvmultiply",
    "access": null,
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "fnv1ab",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#fnv1ab",
    "access": null,
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "fnvmix",
    "memberof": "src/graphconnector/BloomFilter.js~BloomFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/BloomFilter.js~BloomFilter#fnvmix",
    "access": null,
    "description": null,
    "lineNumber": 183,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "file",
    "name": "src/graphconnector/GlobalRegistryRecord.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n/**\r\n* Represents the user's information for the global registry.\r\n* @author beierle@tu-berlin.de\r\n*/\r\nclass GlobalRegistryRecord {\r\n\r\n  /**\r\n   * Constructs a new empty object.\r\n   */\r\n    constructor() {\r\n      this.guid;\r\n      this.salt;\r\n      this.userIDs = [];\r\n      this.lastUpdate;\r\n      this.timeout;\r\n      this.publicKey;\r\n      this.active;\r\n      this.revoked;\r\n    }\r\n\r\n  /**\r\n   * Constructs a new object representing information about one contact.\r\n   * @returns {Object}  object  A JavaScript Object with all fields for the Global Registry Record.\r\n   */\r\n    getRecord() {\r\n\r\n      // TODO: give error if fields are missing\r\n\r\n      let record = new Object();\r\n      record.guid = this.guid;\r\n      record.salt = this.salt;\r\n      record.userIDs = this.userIDs;\r\n      record.lastUpdate = this.lastUpdate;\r\n      record.timeout = this.timeout;\r\n      record.publicKey = this.publicKey;\r\n      record.active = this.active;\r\n      record.revoked = this.revoked;\r\n\r\n      return record;\r\n    }\r\n\r\n}\r\n\r\nexport default GlobalRegistryRecord;\r\n",
    "static": true,
    "longname": "src/graphconnector/GlobalRegistryRecord.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 89,
    "kind": "class",
    "name": "GlobalRegistryRecord",
    "memberof": "src/graphconnector/GlobalRegistryRecord.js",
    "static": true,
    "longname": "src/graphconnector/GlobalRegistryRecord.js~GlobalRegistryRecord",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/graphconnector/GlobalRegistryRecord.js",
    "importStyle": "GlobalRegistryRecord",
    "description": "Represents the user's information for the global registry.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "beierle@tu-berlin.de"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 90,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/graphconnector/GlobalRegistryRecord.js~GlobalRegistryRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GlobalRegistryRecord.js~GlobalRegistryRecord#constructor",
    "access": null,
    "description": "Constructs a new empty object.",
    "lineNumber": 32,
    "params": []
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "userIDs",
    "memberof": "src/graphconnector/GlobalRegistryRecord.js~GlobalRegistryRecord",
    "static": false,
    "longname": "src/graphconnector/GlobalRegistryRecord.js~GlobalRegistryRecord#userIDs",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "getRecord",
    "memberof": "src/graphconnector/GlobalRegistryRecord.js~GlobalRegistryRecord",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GlobalRegistryRecord.js~GlobalRegistryRecord#getRecord",
    "access": null,
    "description": "Constructs a new object representing information about one contact.",
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}  object  A JavaScript Object with all fields for the Global Registry Record."
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "object  A JavaScript Object with all fields for the Global Registry Record."
    }
  },
  {
    "__docId__": 93,
    "kind": "file",
    "name": "src/graphconnector/GraphConnector.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\nimport GraphConnectorContactData from './GraphConnectorContactData';\r\nimport BloomFilter from './BloomFilter';\r\nimport GlobalRegistryRecord from './GlobalRegistryRecord';\r\nimport bitcoin from 'bitcoinjs-lib';\r\nimport bip39 from 'bip39';\r\nimport sjcl from 'sjcl';\r\nimport jsrsasign from 'jsrsasign';\r\nimport base64url from 'base64-url';\r\nimport hex64 from 'hex64';\r\nimport Buffer from 'buffer';\r\n\r\n/**\r\n* The Graph Connector contains the contact list/address book.\r\n* @author beierle@tu-berlin.de\r\n*/\r\nclass GraphConnector {\r\n\r\n  // TODO: import / export methods\r\n\r\n  /**\r\n   * Constructs a new and empty Graph Connector.\r\n   * @param {string}   HypertyRuntimeURL    The Hyperty Runtime URL.\r\n   * @param {messageBus}    MessageBus      The Message Bus.\r\n   */\r\n  constructor(hypertyRuntimeURL, messageBus) {\r\n    this.contacts = [];\r\n    this.lastCalculationBloomFilter1Hop = new Date(0).toISOString();\r\n\r\n    this.globalRegistryRecord = new GlobalRegistryRecord();\r\n    this._prvKey;\r\n    this.privateKey;\r\n\r\n    this.groups = [];\r\n    this.residenceLocation;\r\n    this.firstName;\r\n    this.lastName;\r\n\r\n    this._messageBus = messageBus;\r\n    this._hypertyRuntimeURL = hypertyRuntimeURL;\r\n  }\r\n\r\n  /**\r\n  * Returns the MessageBus.\r\n  * @param {MessageBus}           messageBus    The Message Bus.\r\n  */\r\n  get messageBus() {\r\n    return this._messageBus;\r\n  }\r\n\r\n  /**\r\n  * Sets the MessageBus.\r\n  * @param {MessageBus}           messageBus    The Message Bus.\r\n  */\r\n  set messageBus(messageBus) {\r\n    this._messageBus = messageBus;\r\n  }\r\n\r\n  /**\r\n   * Generates a GUID and returns a mnemonic from which the GUID can be re-created later.\r\n   * @returns  {string}    mnemonic      A string with 16 words.\r\n   */\r\n  generateGUID() {\r\n\r\n    // generate mnemonic and salt\r\n    Buffer.TYPED_ARRAY_SUPPORT = true;\r\n    let mnemonic = bip39.generateMnemonic(160);\r\n\r\n    let saltWord = bip39.generateMnemonic(8);\r\n    this._createKeys(mnemonic, saltWord);\r\n\r\n    // set lasUpdate date\r\n    this.globalRegistryRecord.lastUpdate = new Date().toISOString();\r\n\r\n    // set defualt timeout\r\n    let timeout = new Date();\r\n    timeout.setMonth(timeout.getMonth() + 120);\r\n    this.globalRegistryRecord.timeout = timeout.toISOString();\r\n\r\n    // set default values\r\n    this.globalRegistryRecord.active = 1;\r\n    this.globalRegistryRecord.revoked = 0;\r\n\r\n    // return mnemonic\r\n    let rtn = mnemonic + ' ' + saltWord;\r\n    return rtn;\r\n  }\r\n\r\n  /**\r\n   * Generates a public/private key pair from a given mnemonic (16 words).\r\n   * Expects a string containing 16 words seperated by single spaces.\r\n   * Retrieves data from the Global Registry.\r\n   * @param  {string}     mnemonicAndSalt     A string of 16 words.\r\n   * @returns  {Promise}  Promise          Global Registry Record.\r\n   */\r\n  useGUID(mnemonicAndSalt) {\r\n    // TODO: check if format is correct and if all words are from bip39 english wordlist\r\n    let lastIndex = mnemonicAndSalt.lastIndexOf(' ');\r\n    let mnemonic = mnemonicAndSalt.substring(0, lastIndex);\r\n    let saltWord = mnemonicAndSalt.substring(lastIndex + 1, mnemonicAndSalt.length);\r\n    this._createKeys(mnemonic, saltWord);\r\n\r\n    let _this = this;\r\n\r\n    // retrieve current info from Global Registry and fill this.globalRegistryRecord\r\n    let msg = {\r\n      type: 'READ',\r\n      from: this._hypertyRuntimeURL + '/graph-connector',\r\n      to: 'global://registry/',\r\n      body: { guid: this.globalRegistryRecord.guid }\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      if (_this.messageBus === undefined) {\r\n        reject('MessageBus not found on GraphConnector');\r\n      } else {\r\n\r\n        _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n          // reply should be the JSON returned from the Global Registry REST-interface\r\n          let jwt = reply.body.data;\r\n          let unwrappedJWT = KJUR.jws.JWS.parse(reply.body.data);\r\n          let dataEncoded = unwrappedJWT.payloadObj.data;\r\n          let dataDecoded = base64url.decode(dataEncoded);\r\n          let dataJSON = JSON.parse(dataDecoded);\r\n\r\n          // public key should match\r\n          let sameKey = (dataJSON.publicKey == _this.globalRegistryRecord.publicKey);\r\n          if (!sameKey) {\r\n            reject('Retrieved key does not match!');\r\n          } else {\r\n            let publicKeyObject = jsrsasign.KEYUTIL.getKey(dataJSON.publicKey);\r\n            let encodedString = jwt.split('.').slice(0, 2).join('.');\r\n            let sigValueHex = unwrappedJWT.sigHex;\r\n            let sig = new KJUR.crypto.Signature({alg: 'SHA256withECDSA'});\r\n            sig.init(publicKeyObject);\r\n            sig.updateString(encodedString);\r\n            let isValid = sig.verify(sigValueHex);\r\n\r\n            if (!isValid) {\r\n              reject('Retrieved Record not valid!');\r\n            } else {\r\n              if (typeof dataJSON.userIDs != 'undefined' && dataJSON.userIDs != null) {\r\n                _this.globalRegistryRecord.userIDs = dataJSON.userIDs;\r\n              }\r\n              _this.globalRegistryRecord.lastUpdate = dataJSON.lastUpdate;\r\n              _this.globalRegistryRecord.timeout = dataJSON.timeout;\r\n              _this.globalRegistryRecord.salt = dataJSON.salt;\r\n              _this.globalRegistryRecord.active = dataJSON.active;\r\n              _this.globalRegistryRecord.revoked = dataJSON.revoked;\r\n              resolve(_this.globalRegistryRecord);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates the keys from mnemonic and salt. Also sets public key, guid, and salt for globalRegistryRecord.\r\n   * @param  {string}     mnemonic     A string with 15 words.\r\n   * @param  {string}     salt         A word.\r\n   */\r\n  _createKeys(mnemonic, saltWord) {\r\n\r\n    // generate key pair\r\n    let seed = bip39.mnemonicToSeed(mnemonic);\r\n    Buffer.TYPED_ARRAY_SUPPORT = false;\r\n    let hdnode = bitcoin.HDNode.fromSeedBuffer(seed);\r\n    let ecparams = KJUR.crypto.ECParameterDB.getByName('secp256k1');\r\n    let biPrv = hdnode.keyPair.d; // private key big integer\r\n    let epPub = ecparams.G.multiply(biPrv); // d*G\r\n    let biX = epPub.getX().toBigInteger(); // x from Q\r\n    let biY = epPub.getY().toBigInteger(); // y from Q\r\n    let charlen = ecparams.keylen / 4;\r\n    let hPrv = ('0000000000' + biPrv.toString(16)).slice(-charlen);\r\n    let hX   = ('0000000000' + biX.toString(16)).slice(-charlen);\r\n    let hY   = ('0000000000' + biY.toString(16)).slice(-charlen);\r\n    let hPub = '04' + hX + hY;\r\n    this._prvKey = new KJUR.crypto.ECDSA({curve: 'secp256k1'});\r\n    this._prvKey.setPrivateKeyHex(hPrv);\r\n    this._prvKey.isPrivate = true;\r\n    this._prvKey.isPublic = false;\r\n    let pubKey = new KJUR.crypto.ECDSA({curve: 'secp256k1'});\r\n    this.privateKey = jsrsasign.KEYUTIL.getPEM(this._prvKey, 'PKCS8PRV');\r\n    pubKey.setPublicKeyHex(hPub);\r\n    pubKey.isPrivate = false;\r\n    pubKey.isPublic = true;\r\n    let publicKey = jsrsasign.KEYUTIL.getPEM(pubKey, 'PKCS8PUB');\r\n    publicKey = publicKey.replace(/(\\r\\n|\\n|\\r)/gm, '');\r\n    this.globalRegistryRecord.publicKey = publicKey;\r\n\r\n    // generate salt\r\n    let saltHashedBitArray = sjcl.hash.sha256.hash(saltWord);\r\n    let salt = sjcl.codec.base64.fromBits(saltHashedBitArray);\r\n    this.globalRegistryRecord.salt = salt;\r\n\r\n    // generate GUID\r\n    let iterations = 10000;\r\n    let guidBitArray = sjcl.misc.pbkdf2(this.globalRegistryRecord.publicKey, salt, iterations);\r\n    let guid = sjcl.codec.base64url.fromBits(guidBitArray);\r\n    this.globalRegistryRecord.guid = guid;\r\n  }\r\n\r\n  /**\r\n   * SignGenerates a public/private key pair from a given mnemonic.\r\n   * @returns  {string}     JWT     JSON Web Token ready to commit to Global Registry.\r\n   */\r\n  signGlobalRegistryRecord() {\r\n\r\n    let record = this.globalRegistryRecord.getRecord();\r\n    let recordString = JSON.stringify(record);\r\n    let recordStringBase64 = base64url.encode(recordString);\r\n\r\n    let jwtTemp = KJUR.jws.JWS.sign(null, {alg: 'ES256'}, {data: recordStringBase64}, this._prvKey);\r\n    let encodedString = jwtTemp.split('.').slice(0, 2).join('.');\r\n\r\n    let sig = new KJUR.crypto.Signature({alg: 'SHA256withECDSA'});\r\n    sig.init(this.privateKey);\r\n    sig.updateString(encodedString);\r\n\r\n    let signatureHex = sig.sign();\r\n    let signature = hex64.toBase64(signatureHex);\r\n    let jwt = encodedString + '.' + signature;\r\n    return jwt;\r\n  }\r\n\r\n  /**\r\n   * Takes the Global Registry Record as a signed JWT and sends it to the Global Registry via the MessageBus.\r\n   * Returns the response code of the REST-interface of the Global Registry as a Promise.\r\n   * @param  {string}     jwt     The Global Registry Record as a signed JWT.\r\n   * @returns {Propmise}  Promise Response Code from Global Registry.\r\n   */\r\n  sendGlobalRegistryRecord(jwt) {\r\n\r\n    let payloadObj = KJUR.jws.JWS.parse(jwt).payloadObj;\r\n    let guid = payloadObj.guid;\r\n\r\n    let _this = this;\r\n\r\n    let msg = {\r\n      type: 'CREATE',\r\n      from: this._hypertyRuntimeURL + '/graph-connector',\r\n      to: 'global://registry/',\r\n      body: { guid: this.globalRegistryRecord.guid, jwt: jwt }\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      if (_this.messageBus === undefined) {\r\n        reject('MessageBus not found on GraphConnector');\r\n      } else {\r\n\r\n        _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n          let responseCode = reply.body.responseCode;\r\n          if (responseCode == 200) {\r\n            resolve(200);\r\n          } else {\r\n            reject(responseCode);\r\n          }\r\n\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Queries the Global Registry for a given GUID.\r\n   * Returns a Graph Connector Contact Data as a Promise.\r\n   * @param  {string}   guid  The GUID to query the Global Registry for\r\n   * @returns   {Promise}   Promise   Graph Connector Contact Data containing UserIDs.\r\n   */\r\n   queryGlobalRegistry(guid) {\r\n\r\n     let _this = this;\r\n\r\n     let msg = {\r\n       type: 'READ',\r\n       from: this._hypertyRuntimeURL + '/graph-connector',\r\n       to: 'global://registry/',\r\n       body: { guid: guid }\r\n     };\r\n\r\n     return new Promise(function(resolve, reject) {\r\n\r\n       if (_this.messageBus === undefined) {\r\n         reject('MessageBus not found on GraphConnector');\r\n       } else {\r\n\r\n         _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n           // reply should be the JSON returned from the Global Registry REST-interface\r\n           let jwt = reply.body.data;\r\n           let unwrappedJWT = KJUR.jws.JWS.parse(reply.body.data);\r\n           let dataEncoded = unwrappedJWT.payloadObj.data;\r\n           let dataDecoded = base64url.decode(dataEncoded);\r\n           let dataJSON = JSON.parse(dataDecoded);\r\n\r\n           let publicKeyObject = jsrsasign.KEYUTIL.getKey(dataJSON.publicKey);\r\n           let encodedString = jwt.split('.').slice(0, 2).join('.');\r\n           let sigValueHex = unwrappedJWT.sigHex;\r\n           let sig = new KJUR.crypto.Signature({alg: 'SHA256withECDSA'});\r\n           sig.init(publicKeyObject);\r\n           sig.updateString(encodedString);\r\n           let isValid = sig.verify(sigValueHex);\r\n\r\n           if (!isValid) {\r\n             reject('Retrieved Record not valid!');\r\n           } else {\r\n             let queriedContact = new GraphConnectorContactData(dataJSON.guid, '', '');\r\n             if (typeof dataJSON.userIDs != 'undefined' && dataJSON.userIDs != null) {\r\n               queriedContact.userIDs = dataJSON.userIDs;\r\n             }\r\n             resolve(queriedContact);\r\n           }\r\n         });\r\n       }\r\n     });\r\n\r\n   }\r\n\r\n  /**\r\n   * Adds a UserID for the user.\r\n   * @param  {string}     userID          The UserID for a Domain Registry to add for the user.\r\n   */\r\n  addUserID(userID) {\r\n    // check if already inside\r\n    let found = false;\r\n    for (let i = 0; i < this.globalRegistryRecord.userIDs.length; i++) {\r\n      if (this.globalRegistryRecord.userIDs == userID) {\r\n        found = true;\r\n      }\r\n    }\r\n    if (!found) {\r\n      this.globalRegistryRecord.userIDs.push(userID);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a UserID for the user.\r\n   * @param  {string}     userID          The UserID to remove.\r\n   */\r\n  removeUserID(userID) {\r\n    for (let i = 0; i < this.globalRegistryRecord.userIDs.length; i++) {\r\n      if (this.globalRegistryRecord.userIDs == userID) {\r\n        this.globalRegistryRecord.userIDs.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a contact to the Graph Connector.\r\n   * @param  {string}   guid          GUID of the new contact.\r\n   * @param  {string}   firstName     First name of the new contact.\r\n   * @param  {string}   lastname      Last name of the new contact.\r\n   */\r\n  addContact(guid, firstName, lastName) {\r\n\r\n    // TODO: what if two contacts have the same GUID?\r\n    // TODO: reject invalid GUIDs\r\n\r\n    this.contacts.push(new GraphConnectorContactData(guid, firstName, lastName));\r\n  }\r\n\r\n  /**\r\n   * Remove a contact from the Graph Connector.\r\n   * @param  {string}     guid      GUID of the user to be removed.\r\n   */\r\n  removeContact(guid) {\r\n    // remove from contacts\r\n    for (let i = 0; i < this.contacts.length; i++) {\r\n      if (this.contacts[i].guid == guid) {\r\n        this.contacts.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    // re-calculate BF1hop\r\n    this.calculateBloomFilter1Hop();\r\n  }\r\n\r\n  /**\r\n   * Calculates the Bloom filter containing all non-private contacts.\r\n   */\r\n  calculateBloomFilter1Hop() {\r\n    let bf = new BloomFilter(\r\n      431328,   // number of bits to allocate. With 30000 entries, we have a false positive rate of 0.1 %.\r\n      10        // number of hash functions.\r\n    );\r\n    for (let i = 0; i < this.contacts.length; i++) {\r\n      if (!this.contacts[i].privateContact) {\r\n        bf.add(this.contacts[i].guid);\r\n      }\r\n    }\r\n    this.contactsBloomFilter1Hop = bf;\r\n    this.lastCalculationBloomFilter1Hop = new Date().toISOString();\r\n  }\r\n\r\n  /**\r\n   * Gets contacts by name.\r\n   * @param  {string}   name    First or last name to look for in the contact list.\r\n   * @returns  {array}   matchingContacts       Contacts matching the given name. The format is: Contacts<GraphConnectorContactData>.\r\n   */\r\n  getContact(name) {\r\n    // TODO: optimize, e.g., find misspelled people\r\n    let rtnArray = [];\r\n    for (let i = 0; i < this.contacts.length; i++) {\r\n      if (this.contacts[i].firstName == name || this.contacts[i].lastName == name) {\r\n        rtnArray.push(this.contacts[i]);\r\n      }\r\n    }\r\n    return rtnArray;\r\n  }\r\n\r\n  /**\r\n   * Checks, if the given GUID is known and returns a list of contacs that are direct connections as well as a list of contacts that (most likely) know the given contact.\r\n   * @param  {string}     guid      GUID of the contact to look for.\r\n   * @returns  {array}    relatedContacts     List of related direct contacts and of related friends-of-friends contacts.The format is: RelatedContacts<Direct<GraphConnectorContactData>,FoF<GraphConnectorContactData>>.\r\n   */\r\n  checkGUID(guid) {\r\n    let directContactsArray = [];\r\n    let fofContactsArray = [];\r\n    for (let i = 0; i < this.contacts.length; i++) {\r\n      if (this.contacts[i].guid == guid) {\r\n        directContactsArray.push(this.contacts[i]);\r\n      }\r\n      let bf1hop = this.contacts[i].contactsBloomFilter1Hop;\r\n      if (bf1hop !== undefined) {\r\n        if (bf1hop.test(guid)) {\r\n          fofContactsArray.push(this.contacts[i]);\r\n        }\r\n      }\r\n    }\r\n    let rtnArray = [];\r\n    rtnArray.push(directContactsArray, fofContactsArray);\r\n    return rtnArray;\r\n  }\r\n\r\n  // TODO: exportGraphData(?){}\r\n  // TODO: importGraphData(?){}\r\n\r\n}\r\n\r\nexport default GraphConnector;\r\n",
    "static": true,
    "longname": "src/graphconnector/GraphConnector.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 94,
    "kind": "class",
    "name": "GraphConnector",
    "memberof": "src/graphconnector/GraphConnector.js",
    "static": true,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/graphconnector/GraphConnector.js",
    "importStyle": "GraphConnector",
    "description": "The Graph Connector contains the contact list/address book.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "beierle@tu-berlin.de"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 95,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#constructor",
    "access": null,
    "description": "Constructs a new and empty Graph Connector.",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "HypertyRuntimeURL",
        "description": "The Hyperty Runtime URL."
      },
      {
        "nullable": null,
        "types": [
          "messageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "MessageBus",
        "description": "The Message Bus."
      }
    ]
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "contacts",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#contacts",
    "access": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "lastCalculationBloomFilter1Hop",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#lastCalculationBloomFilter1Hop",
    "access": null,
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "globalRegistryRecord",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#globalRegistryRecord",
    "access": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "groups",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#groups",
    "access": null,
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "_messageBus",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#_messageBus",
    "access": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "_hypertyRuntimeURL",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#_hypertyRuntimeURL",
    "access": null,
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "get",
    "name": "messageBus",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#messageBus",
    "access": null,
    "description": "Returns the MessageBus.",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": "The Message Bus."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "set",
    "name": "messageBus",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#messageBus",
    "access": null,
    "description": "Sets the MessageBus.",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": "The Message Bus."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "_messageBus",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#_messageBus",
    "access": null,
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "generateGUID",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#generateGUID",
    "access": null,
    "description": "Generates a GUID and returns a mnemonic from which the GUID can be re-created later.",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {string}    mnemonic      A string with 16 words."
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "mnemonic      A string with 16 words."
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "useGUID",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#useGUID",
    "access": null,
    "description": "Generates a public/private key pair from a given mnemonic (16 words).\nExpects a string containing 16 words seperated by single spaces.\nRetrieves data from the Global Registry.",
    "lineNumber": 117,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {Promise}  Promise          Global Registry Record."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mnemonicAndSalt",
        "description": "A string of 16 words."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise          Global Registry Record."
    }
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "_createKeys",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#_createKeys",
    "access": null,
    "description": "Creates the keys from mnemonic and salt. Also sets public key, guid, and salt for globalRegistryRecord.",
    "lineNumber": 186,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mnemonic",
        "description": "A string with 15 words."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "salt",
        "description": "A word."
      }
    ]
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_prvKey",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#_prvKey",
    "access": null,
    "description": null,
    "lineNumber": 202,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "privateKey",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#privateKey",
    "access": null,
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "signGlobalRegistryRecord",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#signGlobalRegistryRecord",
    "access": null,
    "description": "SignGenerates a public/private key pair from a given mnemonic.",
    "lineNumber": 231,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {string}     JWT     JSON Web Token ready to commit to Global Registry."
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "JWT     JSON Web Token ready to commit to Global Registry."
    }
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "sendGlobalRegistryRecord",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#sendGlobalRegistryRecord",
    "access": null,
    "description": "Takes the Global Registry Record as a signed JWT and sends it to the Global Registry via the MessageBus.\nReturns the response code of the REST-interface of the Global Registry as a Promise.",
    "lineNumber": 256,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Propmise}  Promise Response Code from Global Registry."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "jwt",
        "description": "The Global Registry Record as a signed JWT."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Propmise"
      ],
      "spread": false,
      "description": "Promise Response Code from Global Registry."
    }
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "queryGlobalRegistry",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#queryGlobalRegistry",
    "access": null,
    "description": "Queries the Global Registry for a given GUID.\nReturns a Graph Connector Contact Data as a Promise.",
    "lineNumber": 296,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "  {Promise}   Promise   Graph Connector Contact Data containing UserIDs."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "guid",
        "description": "The GUID to query the Global Registry for"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise   Graph Connector Contact Data containing UserIDs."
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "addUserID",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#addUserID",
    "access": null,
    "description": "Adds a UserID for the user.",
    "lineNumber": 349,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userID",
        "description": "The UserID for a Domain Registry to add for the user."
      }
    ]
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "removeUserID",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#removeUserID",
    "access": null,
    "description": "Removes a UserID for the user.",
    "lineNumber": 366,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userID",
        "description": "The UserID to remove."
      }
    ]
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "addContact",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#addContact",
    "access": null,
    "description": "Add a contact to the Graph Connector.",
    "lineNumber": 380,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "guid",
        "description": "GUID of the new contact."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "firstName",
        "description": "First name of the new contact."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "lastname",
        "description": "Last name of the new contact."
      }
    ]
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "removeContact",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#removeContact",
    "access": null,
    "description": "Remove a contact from the Graph Connector.",
    "lineNumber": 392,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "guid",
        "description": "GUID of the user to be removed."
      }
    ]
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "calculateBloomFilter1Hop",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#calculateBloomFilter1Hop",
    "access": null,
    "description": "Calculates the Bloom filter containing all non-private contacts.",
    "lineNumber": 407,
    "params": []
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "contactsBloomFilter1Hop",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#contactsBloomFilter1Hop",
    "access": null,
    "description": null,
    "lineNumber": 417,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "lastCalculationBloomFilter1Hop",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#lastCalculationBloomFilter1Hop",
    "access": null,
    "description": null,
    "lineNumber": 418,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "getContact",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#getContact",
    "access": null,
    "description": "Gets contacts by name.",
    "lineNumber": 426,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {array}   matchingContacts       Contacts matching the given name. The format is: Contacts<GraphConnectorContactData>."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "First or last name to look for in the contact list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "matchingContacts       Contacts matching the given name. The format is: Contacts<GraphConnectorContactData>."
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "checkGUID",
    "memberof": "src/graphconnector/GraphConnector.js~GraphConnector",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnector.js~GraphConnector#checkGUID",
    "access": null,
    "description": "Checks, if the given GUID is known and returns a list of contacs that are direct connections as well as a list of contacts that (most likely) know the given contact.",
    "lineNumber": 442,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {array}    relatedContacts     List of related direct contacts and of related friends-of-friends contacts.The format is: RelatedContacts<Direct<GraphConnectorContactData>,FoF<GraphConnectorContactData>>."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "guid",
        "description": "GUID of the contact to look for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "relatedContacts     List of related direct contacts and of related friends-of-friends contacts.The format is: RelatedContacts<Direct<GraphConnectorContactData>,FoF<GraphConnectorContactData>>."
    }
  },
  {
    "__docId__": 122,
    "kind": "file",
    "name": "src/graphconnector/GraphConnectorContactData.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n/**\r\n* Represents information about a contact.\r\n* @author beierle@tu-berlin.de\r\n*/\r\nclass GraphConnectorContactData {\r\n\r\n  /**\r\n   * Constructs a new object representing information about one contact.\r\n   * @param  {String}     guid        The GUID of the new contact.\r\n   * @param  {String}   firstName   The first name of the new contact.\r\n   * @param  {String}   lastName    The last name of the new contact.\r\n   */\r\n    constructor(guid, firstName, lastName) {\r\n      this._guid = guid;\r\n      this._userIDs = [];\r\n      this._firstName = firstName;\r\n      this._lastName = lastName;\r\n      this._privateContact = false;\r\n      this._lastSyncBloomFilter1Hop = new Date(0).toISOString();\r\n      this._lastSyncDomainUserIDs = new Date(0).toISOString();\r\n      this._residenceLocation;\r\n      this._groups = [];\r\n    }\r\n\r\n    /**\r\n     * Returns the GUID.\r\n     * @returns  {String}     GUID        GUID of the contact.\r\n     */\r\n    get guid() {\r\n      return this._guid;\r\n    }\r\n\r\n    /**\r\n     * Sets the GUID.\r\n     * @param  {String}     GUID        GUID of the contat.\r\n     */\r\n    set guid(guid) {\r\n      this._guid = guid;\r\n    }\r\n\r\n    /**\r\n     * Returns the user IDs.\r\n     * @returns  {List<String>}     userIDs        UserIDs of the contact.\r\n     */\r\n    get userIDs() {\r\n      return this._userIDs;\r\n    }\r\n\r\n    /**\r\n     * Sets the userIDs.\r\n     * @param  {List<String>}     userIDs        UserIDs of the contat.\r\n     */\r\n    set userIDs(userIDs) {\r\n      this._userIDs = userIDs;\r\n      this._lastSyncDomainUserIDs = new Date().toISOString();\r\n    }\r\n\r\n    /**\r\n     * Returns the first name.\r\n     * @returns  {String}     firstName        First name of the contact.\r\n     */\r\n    get firstName() {\r\n      return this._firstName;\r\n    }\r\n\r\n    /**\r\n     * Sets the first name.\r\n     * @param  {String}     firstName        First name of the contat.\r\n     */\r\n    set firstName(firstName) {\r\n      this._firstName = firstName;\r\n    }\r\n\r\n    /**\r\n     * Returns the last name.\r\n     * @returns  {String}     lastName        Last name of the contact.\r\n     */\r\n    get lastName() {\r\n      return this._lastName;\r\n    }\r\n\r\n    /**\r\n     * Sets the last name.\r\n     * @param  {String}     lastName        Last name of the contat.\r\n     */\r\n    set lastName(lastName) {\r\n      this._lastName = lastName;\r\n    }\r\n\r\n    /**\r\n     * Returns the privacy status of the contact.\r\n     * @returns  {Boolean}     privateContact        True/false value indicating the privacy status of the contact.\r\n     */\r\n    get privateContact() {\r\n      return this._privateContact;\r\n    }\r\n\r\n    /**\r\n     * Sets the privacy status of the contact according to the given Boolean value.\r\n     * @param  {Boolean}     boolPrivate        True/false value indicating the privacy status of the contact.\r\n     */\r\n    set privateContact(boolPrivate) {\r\n      this._privateContact = boolPrivate;\r\n    }\r\n\r\n    /**\r\n     * Returns the Bloom filter containing the hashed GUIDs of the contacts for the contact.\r\n     * @returns  {BloomFilter}     bf        Bloom filter for the contact.\r\n     */\r\n    get contactsBloomFilter1Hop() {\r\n      return this._contactsBloomFilter1Hop;\r\n    }\r\n\r\n    /**\r\n     * Sets the friends-of-friends Bloom filter containing the hashed GUIDs of the contacts for the contact.\r\n     * @param  {BloomFilter}     bf        Bloom filter for the contact.\r\n     */\r\n    set contactsBloomFilter1Hop(bf) {\r\n      this._contactsBloomFilter1Hop = bf;\r\n      this._lastSyncBloomFilter1Hop = new Date().toISOString();\r\n    }\r\n\r\n    /**\r\n     * Returns the geohash of the residence location.\r\n     * @returns  {String}     geohash        Geohash of the residence location.\r\n     */\r\n    get residenceLocation() {\r\n      return this._residenceLocation;\r\n    }\r\n\r\n    /**\r\n     * Sets the geohash of the residence location.\r\n     * @param  {String}     geohash        Geohash of the residence location.\r\n     */\r\n    set residenceLocation(geohash) {\r\n      this._residenceLocation = geohash;\r\n    }\r\n\r\n    /**\r\n     * Returns the groups.\r\n     * @returns  {List<String>}     groups        Groups of the contact.\r\n     */\r\n    get groups() {\r\n      return this._groups;\r\n    }\r\n\r\n    /**\r\n     * Sets the groups.\r\n     * @param  {List<String>}     groups        Groups of the contat.\r\n     */\r\n    set groups(groups) {\r\n      this._groups = groups;\r\n    }\r\n\r\n}\r\n\r\nexport default GraphConnectorContactData;\r\n",
    "static": true,
    "longname": "src/graphconnector/GraphConnectorContactData.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 123,
    "kind": "class",
    "name": "GraphConnectorContactData",
    "memberof": "src/graphconnector/GraphConnectorContactData.js",
    "static": true,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/graphconnector/GraphConnectorContactData.js",
    "importStyle": "GraphConnectorContactData",
    "description": "Represents information about a contact.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "beierle@tu-berlin.de"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 124,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#constructor",
    "access": null,
    "description": "Constructs a new object representing information about one contact.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "guid",
        "description": "The GUID of the new contact."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "firstName",
        "description": "The first name of the new contact."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "lastName",
        "description": "The last name of the new contact."
      }
    ]
  },
  {
    "__docId__": 125,
    "kind": "member",
    "name": "_guid",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_guid",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "member",
    "name": "_userIDs",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_userIDs",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "member",
    "name": "_firstName",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_firstName",
    "access": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "member",
    "name": "_lastName",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_lastName",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "member",
    "name": "_privateContact",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_privateContact",
    "access": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "_lastSyncBloomFilter1Hop",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_lastSyncBloomFilter1Hop",
    "access": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "member",
    "name": "_lastSyncDomainUserIDs",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_lastSyncDomainUserIDs",
    "access": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "member",
    "name": "_groups",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_groups",
    "access": null,
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "get",
    "name": "guid",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#guid",
    "access": null,
    "description": "Returns the GUID.",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {String}     GUID        GUID of the contact."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "GUID        GUID of the contact."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "set",
    "name": "guid",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#guid",
    "access": null,
    "description": "Sets the GUID.",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "GUID",
        "description": "GUID of the contat."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "_guid",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_guid",
    "access": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "get",
    "name": "userIDs",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#userIDs",
    "access": null,
    "description": "Returns the user IDs.",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {List<String>}     userIDs        UserIDs of the contact."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "List<String>"
      ],
      "spread": false,
      "description": "userIDs        UserIDs of the contact."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "set",
    "name": "userIDs",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#userIDs",
    "access": null,
    "description": "Sets the userIDs.",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "List<String>"
        ],
        "spread": false,
        "optional": false,
        "name": "userIDs",
        "description": "UserIDs of the contat."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "_userIDs",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_userIDs",
    "access": null,
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "_lastSyncDomainUserIDs",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_lastSyncDomainUserIDs",
    "access": null,
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "get",
    "name": "firstName",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#firstName",
    "access": null,
    "description": "Returns the first name.",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {String}     firstName        First name of the contact."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "firstName        First name of the contact."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "set",
    "name": "firstName",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#firstName",
    "access": null,
    "description": "Sets the first name.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "firstName",
        "description": "First name of the contat."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "_firstName",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_firstName",
    "access": null,
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "get",
    "name": "lastName",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#lastName",
    "access": null,
    "description": "Returns the last name.",
    "lineNumber": 100,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {String}     lastName        Last name of the contact."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "lastName        Last name of the contact."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "set",
    "name": "lastName",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#lastName",
    "access": null,
    "description": "Sets the last name.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "lastName",
        "description": "Last name of the contat."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "member",
    "name": "_lastName",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_lastName",
    "access": null,
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "get",
    "name": "privateContact",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#privateContact",
    "access": null,
    "description": "Returns the privacy status of the contact.",
    "lineNumber": 116,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {Boolean}     privateContact        True/false value indicating the privacy status of the contact."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": "privateContact        True/false value indicating the privacy status of the contact."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "set",
    "name": "privateContact",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#privateContact",
    "access": null,
    "description": "Sets the privacy status of the contact according to the given Boolean value.",
    "lineNumber": 124,
    "params": [
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "boolPrivate",
        "description": "True/false value indicating the privacy status of the contact."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "member",
    "name": "_privateContact",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_privateContact",
    "access": null,
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "get",
    "name": "contactsBloomFilter1Hop",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#contactsBloomFilter1Hop",
    "access": null,
    "description": "Returns the Bloom filter containing the hashed GUIDs of the contacts for the contact.",
    "lineNumber": 132,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {BloomFilter}     bf        Bloom filter for the contact."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BloomFilter"
      ],
      "spread": false,
      "description": "bf        Bloom filter for the contact."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "set",
    "name": "contactsBloomFilter1Hop",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#contactsBloomFilter1Hop",
    "access": null,
    "description": "Sets the friends-of-friends Bloom filter containing the hashed GUIDs of the contacts for the contact.",
    "lineNumber": 140,
    "params": [
      {
        "nullable": null,
        "types": [
          "BloomFilter"
        ],
        "spread": false,
        "optional": false,
        "name": "bf",
        "description": "Bloom filter for the contact."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "member",
    "name": "_contactsBloomFilter1Hop",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_contactsBloomFilter1Hop",
    "access": null,
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "_lastSyncBloomFilter1Hop",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_lastSyncBloomFilter1Hop",
    "access": null,
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "get",
    "name": "residenceLocation",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#residenceLocation",
    "access": null,
    "description": "Returns the geohash of the residence location.",
    "lineNumber": 149,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {String}     geohash        Geohash of the residence location."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "geohash        Geohash of the residence location."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "set",
    "name": "residenceLocation",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#residenceLocation",
    "access": null,
    "description": "Sets the geohash of the residence location.",
    "lineNumber": 157,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "geohash",
        "description": "Geohash of the residence location."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "_residenceLocation",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_residenceLocation",
    "access": null,
    "description": null,
    "lineNumber": 158,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "get",
    "name": "groups",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#groups",
    "access": null,
    "description": "Returns the groups.",
    "lineNumber": 165,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {List<String>}     groups        Groups of the contact."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "List<String>"
      ],
      "spread": false,
      "description": "groups        Groups of the contact."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "set",
    "name": "groups",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#groups",
    "access": null,
    "description": "Sets the groups.",
    "lineNumber": 173,
    "params": [
      {
        "nullable": null,
        "types": [
          "List<String>"
        ],
        "spread": false,
        "optional": false,
        "name": "groups",
        "description": "Groups of the contat."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "member",
    "name": "_groups",
    "memberof": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData",
    "static": false,
    "longname": "src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData#_groups",
    "access": null,
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "file",
    "name": "src/identity/Crypto.js",
    "content": "/**\r\n* Class with the cryptographic functions for the authentication protocol\r\n*\r\n*/\r\nclass Crypto {\r\n\r\n  constructor() {\r\n    let _this = this;\r\n\r\n  }\r\n\r\n  /**\r\n  * encode a byteArray value in base 64 encode\r\n  * @param   {byteArray}    value    byteArray value\r\n  * @return  {string}   encoded value\r\n  */\r\n  encode(value) {\r\n    return btoa(value);\r\n  }\r\n\r\n  /**\r\n  * decode a base64 value in a new Uint8Array\r\n  * @param   {string}    value    value encoded in base 64\r\n  * @return  {byteArray} decodedValue\r\n  */\r\n  decode(value) {\r\n    return new Uint8Array(JSON.parse('[' + atob(value) + ']'));\r\n  }\r\n\r\n  encryptRSA(pubKey, data) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      _this._importRSAencryptKey(new Uint8Array(pubKey)).then(function(publicKey) {\r\n\r\n        crypto.subtle.encrypt(\r\n            {\r\n              name: 'RSA-OAEP'\r\n            },\r\n            publicKey, //from generateKey or importKey above\r\n            data //ArrayBuffer of data you want to encrypt\r\n        )\r\n        .then(function(encrypted) {\r\n          //returns an ArrayBuffer containing the encrypted data\r\n          //console.log('crypto-encryptRSA', new Uint8Array(encrypted));\r\n          resolve(new Uint8Array(encrypted));\r\n\r\n        }).catch(function(err) {\r\n          console.log('crypto-encryptRSA', err);\r\n          reject(err);\r\n        });\r\n\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n  decryptRSA(privKey, data) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      _this._importRSAdecryptKey(privKey).then(function(privateKey) {\r\n\r\n        crypto.subtle.decrypt(\r\n            {\r\n              name: 'RSA-OAEP'\r\n            },\r\n            privateKey, //from generateKey or importKey above\r\n            data //ArrayBuffer of the data\r\n        )\r\n        .then(function(decrypted) {\r\n\r\n          let decryptedData = new Uint8Array(decrypted);\r\n\r\n          //console.log('crypto-decryptRSA', decryptedData);\r\n          resolve(decryptedData);\r\n\r\n        }).catch(function(err) {\r\n          console.log('crypto-decryptRSA', err);\r\n          reject(err);\r\n        });\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  signRSA(privKey, data) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      _this._importRSAsignKey(privKey).then(function(privateKey) {\r\n\r\n        crypto.subtle.sign(\r\n            {\r\n              name: 'RSASSA-PKCS1-v1_5'\r\n            },\r\n            privateKey, //from generateKey or importKey above\r\n            _this._utf8Encode(data) //ArrayBuffer of data you want to sign\r\n        )\r\n        .then(function(signature) {\r\n          //returns an ArrayBuffer containing the signature\r\n          //console.log('crypto-signRSA', new Uint8Array(signature));\r\n          resolve(new Uint8Array(signature));\r\n\r\n        }).catch(function(err) {\r\n          console.log('crypto-signRSA', err);\r\n          reject(err);\r\n        });\r\n\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  verifyRSA(pubKey, data, signature) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      _this._importRSAverifyKey(pubKey).then(function(publicKey) {\r\n\r\n        crypto.subtle.verify(\r\n            {\r\n              name: 'RSASSA-PKCS1-v1_5'\r\n            },\r\n            publicKey, //from generateKey or importKey above\r\n            signature, //ArrayBuffer of the signature\r\n            _this._utf8Encode(data) //ArrayBuffer of the data\r\n        )\r\n        .then(function(isvalid) {\r\n          //returns a boolean on whether the signature is true or not\r\n          //console.log('crypto-verifyRSA', isvalid);\r\n          resolve(isvalid);\r\n\r\n        }).catch(function(err) {\r\n          console.log('crypto-verifyRSA', err);\r\n          reject(err);\r\n        });\r\n\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  encryptAES(key, data, iv) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      _this._importAESkey(key).then(function(aesKey) {\r\n\r\n        crypto.subtle.encrypt(\r\n            {\r\n              name: 'AES-CBC',\r\n              //Don't re-use initialization vectors!\r\n              //Always generate a new iv every time your encrypt!\r\n              iv: iv\r\n            },\r\n            aesKey, //from generateKey or importKey above\r\n            _this._utf8Encode(data) //ArrayBuffer of data you want to encrypt\r\n        )\r\n        .then(function(encrypted) {\r\n          //returns an ArrayBuffer containing the encrypted data\r\n          //console.log('crypto-encryptAES', new Uint8Array(encrypted));\r\n          resolve(new Uint8Array(encrypted));\r\n\r\n        }).catch(function(err) {\r\n          console.log('crypto-encryptAES', err);\r\n          reject(err);\r\n        });\r\n\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  decryptAES(key, data, iv) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      _this._importAESkey(key).then(function(aesKey) {\r\n\r\n        crypto.subtle.decrypt(\r\n            {\r\n              name: 'AES-CBC',\r\n              iv: iv\r\n            },\r\n            aesKey, //from generateKey or importKey above\r\n            data //ArrayBuffer of the data\r\n        )\r\n        .then(function(decrypted) {\r\n\r\n          let decodedData = _this._utf8Decode(new Uint8Array(decrypted));\r\n          //console.log('crypto-decryptAES', decodedData);\r\n          resolve(decodedData);\r\n\r\n        }).catch(function(err) {\r\n          console.log('crypto-decryptAES', err);\r\n          reject(err);\r\n        });\r\n\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  /**\r\n  * creates a hash using the HMAC algorithm\r\n  * @param  {byteArray}    key       key to be used in the hmac\r\n  * @param  {string}      data       information to be hashed\r\n  * @return  {byteArray}   signature  resulting hash\r\n  */\r\n  hashHMAC(key, data) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve,reject) {\r\n\r\n      _this._importHMACkey(key).then(function(hmacKey) {\r\n\r\n        crypto.subtle.sign(\r\n        {\r\n          name: 'HMAC'\r\n        },\r\n        hmacKey, //from generateKey or importKey above\r\n        _this._utf8Encode(data) //ArrayBuffer of data you want to sign\r\n        )\r\n        .then(function(signature) {\r\n          //console.log('crypto-hashHMAC', signature);\r\n\r\n          //returns an ArrayBuffer containing the signature\r\n          resolve(new Uint8Array(signature));\r\n\r\n        }).catch(function(err) {\r\n          console.log('crypto-hashHMAC', err);\r\n          reject(err);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * verifies an hash using the HMAC algorithm\r\n  * @param  {byteArray}    key       key to be used in the hmac\r\n  * @param  {string}      data       information to be hashed to compare\r\n  * @param  {byteArray}  signature   hash to compare with the received data\r\n  * @return  {boolean}   isvalid     boolean saying if the data corresponds to the hash received\r\n  */\r\n  verifyHMAC(key, data, signature) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve,reject) {\r\n\r\n      _this._importHMACkey(key).then(function(hmacKey) {\r\n\r\n        crypto.subtle.verify(\r\n          {\r\n            name: 'HMAC'\r\n          },\r\n          hmacKey, //from generateKey or importKey above\r\n          signature, //ArrayBuffer of the signature\r\n          _this._utf8Encode(data) //ArrayBuffer of the data\r\n        )\r\n        .then(function(isvalid) {\r\n          //returns a boolean on whether the signature is true or not\r\n          //console.log('crypto-verifyHMAC', isvalid);\r\n          (isvalid) ? resolve(isvalid) : reject(isvalid);\r\n\r\n        }).catch(function(err) {\r\n          console.error('crypto-verifyHMAC', err);\r\n          reject(err);\r\n        });\r\n\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * generates a RSA public/private key pair with a modulus length of 2048 bits\r\n  * @return  {JSON}   keyPair    json containing the public and private keys\r\n  */\r\n  generateRSAKeyPair() {\r\n    let _this = this;\r\n    let keyPair = {};\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      crypto.subtle.generateKey(\r\n      {\r\n        name: 'RSA-PSS',\r\n        modulusLength: 2048, //can be 1024, 2048, or 4096\r\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\r\n        hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\r\n      },\r\n      true, //whether the key is extractable (i.e. can be used in exportKey)\r\n      ['sign', 'verify'] //can be any combination of 'sign' and 'verify'\r\n\r\n      ).then(function(key) {\r\n        //returns a keypair object\r\n        //console.log(key);\r\n\r\n        crypto.subtle.exportKey(\r\n          'spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\r\n          key.publicKey //can be a publicKey or privateKey, as long as extractable was true\r\n        ).then(function(publicKey) {\r\n          //returns the exported key data\r\n          keyPair.public  = new Uint8Array(publicKey);\r\n          return crypto.subtle.exportKey(\r\n            'pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\r\n            key.privateKey //can be a publicKey or privateKey, as long as extractable was true\r\n          );\r\n        }).then(function(privateKey) {\r\n          keyPair.private  = new Uint8Array(privateKey);\r\n          //console.log('crypto-generateRSAKeyPair', keyPair);\r\n\r\n          resolve(keyPair);\r\n\r\n        }).catch(function(err) {\r\n          console.error(err);\r\n          reject(err);\r\n        });\r\n\r\n      }).catch(function(err) {\r\n        console.error(err);\r\n        reject(err);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * Generates a 128 bit random value.\r\n  * @return {byteArray}  array    random value\r\n  */\r\n  generateIV() {\r\n    let _this = this;\r\n\r\n    let array = new  Uint8Array(16);\r\n    crypto.getRandomValues(array);\r\n\r\n    return array;\r\n  }\r\n\r\n  /**\r\n  * Generates a 256 bit random value. 32 bits are extrated from the machine time,\r\n  * the remaining are generated randomly\r\n  * @return {byteArray}  array    random value\r\n  */\r\n  generateRandom() {\r\n    let _this = this;\r\n\r\n    let array = new  Uint8Array(32);\r\n    crypto.getRandomValues(array);\r\n\r\n    let date = Date.now();\r\n    let dateEncoded = _this._utf8Encode(date);\r\n\r\n    //extract the least significant 4 bytes in the date\r\n    let finalDate = dateEncoded.slice(dateEncoded.length - 4, dateEncoded.length);\r\n\r\n    // add in the first 4 bytes of the array the bytes extracted previously;\r\n    for (let i = 0; i < 4; i++) { array[i] = finalDate[i]; }\r\n    return array;\r\n  }\r\n\r\n  /**\r\n  * generates a premaster secret (PMS) of 48 bytes (384 bits) randomly\r\n  * @return {byteArray}  array    premaster secret key\r\n  */\r\n  generatePMS() {\r\n    let _this = this;\r\n\r\n    let array = new Uint8Array(48);\r\n    crypto.getRandomValues(array);\r\n    return array;\r\n  }\r\n\r\n  /**\r\n  * generates a masterKey secret (PMS) of 48 bytes (384 bits) using the premaster secret and\r\n  * two randoms\r\n  * @return {byteArray}  array    master secret key with 48 bytes\r\n  */\r\n  generateMasterSecret(hmacKey, data) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      let key = new Uint8Array(48);\r\n      let seed = data;\r\n\r\n      _this._digest(hmacKey).then((digestedKey) => {\r\n\r\n        _this.hashHMAC(digestedKey, seed).then(function(keypart0) {\r\n\r\n          //copy the first 32 bytes into the key\r\n          for (let i = 0; i < 32; i++) { key[i] = keypart0[i]; }\r\n          return _this.hashHMAC(digestedKey, seed + keypart0);\r\n\r\n        }).then(function(keypart1) {\r\n\r\n          //copy the first 16 bytes to the key remaining 16 bytes\r\n          for (let i = 0; i < 16; i++) { key[i + 32] = keypart1[i]; }\r\n          //console.log('crypto-generateMasterSecret', key);\r\n          resolve(key);\r\n\r\n        }).catch(function(err) {\r\n          console.log('crypto-generateMasterSecret', err);\r\n          reject(err);\r\n        });\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  /**\r\n  * generates both users MAC and encryption keys. generate as output an array\r\n  * with 4 byteArray each with 32 bytes\r\n  * @param  {byteArray}        secret       secret to be used in the HMAC function\r\n  * @param  {String}           data         information to be used as seed\r\n  * @return {Array<byteArray>} key          array with the information to generate keys\r\n  */\r\n  generateKeys(hmacKey, data) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let key = [];\r\n      let seed = data;\r\n\r\n      // iterate 4 times to obtain a 1024 key size\r\n      _this.hashHMAC(hmacKey, seed).then(function(keypart0) {\r\n        key.push(keypart0);\r\n        return _this.hashHMAC(hmacKey, seed + keypart0);\r\n\r\n      }).then(function(keypart1) {\r\n        key.push(keypart1);\r\n        return _this.hashHMAC(hmacKey, seed + keypart1);\r\n\r\n      }).then(function(keypart2) {\r\n        key.push(keypart2);\r\n        return _this.hashHMAC(hmacKey, seed + keypart2);\r\n\r\n      }).then(function(keypart3) {\r\n        key.push(keypart3);\r\n\r\n        //console.log('crypto-generateKeys', key);\r\n        resolve(key);\r\n\r\n      }).catch(function(err) {\r\n        //console.log('crypto-generateKeys', err);\r\n        reject(err);\r\n      });\r\n\r\n      //console.log(hmacKey, data);\r\n    });\r\n  }\r\n\r\n  _importRSAsignKey(privKey) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      crypto.subtle.importKey(\r\n          'pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\r\n          privKey,\r\n          {   //these are the algorithm options\r\n            name: 'RSASSA-PKCS1-v1_5',\r\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\r\n          },\r\n          true, //whether the key is extractable (i.e. can be used in exportKey)\r\n          ['sign'] //'verify' for public key import, 'sign' for private key imports\r\n      )\r\n      .then(function(privateKey) {\r\n        //returns a publicKey (or privateKey if you are importing a private key)\r\n        //console.log('crypto-_importRSAsignKey', privateKey);\r\n        resolve(privateKey);\r\n\r\n      }).catch(function(err) {\r\n        console.error('crypto-_importRSAsignKey', err);\r\n        reject(err);\r\n      });\r\n    });\r\n  }\r\n\r\n  _importRSAverifyKey(pubKey) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      crypto.subtle.importKey(\r\n          'spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\r\n          pubKey,\r\n          {   //these are the algorithm options\r\n            name: 'RSASSA-PKCS1-v1_5',\r\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\r\n          },\r\n          true, //whether the key is extractable (i.e. can be used in exportKey)\r\n          ['verify'] //'verify' for public key import, 'sign' for private key imports\r\n      )\r\n      .then(function(publicKey) {\r\n        //returns a publicKey (or privateKey if you are importing a private key)\r\n        //console.log('crypto-_importRSAverifyKey', publicKey);\r\n        resolve(publicKey);\r\n\r\n      }).catch(function(err) {\r\n        console.error('crypto-_importRSAverifyKey', err);\r\n        reject(err);\r\n      });\r\n    });\r\n  }\r\n\r\n  _importRSAencryptKey(pubKey) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      crypto.subtle.importKey(\r\n          'spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\r\n          pubKey,\r\n          {   //these are the algorithm options\r\n            name: 'RSA-OAEP',\r\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\r\n          },\r\n          true, //whether the key is extractable (i.e. can be used in exportKey)\r\n          ['encrypt'] //'encrypt' or 'wrapKey' for public key import or\r\n                      //'decrypt' or 'unwrapKey' for private key imports\r\n      )\r\n      .then(function(publicKey) {\r\n        //returns a publicKey (or privateKey if you are importing a private key)\r\n        //console.log('crypto-_importRSAencryptKey', publicKey);\r\n        resolve(publicKey);\r\n\r\n      }).catch(function(err) {\r\n        console.error('crypto-_importRSAencryptKey', err);\r\n        reject(err);\r\n      });\r\n    });\r\n  }\r\n\r\n  _importRSAdecryptKey(privKey) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      crypto.subtle.importKey(\r\n          'pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\r\n          privKey,\r\n          {   //these are the algorithm options\r\n            name: 'RSA-OAEP',\r\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\r\n          },\r\n          true, //whether the key is extractable (i.e. can be used in exportKey)\r\n          ['decrypt'] //'encrypt' or 'wrapKey' for public key import or\r\n                      //'decrypt' or 'unwrapKey' for private key imports\r\n      )\r\n      .then(function(privateKey) {\r\n        //returns a publicKey (or privateKey if you are importing a private key)\r\n        //console.log('crypto-_importRSAdecryptKey', privateKey);\r\n        resolve(privateKey);\r\n\r\n      }).catch(function(err) {\r\n        console.error('crypto-_importRSAdecryptKey', err);\r\n        reject(err);\r\n      });\r\n    });\r\n  }\r\n\r\n  concatPMSwithRandoms(pms, toRandom, fromRandom) {\r\n    let _this = this;\r\n\r\n    let finalKey = new Uint8Array(pms.length + toRandom.length + fromRandom.length);\r\n\r\n    // add PremasterKey\r\n    for (let i = 0; i < pms.length; i++) {\r\n      finalKey[i] = pms[i];\r\n    }\r\n\r\n    //add to random\r\n    for (let i = 0; i < toRandom.length; i++) {\r\n      finalKey[i + pms.length] = pms[i];\r\n    }\r\n\r\n    //add from random\r\n    for (let i = 0; i < fromRandom.length; i++) {\r\n      finalKey[i + pms.length + toRandom.length] = pms[i];\r\n    }\r\n\r\n    return finalKey;\r\n  }\r\n\r\n  _generate256bitKey() {\r\n    let array = new  Uint8Array(32);\r\n    crypto.getRandomValues(array);\r\n\r\n    return array;\r\n  }\r\n\r\n  /**\r\n  * imports the secret to the HMAC function\r\n  * @param  {byteArray}   arrayBuffer     bytes to import as key\r\n  * @return {JSON}       key              key ready to be used in the HMAC cryptographic function\r\n  */\r\n  _importHMACkey(arrayBuffer) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this._digest(arrayBuffer).then((key) => {\r\n\r\n        crypto.subtle.importKey(\r\n        'raw', //can be 'jwk' or 'raw'\r\n        key,\r\n        {   //this is the algorithm options\r\n          name: 'HMAC',\r\n          hash: {name: 'SHA-256'}, //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\r\n          length: 256 //optional, if you want your key length to differ from the hash function's block length\r\n        },\r\n        true, //whether the key is extractable (i.e. can be used in exportKey)\r\n        ['sign', 'verify'] //can be any combination of 'sign' and 'verify'\r\n        ).then(function(key) {\r\n          //returns the symmetric key\r\n          //console.log('crypto-_importHMACkey', key);\r\n          resolve(key);\r\n        })\r\n        .catch(function(err) {\r\n          reject(err);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  _digest(value) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      crypto.subtle.digest(\r\n          {\r\n            name: 'SHA-256'\r\n          },\r\n          value //The data you want to hash as an ArrayBuffer\r\n      )\r\n      .then(function(hash) {\r\n        //returns the hash as an ArrayBuffer\r\n        //console.log('crypto-digest', new Uint8Array(hash));\r\n        resolve(new Uint8Array(hash));\r\n      })\r\n      .catch(function(err) {\r\n        console.error(err);\r\n        reject(err);\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  _importAESkey(arrayBuffer) {\r\n    return new Promise(function(resolve, reject) {\r\n      crypto.subtle.importKey(\r\n          'raw', //can be 'jwk' or 'raw'\r\n          arrayBuffer,\r\n          {   //this is the algorithm options\r\n            name: 'AES-CBC'\r\n          },\r\n          true, //whether the key is extractable (i.e. can be used in exportKey)\r\n          ['encrypt', 'decrypt'] //can be 'encrypt', 'decrypt', 'wrapKey', or 'unwrapKey'\r\n      )\r\n      .then(function(key) {\r\n        //returns the symmetric key\r\n        //console.log('crypto-importAESkey', key);\r\n        resolve(key);\r\n      })\r\n      .catch(function(err) {\r\n        console.error('crypto-importAESkey', err);\r\n        reject(err);\r\n      });\r\n    });\r\n  }\r\n\r\n  _utf8Encode(s) {\r\n    return new TextEncoder('utf-8').encode(s);\r\n  }\r\n\r\n  _utf8Decode(s) {\r\n    return new TextDecoder('utf-8').decode(s);\r\n  }\r\n}\r\n\r\nexport default Crypto;\r\n",
    "static": true,
    "longname": "src/identity/Crypto.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 160,
    "kind": "class",
    "name": "Crypto",
    "memberof": "src/identity/Crypto.js",
    "static": true,
    "longname": "src/identity/Crypto.js~Crypto",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/identity/Crypto.js",
    "importStyle": "Crypto",
    "description": "Class with the cryptographic functions for the authentication protocol",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 161,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#constructor",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "encode",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#encode",
    "access": null,
    "description": "encode a byteArray value in base 64 encode",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "byteArray value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "encoded value"
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "decode",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#decode",
    "access": null,
    "description": "decode a base64 value in a new Uint8Array",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value encoded in base 64"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "decodedValue"
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "encryptRSA",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#encryptRSA",
    "access": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pubKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "decryptRSA",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#decryptRSA",
    "access": null,
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "privKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "signRSA",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#signRSA",
    "access": null,
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "privKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "verifyRSA",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#verifyRSA",
    "access": null,
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pubKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "signature",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "encryptAES",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#encryptAES",
    "access": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "iv",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "decryptAES",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#decryptAES",
    "access": null,
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "iv",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "hashHMAC",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#hashHMAC",
    "access": null,
    "description": "creates a hash using the HMAC algorithm",
    "lineNumber": 212,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key to be used in the hmac"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "information to be hashed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "signature  resulting hash"
    }
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "verifyHMAC",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#verifyHMAC",
    "access": null,
    "description": "verifies an hash using the HMAC algorithm",
    "lineNumber": 247,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key to be used in the hmac"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "information to be hashed to compare"
      },
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "hash to compare with the received data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "isvalid     boolean saying if the data corresponds to the hash received"
    }
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "generateRSAKeyPair",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateRSAKeyPair",
    "access": null,
    "description": "generates a RSA public/private key pair with a modulus length of 2048 bits",
    "lineNumber": 280,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "keyPair    json containing the public and private keys"
    }
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "generateIV",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateIV",
    "access": null,
    "description": "Generates a 128 bit random value.",
    "lineNumber": 331,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "array    random value"
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "generateRandom",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateRandom",
    "access": null,
    "description": "Generates a 256 bit random value. 32 bits are extrated from the machine time,\nthe remaining are generated randomly",
    "lineNumber": 345,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "array    random value"
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "generatePMS",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generatePMS",
    "access": null,
    "description": "generates a premaster secret (PMS) of 48 bytes (384 bits) randomly",
    "lineNumber": 366,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "array    premaster secret key"
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "generateMasterSecret",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateMasterSecret",
    "access": null,
    "description": "generates a masterKey secret (PMS) of 48 bytes (384 bits) using the premaster secret and\ntwo randoms",
    "lineNumber": 379,
    "params": [
      {
        "name": "hmacKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "array    master secret key with 48 bytes"
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "generateKeys",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateKeys",
    "access": null,
    "description": "generates both users MAC and encryption keys. generate as output an array\nwith 4 byteArray each with 32 bytes",
    "lineNumber": 417,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "secret",
        "description": "secret to be used in the HMAC function"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "information to be used as seed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<byteArray>"
      ],
      "spread": false,
      "description": "key          array with the information to generate keys"
    }
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "_importRSAsignKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importRSAsignKey",
    "access": null,
    "description": null,
    "lineNumber": 453,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "privKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "_importRSAverifyKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importRSAverifyKey",
    "access": null,
    "description": null,
    "lineNumber": 479,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pubKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "_importRSAencryptKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importRSAencryptKey",
    "access": null,
    "description": null,
    "lineNumber": 505,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pubKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "_importRSAdecryptKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importRSAdecryptKey",
    "access": null,
    "description": null,
    "lineNumber": 532,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "privKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "concatPMSwithRandoms",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#concatPMSwithRandoms",
    "access": null,
    "description": null,
    "lineNumber": 559,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pms",
        "types": [
          "*"
        ]
      },
      {
        "name": "toRandom",
        "types": [
          "*"
        ]
      },
      {
        "name": "fromRandom",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "_generate256bitKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_generate256bitKey",
    "access": null,
    "description": null,
    "lineNumber": 582,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "_importHMACkey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importHMACkey",
    "access": null,
    "description": "imports the secret to the HMAC function",
    "lineNumber": 594,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "arrayBuffer",
        "description": "bytes to import as key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "key              key ready to be used in the HMAC cryptographic function"
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "_digest",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_digest",
    "access": null,
    "description": null,
    "lineNumber": 623,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "_importAESkey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importAESkey",
    "access": null,
    "description": null,
    "lineNumber": 646,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "arrayBuffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "_utf8Encode",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_utf8Encode",
    "access": null,
    "description": null,
    "lineNumber": 669,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "s",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "_utf8Decode",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_utf8Decode",
    "access": null,
    "description": null,
    "lineNumber": 673,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "s",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "file",
    "name": "src/identity/GuiFake.js",
    "content": "/**\r\n* fake class for the gui to select the identity,\r\n* TODO replace with the proper identity GUI\r\n*\r\n*/\r\nclass GuiFake {\r\n\r\n  constructor(url, messageBus) {\r\n    let _this = this;\r\n\r\n    _this._url = url;\r\n    _this._waitTime = 10000;\r\n    _this._messageBus = messageBus;\r\n\r\n    _this._messageBus.addListener(_this._url, msg => {\r\n\r\n      let identities = msg.body.value.identities;\r\n      let idps = msg.body.value.idps;\r\n\r\n      let value;\r\n\r\n      if (identities[0] !== undefined) {\r\n        value = {type: 'identity', value: identities[0], code: 200};\r\n      } else {\r\n        value = {type: 'idp', value: idps[0].domain, code: 200};\r\n      }\r\n\r\n      let replyMsg = {id: msg.id, type: 'response', to: msg.from, from: msg.to, body: value};\r\n\r\n      // to test on the identity side the listener without the timeout\r\n      // can represent the time the user takes to choose and identity\r\n      if (msg.body.value === 'wait') {\r\n\r\n        setTimeout(() => {\r\n          _this._messageBus.postMessage(replyMsg);\r\n        }, _this._waitTime);\r\n      } else {\r\n        _this._messageBus.postMessage(replyMsg);\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default GuiFake;\r\n",
    "static": true,
    "longname": "src/identity/GuiFake.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 190,
    "kind": "class",
    "name": "GuiFake",
    "memberof": "src/identity/GuiFake.js",
    "static": true,
    "longname": "src/identity/GuiFake.js~GuiFake",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/identity/GuiFake.js",
    "importStyle": "GuiFake",
    "description": "fake class for the gui to select the identity,\nTODO replace with the proper identity GUI",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 191,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/GuiFake.js~GuiFake",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/GuiFake.js~GuiFake#constructor",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "messageBus",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 192,
    "kind": "file",
    "name": "src/identity/Identity.js",
    "content": "/**\r\n* The Identity Data Model is used to model the reTHINK User entity. The Identity data model is handled by Identity Management functionality.\r\n*\r\n*/\r\nclass Identity {\r\n\r\n  constructor(guid, type) {\r\n    let _this = this;\r\n\r\n    _this.guid = guid;\r\n    _this.type = type;\r\n    _this.identifiersList = {};\r\n\r\n  }\r\n\r\n  addIdentity(identifier) {\r\n    let _this = this;\r\n    let identityInformation = {\r\n      idAssertion: '',\r\n      serviceAddress: '',\r\n      authenticationData: '',\r\n      authorisationData: '',\r\n      userProfile: ''\r\n    };\r\n    _this.identifiersList[identifier] = identityInformation;\r\n  }\r\n\r\n  addIdAssertion(identifier, assertion, idp, scope) {\r\n    let _this = this;\r\n\r\n    let newIdAssertion = new IdAssertion(assertion, idp, scope);\r\n\r\n    _this.idAssertionList.push(newIdAssertion);\r\n  }\r\n}\r\n\r\nclass IdAssertion {\r\n\r\n  constructor(assertion, idp, scope) {\r\n    let _this = this;\r\n\r\n    _this.assertion = assertion;\r\n    _this.idp = idp;\r\n    _this.scope = scope;\r\n  }\r\n\r\n}\r\n\r\nclass IdValidation {\r\n\r\n  constructor(identity, contents) {\r\n    let _this = this;\r\n    _this.identity = identity;\r\n    _this.contents = contents;\r\n  }\r\n\r\n  validates(identity, contents) {\r\n    //TODO implement the logic\r\n\r\n  }\r\n}\r\n\r\nexport default Identity;\r\n",
    "static": true,
    "longname": "src/identity/Identity.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 193,
    "kind": "class",
    "name": "IdAssertion",
    "memberof": "src/identity/Identity.js",
    "static": true,
    "longname": "src/identity/Identity.js~IdAssertion",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/identity/Identity.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 194,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/Identity.js~IdAssertion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~IdAssertion#constructor",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "assertion",
        "types": [
          "*"
        ]
      },
      {
        "name": "idp",
        "types": [
          "*"
        ]
      },
      {
        "name": "scope",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 195,
    "kind": "class",
    "name": "IdValidation",
    "memberof": "src/identity/Identity.js",
    "static": true,
    "longname": "src/identity/Identity.js~IdValidation",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/identity/Identity.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 196,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/Identity.js~IdValidation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~IdValidation#constructor",
    "access": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identity",
        "types": [
          "*"
        ]
      },
      {
        "name": "contents",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "validates",
    "memberof": "src/identity/Identity.js~IdValidation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~IdValidation#validates",
    "access": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identity",
        "types": [
          "*"
        ]
      },
      {
        "name": "contents",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 198,
    "kind": "class",
    "name": "Identity",
    "memberof": "src/identity/Identity.js",
    "static": true,
    "longname": "src/identity/Identity.js~Identity",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/identity/Identity.js",
    "importStyle": "Identity",
    "description": "The Identity Data Model is used to model the reTHINK User entity. The Identity data model is handled by Identity Management functionality.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 199,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/Identity.js~Identity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~Identity#constructor",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "guid",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 200,
    "kind": "method",
    "name": "addIdentity",
    "memberof": "src/identity/Identity.js~Identity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~Identity#addIdentity",
    "access": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "addIdAssertion",
    "memberof": "src/identity/Identity.js~Identity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~Identity#addIdAssertion",
    "access": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "assertion",
        "types": [
          "*"
        ]
      },
      {
        "name": "idp",
        "types": [
          "*"
        ]
      },
      {
        "name": "scope",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 202,
    "kind": "file",
    "name": "src/identity/IdentityModule.js",
    "content": "\nimport {divideURL, getUserURLFromEmail, getUserEmailFromURL, isDataObjectURL, convertToUserURL, getUserIdentityDomain, isLegacy} from '../utils/utils.js';\nimport Identity from './Identity';\nimport Crypto from './Crypto';\nimport GuiFake from './GuiFake';\n\n/**\n*\n* The Identity Module (Id Module) is the component responsible for handling the\n* user identity and the association of this identity with the Hyperty instances,\n* in order to make Hyperty instances identifiable. The identity in the reTHINK project\n* is not fixed to a unique Identity Service Provider, but obtained through several\n* different Identity sources. With this approach, the Id Module provides to the user the\n* option to choose the preferred method for authentication.\n* This module will thus able to support multiple Identity acquisition methods,\n* such as OpenID connect 1.0, Kerberos System, or authentication through smart cards.\n* For example, a user with a Google account can use the Google as an Identity Provider to provide Identity Tokens,\n*  which can be used by the Identity Module to associate it with a Hyperty instance.\n*\n* The Identity Module uses a node package, the HelloJS, which is a client-side JavaScript API for authentication\n* that facilitates the requests for the OpenID connect protocol. This method allows for some abstraction\n* when making requests for different Identity Providers, such as OpenID connect used by Google, Facebook, Microsoft, for example.\n*\n* When a request for a user identity is made using the method loginWithRP(identifier, scope),\n* this method will analyse the Identity Provider chosen to obtain an identity and will use the HelloJS node package\n* with the selected Identity Provider and identity scope. After the HelloJS request for an Access Token\n* to the Identity Providers, the user will be prompted to authenticate towards the Identity Provider.\n* Upon receiving the Access Token, this token is validated with a RESTful web service request to an endpoint\n* on the Identity Provider Authorization Server, and after the validation is done,\n* an ID token is obtained with the information according to the scope required.\n* This ID token is then preserved in this module that can obtained through the getIdentities()\n* and is passed as return value of the loginWithRP function. The methods generateAssertion and validateAssertion have not yet been developed.\n*\n*/\nclass IdentityModule {\n\n  /**\n  * This is the constructor to initialise the Identity Module it does not require any input.\n  */\n  constructor(runtimeURL, runtimeCapabilities, storageManager) {\n    let _this = this;\n\n    if (!runtimeURL) throw new Error('runtimeURL is missing.');\n    if (!storageManager) throw new Error('storageManager is missing');\n\n    _this._runtimeURL = runtimeURL;\n    _this.storageManager = storageManager;\n    _this._idmURL = _this._runtimeURL + '/idm';\n    _this._guiURL = _this._runtimeURL + '/identity-gui';\n    _this.runtimeCapabilities = runtimeCapabilities;\n\n    _this._domain = divideURL(_this._runtimeURL).domain;\n\n    //to store items with this format: {identity: identityURL, token: tokenID}\n    _this.identities = [];\n    _this.emailsList = [];\n    let newIdentity = new Identity('guid','HUMAN');\n    _this.identity = newIdentity;\n    _this.crypto = new Crypto();\n\n    //stores the association of the dataObject and the Hyperty registered within\n    _this.dataObjectsIdentity = {};\n\n    // hashTable to store all the crypto information between two hyperties\n    _this.chatKeys = {};\n\n    // hashTable to store the symmetric keys to be used in the chat group\n    _this.dataObjectSessionKeys = {};\n\n    //failsafe to enable/disable all the criptographic functions\n    _this.isToUseEncryption = true;\n\n    // variable to know if the GUI is deployed to choose the identity. if the real GUI is not deployed, a fake gui is deployed instead.\n    _this.guiDeployed = false;\n\n    // verification of nodeJS, and in case it is nodeJS then disable encryption\n    // TODO improve later, this exists because the crypto lib uses browser cryptographic methods\n    //_this.isToUseEncryption = (window) ? true : false;\n\n    _this._loadIdentities();\n\n  }\n\n  /**\n  * return the messageBus in this Registry\n  * @param {MessageBus}           messageBus\n  */\n  get messageBus() {\n    let _this = this;\n    return _this._messageBus;\n  }\n\n  /**\n  * Set the messageBus in this Registry\n  * @param {MessageBus}           messageBus\n  */\n  set messageBus(messageBus) {\n    let _this = this;\n    _this._messageBus = messageBus;\n\n  }\n\n  /**\n  * return the registry in this idModule\n  * @param {registry}           registry\n  */\n  get registry() {\n    let _this = this;\n    return _this._registry;\n  }\n\n  /**\n  * Set the registry in this idModule\n  * @param {registry}     reg\n  */\n  set registry(registry) {\n    let _this = this;\n    _this._registry = registry;\n  }\n\n  /**\n  * Function to return all the identities registered within a session by a user.\n  * These identities are returned in an array containing a JSON package for each user identity.\n  * @return {Array<Identities>}         Identities\n  */\n  getIdentities() {\n    let _this = this;\n    return _this.identities;\n  }\n\n  /**\n  * gets all the information from a given userURL\n  * @param  {String}  userURL     user url\n  * @return {JSON}    identity    identity bundle from the userURL\n  */\n  getIdentity(userURL) {\n    let _this = this;\n\n    for (let index in _this.identities) {\n\n      let identity = _this.identities[index];\n      if (identity.identity === userURL) {\n        return identity;\n      }\n    }\n\n    throw 'identity not found';\n  }\n\n  _loadIdentities() {\n    let _this = this;\n    return new Promise((resolve) => {\n\n      _this.storageManager.get('idModule:identities').then((identities) => {\n\n        if (identities) {\n          _this.identities = identities;\n        }\n        resolve();\n      });\n    });\n  }\n\n  deployGUI() {\n    let _this = this;\n    _this.guiDeployed = true;\n  }\n\n\n  /**\n  * get a Token to be added to a message\n  * @param  {String}  fromURL     origin of the message\n  * @param  {String}  toURL     target of the message\n  * @return {JSON}    token    token to be added to the message\n  */\n\n  getToken(fromURL, toUrl) {\n    let _this = this;\n    return new Promise(function(resolve, reject) {\n      console.log('[Identity.IdentityModule.getToken] from->', fromURL, '  to->', toUrl);\n      if (toUrl && toUrl.split('@').length > 1) {\n//        console.log('toUrl', toUrl);\n        _this.registry.isLegacy(toUrl).then(function(result) {\n          console.log('[Identity.IdentityModule.getToken] isLEGACY: ', result);\n          if (result) {\n\n            let token = _this.getAccessToken(toUrl);\n            if (token)\n              return resolve(token);\n\n            console.log('[Identity.IdentityModule.getToken] NO Identity.. Login now');\n            let domain = getUserIdentityDomain(toUrl);\n            console.log('[Identity.IdentityModule.getToken] domain->', domain);\n            _this.callGenerateMethods(domain).then((value) => {\n              console.log('[Identity.IdentityModule.getToken] CallGeneratemethods', value);\n              let token = _this.getAccessToken(toUrl);\n              if (token)\n                return resolve(token);\n              else {\n                return reject('No Access token found');\n              }\n            }, (err) => {\n              console.error('[Identity.IdentityModule.getToken] error CallGeneratemethods');\n              return reject(err);\n            });\n          } else {\n\n            _this.getIdToken(fromURL).then(function(identity) {\n              console.log('[Identity.IdentityModule.getToken] getIdToken', identity);\n              return resolve(identity);\n            }).catch(function(error) {\n              console.error('[Identity.IdentityModule.getToken] error on getToken', error);\n              return reject(error);\n            });\n          }\n        });\n      } else {\n        _this.getIdToken(fromURL).then(function(identity) {\n          console.log('[Identity.IdentityModule.getToken] from getIdToken', identity);\n          return resolve(identity);\n        }).catch(function(error) {\n          return reject(error);\n        });\n      }\n    });\n  }\n\n  /**\n  * get an Id Token for a HypertyURL\n  * @param  {String}  hypertyURL     the Hyperty address\n  * @return {JSON}    token    Id token to be added to the message\n  */\n\n\n  getIdToken(hypertyURL) {\n    let _this = this;\n    return new Promise(function(resolve, reject) {\n      let splitURL = hypertyURL.split('://');\n      if (splitURL[0] !== 'hyperty') {\n\n        _this._getHypertyFromDataObject(hypertyURL).then((returnedHypertyURL) => {\n          let userURL = _this.registry.getHypertyOwner(returnedHypertyURL);\n\n          if (userURL) {\n\n            for (let index in _this.identities) {\n              let identity = _this.identities[index];\n              if (identity.identity === userURL) {\n                return resolve(identity.messageInfo);\n              }\n            }\n          } else {\n            return reject('no identity was found ');\n          }\n        }).catch((reason) => {\n          console.error('no identity was found: ', reason);\n          reject(reason);\n        });\n      } else {\n        let userURL = _this.registry.getHypertyOwner(hypertyURL);\n        if (userURL) {\n\n          for (let index in _this.identities) {\n            let identity = _this.identities[index];\n            if (identity.identity === userURL) {\n              // TODO check this getIdToken when we run on nodejs environment;\n              if (identity.hasOwnProperty('messageInfo')) return resolve(identity.messageInfo);\n              else return resolve(identity);\n            }\n          }\n        } else {\n          return reject('no identity was found.');\n        }\n      }\n    });\n  }\n\n  /**\n  * get an Access Token for a legacyURL\n  * @param  {String}  legacyURL     the legacy address\n  * @return {JSON}    token    Access token to be added to the message\n  */\n\n  getAccessToken(url) {\n    let _this = this;\n\n  /*  let urlSplit = url.split('.');\n    let length = urlSplit.length;*/\n\n    let domainToCheck = divideURL(url).domain;\n\n    for (let index in _this.identities) {\n      let identity = _this.identities[index];\n      if (identity.hasOwnProperty('interworking') && identity.interworking.domain === domainToCheck) {\n        return identity.interworking.access_token;\n      }\n    }\n\n    return null;\n  }\n\n  getIdentitiesToChoose() {\n    let _this = this;\n    let identities = _this.emailsList;\n    let idps = [{domain: 'google.com', type: 'idToken'},{domain: 'microsoft.com', type: 'idToken'}, {domain: 'orange.fr', type: 'idToken'}, {domain: 'slack.com', type: 'Legacy'}];\n\n    return {identities: identities, idps: idps};\n  }\n\n  /**\n  * Function to return all the users URLs registered within a session\n  * These users URLs are returned in an array of strings.\n  * @param  {Boolean}  emailFormat (Optional)   boolean to indicate to return in email format\n  * @return {Array<String>}         users\n  */\n  getUsersIDs(emailFormat) {\n    let _this = this;\n    let users = [];\n\n    //if request comes with the emailFormat option, then convert url to email format\n    let converter = (emailFormat) ? getUserEmailFromURL : (value) => {return value;};\n\n    for (let index in _this.identities) {\n      let identity = _this.identities[index];\n      users.push(converter(identity.identity));\n    }\n    return users;\n  }\n\n  /**\n  * Function to return the selected Identity within a session\n  * @return {Identity}        identity         identity\n  */\n  getCurrentIdentity() {\n    let _this = this;\n    return _this.currentIdentity;\n  }\n\n  /**\n  * Function to set the current Identity with a given Identity\n  * @param {Identity}        identity         identity\n  */\n  setCurrentIdentity(identity) {\n    let _this = this;\n    _this.currentIdentity = identity;\n  }\n\n  /**\n  * Function to remove an identity from the Identities array\n  * @param {String}    userID      userID\n  */\n  deleteIdentity(userID) {\n    let _this = this;\n\n    let userURL = convertToUserURL(userID);\n\n    for (let identity in _this.identities) {\n      if (_this.identities[identity].identity === userURL) {\n        _this.identities.splice(identity, 1);\n      }\n    }\n  }\n\n  /**\n  * Function to unregister an identity from the emailsList array and not show in to the GUI\n  * @param {String}    email      email\n  */\n  unregisterIdentity(email) {\n    let _this = this;\n\n    for (let e in _this.emailsList) {\n      if (_this.emailsList[e] === email) {\n        _this.emailsList.splice(e, 1);\n      }\n    }\n  }\n\n  /**\n  * Function that resolve and create the domainURL in case it is provided one. If not, resolve the default domainURL\n  * @param {String}     idpDomain     idpDomain (Optional)\n  */\n  _resolveDomain(idpDomain) {\n    if (!idpDomain) {\n      return 'domain-idp://google.com';\n    } else {\n      return 'domain-idp://' + idpDomain;\n    }\n  }\n\n  /**\n  * Function that sends a request to the GUI using messages. Sends all identities registered and\n  * the Idps supported, and return the identity/idp received by the GUI\n  * @param {Array<identity>}  identities      list of identitiies\n  * @param {Array<String>}    idps            list of idps to authenticate\n  * @return {Promise}         returns a chosen identity or idp\n  */\n  requestIdentityToGUI(identities, idps) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n\n      //condition to check if the real GUI is deployed. If not, deploys a fake gui\n      if (_this.guiDeployed === false) {\n\n        let guiFake = new GuiFake(_this._guiURL, _this._messageBus);\n        _this.guiFake = guiFake;\n        _this.guiDeployed = true;\n      }\n\n      let message = {type:'create', to: _this._guiURL, from: _this._idmURL,\n                    body: {value: {identities: identities, idps: idps}}};\n\n      let id = _this._messageBus.postMessage(message);\n\n      //add listener without timout\n      _this._messageBus.addResponseListener(_this._idmURL, id, msg => {\n        _this._messageBus.removeResponseListener(_this._idmURL, id);\n\n        // todo: to return the user URL and not the email or identifier\n\n        if (msg.body.code === 200) {\n          let selectedIdentity = msg.body;\n\n          console.log('selectedIdentity: ', selectedIdentity.value);\n          resolve(selectedIdentity);\n        } else {\n          reject('error on requesting an identity to the GUI');\n        }\n      });\n    });\n  }\n\n  openPopup(urlreceived) {\n\n    return new Promise((resolve, reject) => {\n\n      let win = window.open(urlreceived, 'openIDrequest', 'width=800, height=600');\n      if (window.cordova) {\n        win.addEventListener('loadstart', function(e) {\n          let url = e.url;\n          let code = /\\&code=(.+)$/.exec(url);\n          let error = /\\&error=(.+)$/.exec(url);\n\n          if (code || error) {\n            win.close();\n            resolve(url);\n          }\n        });\n      } else {\n        let pollTimer = setInterval(function() {\n          try {\n            if (win.closed) {\n              reject('Some error occured when trying to get identity.');\n              clearInterval(pollTimer);\n            }\n\n            if (win.document.URL.indexOf('id_token') !== -1 || win.document.URL.indexOf(location.origin) !== -1) {\n              window.clearInterval(pollTimer);\n              let url =   win.document.URL;\n\n              win.close();\n              resolve(url);\n            }\n          } catch (e) {\n            //console.log(e);\n          }\n        }, 500);\n      }\n    });\n  }\n\n  /**\n  * Function that fetch an identityAssertion from a user.\n  *\n  * @return {IdAssertion}              IdAssertion\n  */\n  getIdentityAssertion(identifier, origin, usernameHint, idpDomain) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n\n      //CHECK whether is browser environment or nodejs\n      //if it is browser, then create a fake identity\n\n      _this.runtimeCapabilities.isAvailable('browser').then((result) => {\n        console.log('runtime browser identity acquisition ', result);\n\n        if (!result) return;\n\n        let identitiesInfo = _this.getIdentitiesToChoose();\n\n        _this.requestIdentityToGUI(identitiesInfo.identities, identitiesInfo.idps).then(value => {\n\n          if (value.type === 'identity') {\n\n          //  let chosenID = getUserURLFromEmail(value.value);\n          // hack while the user url is not returned from requestIdentityToGUI;\n\n          let chosenID = 'user://' + _this.currentIdentity.idp + '/' + value.value;\n\n            // returns the identity info from the chosen id\n            for (let i in _this.identities) {\n              if (_this.identities[i].identity === chosenID) {\n                return resolve(_this.identities[i].messageInfo);\n              }\n            }\n            reject('no identity was found .');\n          } else if (value.type === 'idp') {\n\n            _this.callGenerateMethods(value.value, origin).then((value) => {\n              resolve(value);\n            }, (err) => {\n              reject(err);\n            });\n\n          } else {\n            reject('error on GUI received message.');\n          }\n        });\n      }).catch(error => {\n        console.log('Error on identity acquisition ', error);\n        reject(error);\n      });\n\n      _this.runtimeCapabilities.isAvailable('node').then((result) => {\n        console.log('node identity acquisition ', result);\n\n        if (!result) return;\n\n        if (_this.currentIdentity !== undefined) {\n          //TODO verify whether the token is still valid or not.\n          // should be needed to make further requests, to obtain a valid token\n          return resolve(_this.currentIdentity);\n        } else {\n          console.log('getIdentityAssertion for nodejs');\n          let randomNumber = Math.floor((Math.random() * 10000) + 1);\n\n          let userProfile = {\n            avatar: 'https://lh3.googleusercontent.com/-WaCrjVMMV-Q/AAAAAAAAAAI/AAAAAAAAAAs/8OlVqCpSB9c/photo.jpg',\n            cn: 'test nodejs',\n            username: 'nodejs-' + randomNumber + '@nodejs.com',\n            userURL: 'user://nodejs.com/nodejs-' + randomNumber\n          };\n\n          let identityBundle = {\n            assertion: 'assertion',\n            idp:'nodejs',\n            identity: 'user://nodejs.com/nodejs-' + randomNumber,\n            messageInfo: {\n              assertion: 'assertion',\n              idp:'nodejs',\n              userProfile: userProfile\n            },\n            userProfile: userProfile\n          };\n          _this.currentIdentity = identityBundle;\n          _this.identities.push(identityBundle);\n          _this.storageManager.set('idModule:identities', 0, _this.identities).then(() => {\n\n            return resolve(identityBundle);\n          });\n        }\n\n      }).catch(error => {\n        console.log('Error on identity acquisition ', error);\n        reject(error);\n      });\n    });\n  }\n\n  callGenerateMethods(idp, origin) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      let publicKey;\n      let userkeyPair;\n\n      //generates the RSA key pair\n      _this.crypto.generateRSAKeyPair().then(function(keyPair) {\n\n        publicKey = btoa(keyPair.public);\n        userkeyPair = keyPair;\n        return _this.generateAssertion(publicKey, origin, '', userkeyPair, idp);\n\n      }).then(function(url) {\n        return _this.generateAssertion(publicKey, origin, url, userkeyPair, idp);\n\n      }).then(function(value) {\n        if (value) {\n          resolve(value);\n        } else {\n          reject('Error on obtaining Identity');\n        }\n      }).catch(function(err) {\n        console.log(err);\n        reject(err);\n      });\n    });\n  }\n\n  sendGenerateMessage(contents, origin, usernameHint, idpDomain) {\n    let _this = this;\n    let domain = _this._resolveDomain(idpDomain);\n    let message;\n\n    return new Promise((resolve, reject) => {\n      message = {type:'execute', to: domain, from: _this._idmURL, body: {resource: 'identity', method: 'generateAssertion', params: {contents: contents, origin: origin, usernameHint: usernameHint}}};\n      _this._messageBus.postMessage(message, (res) => {\n        let result = res.body.value;\n\n        resolve(result);\n\n      });\n    });\n  }\n\n  storeIdentity(result, keyPair) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      let splitedAssertion = result.assertion.split('.');\n      let assertionParsed;\n\n      //verify if the token contains the 3 components, or just the assertion\n      if (splitedAssertion[1]) {\n        assertionParsed = JSON.parse(atob(splitedAssertion[1]));\n      } else {\n\n        assertionParsed = JSON.parse(atob(result.assertion));\n      }\n      let idToken;\n\n      //TODO remove the verification and remove the tokenIDJSON from the google idpProxy;\n      if (assertionParsed.tokenIDJSON) {\n        idToken = assertionParsed.tokenIDJSON;\n      } else {\n        idToken = assertionParsed;\n      }\n\n      idToken.idp = result.idp;\n\n      let email = idToken.email || idToken.sub;\n\n      // let identifier = getUserURLFromEmail(email);\n\n      let identifier = 'user://' + idToken.idp.domain + '/' + email;\n\n      result.identity = identifier;\n\n      _this.identity.addIdentity(result);\n\n      // check if exists any infoToken in the result received\n      let infoToken = (result.infoToken) ? result.infoToken : {};\n\n      let commonName = idToken.name || email.substring(0, email.indexOf('@'));\n      let userProfileBundle = {username: email, cn: commonName, avatar: infoToken.picture, locale: infoToken.locale, userURL: identifier};\n\n      //creation of a new JSON with the identity to send via messages\n      let newIdentity = {userProfile: userProfileBundle, idp: result.idp.domain, assertion: result.assertion};\n      result.messageInfo = newIdentity;\n      result.keyPair = keyPair;\n\n      _this.currentIdentity = newIdentity;\n\n      //verify if the id already exists. If already exists then do not add to the identities list;\n      let idAlreadyExists = false;\n      let oldId;\n      for (let identity in _this.identities) {\n        if (_this.identities[identity].identity === result.identity) {\n          idAlreadyExists = true;\n          oldId = _this.identities[identity].messageInfo;\n        }\n      }\n\n      if (idAlreadyExists) {\n        resolve(oldId);\n        let exists = false;\n\n        //check if the identity exists in emailList, if not add it\n        //This is useful if an identity was previously registered but was later unregistered\n        for (let i in _this.emailsList) {\n          if (_this.emailsList[i] === email) {\n            exists = true;\n            break;\n          }\n        }\n        if (!exists) {\n          _this.emailsList.push(email);\n        }\n\n      } else {\n        _this.emailsList.push(email);\n        _this.identities.push(result);\n        _this.storageManager.set('idModule:identities', 0, _this.identities).then(() => {\n\n          resolve(newIdentity);\n        });\n      }\n\n    });\n  }\n\n  /**\n  * Requests the IdpProxy from a given Domain for an identityAssertion\n  *\n  * @param  {DOMString} contents     contents\n  * @param  {DOMString} origin       origin\n  * @param  {DOMString} usernameHint usernameHint\n  * @param  {JSON}      keyPair       user keyPair\n  * @return {IdAssertion}              IdAssertion\n  */\n  generateAssertion(contents, origin, usernameHint, keyPair, idpDomain) {\n    let _this = this;\n\n    console.log('generateAssertion');\n\n    return new Promise(function(resolve,reject) {\n\n      _this.sendGenerateMessage(contents, origin, usernameHint, idpDomain).then((result) => {\n\n        if (result.loginUrl) {\n\n          _this.openPopup(result.loginUrl).then((value) => {\n            resolve(value);\n          }, (err) => {\n            reject(err);\n          });\n        } else if (result) {\n\n          _this.storeIdentity(result, keyPair).then((value) => {\n            resolve(value);\n          }, (err) => {\n            reject(err);\n          });\n\n        } else {\n          reject('error on obtaining identity information');\n        }\n\n      });\n    });\n  }\n\n  /**\n  * OTHER USER'S IDENTITY\n  */\n\n  /**\n  * Requests the IdpProxy from a given Domain to validate an IdentityAssertion\n  * Returns a promise with the result from the validation.\n  * @param  {DOMString} assertion\n  * @param  {DOMString} origin       origin\n  * @return {Promise}         Promise         promise with the result from the validation\n  */\n  validateAssertion(assertion, origin, idpDomain) {\n    let _this = this;\n\n    let domain = _this._resolveDomain(idpDomain);\n\n    let message = {type:'execute', to: domain, from: _this._idmURL, body: {resource: 'identity', method: 'validateAssertion',\n            params: {assertion: assertion, origin: origin}}};\n\n    return new Promise(function(resolve, reject) {\n      _this._messageBus.postMessage(message, (result) => {\n        if (result.body.code === 200) {\n          resolve(result.body.value);\n        } else {\n          reject('error', result.body.code);\n        }\n      });\n    });\n  }\n\n  encryptMessage(message) {\n    let _this = this;\n\n    console.log('encrypt message ');\n\n    return new Promise(function(resolve, reject) {\n      let isHandShakeType = message.type === 'handshake';\n\n      //if is not to apply encryption, then returns resolve\n      if (!_this.isToUseEncryption && !isHandShakeType) {\n        console.log('encryption disabled');\n        return resolve(message);\n      }\n\n      //TODO remove this logic and move it to a util function\n      let splitedToURL = message.to.split('/');\n      let dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n      if (splitedToURL.length > 6) {\n        dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n      }\n\n      let isToDataObject = isDataObjectURL(dataObjectURL);\n      let isToLegacyIdentity = isLegacy(message.to);\n      let isFromHyperty = divideURL(message.from).type === 'hyperty';\n      let isToHyperty = divideURL(message.to).type === 'hyperty';\n\n      if (message.type === 'update') {\n        resolve(message);\n      }\n\n      if (isToLegacyIdentity) {\n        resolve(message);\n      } else if (isFromHyperty && isToHyperty) {\n        let userURL = _this._registry.getHypertyOwner(message.from);\n        if (userURL) {\n\n          // check if exists any keys between two users\n          let chatKeys = _this.chatKeys[message.from + '<->' + message.to];\n          if (!chatKeys) {\n            chatKeys = _this._newChatCrypto(message, userURL);\n            console.log('createChatKey encrypt', message.from + message.to);\n            _this.chatKeys[message.from + '<->' + message.to] = chatKeys;\n            message.body.handshakePhase = 'startHandShake';\n          }\n\n          if (chatKeys.authenticated && !isHandShakeType) {\n\n            let iv = _this.crypto.generateIV();\n            _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, message.body.value, iv).then(encryptedValue => {\n\n              let filteredMessage = _this._filterMessageToHash(message, message.body.value + iv, chatKeys.hypertyFrom.messageInfo);\n\n              _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage).then(hash => {\n                //console.log('result of hash ', hash);\n                let value = {iv: _this.crypto.encode(iv), value: _this.crypto.encode(encryptedValue), hash: _this.crypto.encode(hash)};\n                message.body.value = JSON.stringify(value);\n\n                resolve(message);\n              });\n            });\n\n            // if is a handshake message, just resolve it\n          } else if (isHandShakeType) {\n            resolve(message);\n\n            // else, starts a new handshake protocol\n          } else {\n            _this._doHandShakePhase(message, chatKeys).then(function(value) {\n              _this.chatKeys[message.from + '<->' + message.to] = value.chatKeys;\n\n              _this._messageBus.postMessage(value.message);\n              reject('encrypt handshake protocol phase ');\n            });\n          }\n        }\n\n      //if from hyperty to a dataObjectURL\n      } else if (isFromHyperty && isToDataObject) {\n        console.log('dataObject value to encrypt: ', message.body.value);\n\n        // TIAGO - persistence issue #147\n        _this.storageManager.get('dataObjectSessionKeys').then((sessionKeys) => {\n          let dataObjectKey = sessionKeys[dataObjectURL];\n\n          //if no key exists, create a new one if is the reporter of dataObject\n          if (!dataObjectKey) {\n            let isHypertyReporter = _this.registry.getReporterURLSynchonous(dataObjectURL);\n\n            // if the hyperty is the reporter of the dataObject then generates a session key\n            if (isHypertyReporter && isHypertyReporter === message.from) {\n\n              let sessionKey = _this.crypto.generateRandom();\n              _this.dataObjectSessionKeys[dataObjectURL] = {sessionKey: sessionKey, isToEncrypt: true};\n\n              // TIAGO - persistence issue #147\n              _this.storageManager.set('dataObjectSessionKeys', 0, _this.dataObjectSessionKeys);\n\n              dataObjectKey = _this.dataObjectSessionKeys[dataObjectURL];\n            }\n          }\n\n          //check if there is already a session key for the chat room\n          if (dataObjectKey) {\n\n            // and if is to apply encryption, encrypt the messages\n            if (dataObjectKey.isToEncrypt) {\n              let iv = _this.crypto.generateIV();\n\n              _this.crypto.encryptAES(dataObjectKey.sessionKey, _this.crypto.encode(JSON.stringify(message.body.value)), iv).then(encryptedValue => {\n\n                let filteredMessage = _this._filterMessageToHash(message, message.body.value + iv, dataObjectKey.sessionKey);\n\n                _this.crypto.hashHMAC(dataObjectKey.sessionKey, filteredMessage).then(hash => {\n                  //console.log('hash ', hash);\n\n                  let newValue = {value: _this.crypto.encode(encryptedValue), iv: _this.crypto.encode(iv), hash: _this.crypto.encode(hash)};\n\n                  message.body.value = JSON.stringify(newValue);\n                  resolve(message);\n                });\n              });\n\n            // if not, just send the message\n            } else {\n              resolve(message);\n            }\n\n            // start the generation of a new session Key\n          } else {\n            reject('failed to decrypt message');\n          }\n\n        });\n      }\n    });\n  }\n\n  decryptMessage(message) {\n    let _this = this;\n\n    console.log('decrypt message ');\n\n    return new Promise(function(resolve, reject) {\n      let isHandShakeType = message.type === 'handshake';\n\n      //if is not to apply encryption, then returns resolve\n      if (!_this.isToUseEncryption && !isHandShakeType) {\n        console.log('decryption disabled');\n        return resolve(message);\n      }\n\n      //TODO remove this logic and move it to a util function\n\n      let splitedToURL = message.to.split('/');\n      let dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n      if (splitedToURL.length > 6) {\n        dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n      }\n\n      let isToDataObject = isDataObjectURL(dataObjectURL);\n      let isFromHyperty = divideURL(message.from).type === 'hyperty';\n      let isToHyperty = divideURL(message.to).type === 'hyperty';\n\n      if (message.type === 'update') {\n        resolve(message);\n      }\n\n      //is is hyperty to hyperty communication\n      if (isFromHyperty && isToHyperty) {\n        //console.log('decrypt hyperty to hyperty');\n        let userURL = _this._registry.getHypertyOwner(message.to);\n        if (userURL) {\n\n          let chatKeys = _this.chatKeys[message.to + '<->' + message.from];\n          if (!chatKeys) {\n            chatKeys = _this._newChatCrypto(message, userURL, 'decrypt');\n            _this.chatKeys[message.to + '<->' + message.from] = chatKeys;\n          }\n\n          if (chatKeys.authenticated && !isHandShakeType) {\n            let value = JSON.parse(message.body.value);\n            let iv = _this.crypto.decode(value.iv);\n            let data = _this.crypto.decode(value.value);\n            let hash = _this.crypto.decode(value.hash);\n            _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv).then(decryptedData => {\n              console.log('decrypted value ', decryptedData);\n              message.body.value = decryptedData;\n\n              let filteredMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n              _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hash).then(result => {\n                //console.log('result of hash verification! ', result);\n                message.body.assertedIdentity = true;\n                resolve(message);\n              });\n            });\n\n          } else if (isHandShakeType) {\n            _this._doHandShakePhase(message, chatKeys).then(function(value) {\n\n              //if it was started by doMutualAuthentication then ends the protocol\n              if (value === 'handShakeEnd') {\n                reject('decrypt handshake protocol phase ');\n\n              // if was started by a message, then resend that message\n              } else {\n                _this.chatKeys[message.to + '<->' + message.from] = value.chatKeys;\n                _this._messageBus.postMessage(value.message);\n                reject('decrypt handshake protocol phase ');\n              }\n            });\n          } else {\n            reject('wrong message do decrypt');\n          }\n        } else {\n          reject('error on decrypt message');\n        }\n\n        //if from hyperty to a dataObjectURL\n      } else if (isFromHyperty && isToDataObject) {\n        console.log('dataObject value to decrypt: ', message.body);\n\n        // TIAGO - persistence issue #147\n        _this.storageManager.get('dataObjectSessionKeys').then((sessionKeys) => {\n          let dataObjectKey = sessionKeys[dataObjectURL];\n\n          if (dataObjectKey) {\n\n            //check if is to apply encryption\n            if (dataObjectKey.isToEncrypt) {\n              let parsedValue = JSON.parse(message.body.value);\n              let iv = _this.crypto.decode(parsedValue.iv);\n              let encryptedValue = _this.crypto.decode(parsedValue.value);\n              let hash = _this.crypto.decode(parsedValue.hash);\n\n              _this.crypto.decryptAES(dataObjectKey.sessionKey, encryptedValue, iv).then(decryptedValue => {\n                let parsedValue = JSON.parse(atob(decryptedValue));\n                console.log('decrypted Value,', parsedValue);\n                message.body.value = parsedValue;\n\n                let filteredMessage = _this._filterMessageToHash(message, parsedValue + iv);\n\n                _this.crypto.verifyHMAC(dataObjectKey.sessionKey, filteredMessage, hash).then(result => {\n                  //console.log('result of hash verification! ', result);\n\n                  message.body.assertedIdentity = true;\n                  resolve(message);\n                });\n              });\n\n            //if not, just return the message\n            } else {\n              message.body.assertedIdentity = true;\n              resolve(message);\n            }\n\n          } else {\n            message.body.assertedIdentity = true;\n            resolve(message);\n\n            //reject('no sessionKey for chat room found');\n          }\n        });\n\n      } else {\n        reject('wrong message to decrypt');\n      }\n\n    });\n  }\n\n  doMutualAuthentication(sender, receiver) {\n    console.log('doMutualAuthentication: ', sender, receiver);\n    let _this = this;\n    let dataObjectURL;\n\n    // check if the sender is a dataObject and if so stores that value\n    let reporterURL = _this.registry.getReporterURLSynchonous(sender);\n    if (reporterURL) {\n      dataObjectURL = sender;\n      sender = reporterURL;\n    }\n\n    let msg = {\n      to: receiver,\n      from: sender,\n      callback: undefined,\n      body: {handshakePhase: 'startHandShake', ignore: 'ignoreMessage'}\n    };\n\n    return new Promise(function(resolve, reject) {\n\n      if (!sender || !receiver) {\n        return reject('sender or receiver missing on doMutualAuthentication');\n      }\n\n      let chatKeys = _this.chatKeys[sender + '<->' + receiver];\n      let userURL = _this._registry.getHypertyOwner(sender);\n\n      if (userURL) {\n\n        if (!chatKeys) {\n          // callback to resolve when finish the mutual authentication\n          let resolved = function(value) {\n            console.log('callback value:', value);\n            resolve(value);\n          };\n          msg.callback = resolved;\n          msg.dataObjectURL = dataObjectURL;\n\n          chatKeys = _this._newChatCrypto(msg, userURL);\n          _this.chatKeys[sender + '<->' + receiver] = chatKeys;\n        }\n\n        if (chatKeys.authenticated) {\n\n          let startSessionKeyExchange = {\n            to: sender,\n            from: receiver\n          };\n          chatKeys.dataObjectURL = dataObjectURL;\n          _this._sendReporterSessionKey(startSessionKeyExchange, chatKeys).then(value => {\n\n            _this._messageBus.postMessage(value.message);\n            resolve('exchange of chat sessionKey initiated');\n          });\n        } else {\n\n          _this._doHandShakePhase(msg, chatKeys);\n        }\n      } else {\n        reject('error on doMutualAuthentication');\n      }\n    });\n\n  }\n\n  _doHandShakePhase(message, chatKeys) {\n    let _this = this;\n\n    //console.log('handshakeType');\n\n    return new Promise(function(resolve,reject) {\n\n      let handshakeType = message.body.handshakePhase;\n      let iv;\n      let hash;\n      let value = {};\n      let filteredMessage;\n      switch (handshakeType) {\n\n        case 'startHandShake':\n          chatKeys.keys.fromRandom = _this.crypto.generateRandom();\n\n          let startHandShakeMsg = {\n            type: 'handshake',\n            to: message.to,\n            from: message.from,\n            body: {\n              handshakePhase: 'senderHello',\n              value: _this.crypto.encode(chatKeys.keys.fromRandom)\n            }\n          };\n          chatKeys.handshakeHistory.senderHello = _this._filterMessageToHash(startHandShakeMsg, undefined, chatKeys.hypertyFrom.messageInfo);\n\n          // check if was the encrypt function or the mutual authentication that request the\n          // start of the handShakePhase.\n          if (chatKeys.initialMessage) {resolve({message: startHandShakeMsg, chatKeys: chatKeys});\n          } else {\n            _this.chatKeys[message.from + '<->' + message.to] = chatKeys;\n            _this._messageBus.postMessage(startHandShakeMsg);\n          }\n\n        break;\n        case 'senderHello':\n\n          console.log('senderHello');\n          chatKeys.handshakeHistory.senderHello = _this._filterMessageToHash(message);\n          chatKeys.keys.fromRandom = _this.crypto.decode(message.body.value);\n          chatKeys.keys.toRandom = _this.crypto.generateRandom();\n\n          let senderHelloMsg = {\n            type: 'handshake',\n            to: message.from,\n            from: message.to,\n            body: {\n              handshakePhase: 'receiverHello',\n              value: _this.crypto.encode(chatKeys.keys.toRandom)\n            }\n          };\n          chatKeys.handshakeHistory.receiverHello = _this._filterMessageToHash(senderHelloMsg, undefined, chatKeys.hypertyFrom.messageInfo);\n          resolve({message: senderHelloMsg, chatKeys: chatKeys});\n\n        break;\n        case 'receiverHello':\n\n          console.log('receiverHello');\n          chatKeys.handshakeHistory.receiverHello = _this._filterMessageToHash(message);\n\n          _this.validateAssertion(message.body.identity.assertion, undefined, message.body.identity.idp).then((value) => {\n\n            //TODO remove later this verification as soon as all the IdP proxy are updated in the example\n            let encodedpublicKey = (typeof value.contents === 'string') ? value.contents : value.contents.nonce;\n\n            let receiverPublicKey = _this.crypto.decode(encodedpublicKey);\n            let premasterSecret = _this.crypto.generatePMS();\n            let toRandom = message.body.value;\n            chatKeys.hypertyTo.assertion = message.body.identity.assertion;\n            chatKeys.hypertyTo.publicKey = receiverPublicKey;\n            chatKeys.hypertyTo.userID    = value.contents.email;\n            chatKeys.keys.toRandom  = _this.crypto.decode(toRandom);\n            chatKeys.keys.premasterKey = premasterSecret;\n\n            let concatKey = _this.crypto.concatPMSwithRandoms(premasterSecret, chatKeys.keys.toRandom, chatKeys.keys.fromRandom);\n\n            return _this.crypto.generateMasterSecret(concatKey, 'messageHistoric' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            //generate the master key\n          }).then((masterKey) => {\n            chatKeys.keys.masterKey = masterKey;\n\n            return _this.crypto.generateKeys(masterKey, 'key expansion' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            //generate the symmetric and hash keys\n          }).then((keys) => {\n\n            chatKeys.keys.hypertyToSessionKey = new Uint8Array(keys[0]);\n            chatKeys.keys.hypertyFromSessionKey = new Uint8Array(keys[1]);\n            chatKeys.keys.hypertyToHashKey = new Uint8Array(keys[2]);\n            chatKeys.keys.hypertyFromHashKey = new Uint8Array(keys[3]);\n            iv = _this.crypto.generateIV();\n            value.iv = _this.crypto.encode(iv);\n\n            let messageStructure = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'senderCertificate'\n              }\n            };\n\n            // hash the value and the iv\n            filteredMessage = _this._filterMessageToHash(messageStructure, 'ok' + iv, chatKeys.hypertyFrom.messageInfo);\n            return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage);\n          }).then((hash) => {\n            value.hash = _this.crypto.encode(hash);\n\n            //encrypt the data\n            return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok', iv);\n          }).then((encryptedData) => {\n            value.symetricEncryption = _this.crypto.encode(encryptedData);\n\n            return _this.crypto.encryptRSA(chatKeys.hypertyTo.publicKey, chatKeys.keys.premasterKey);\n\n          }).then((encryptedValue) => {\n\n            value.assymetricEncryption = _this.crypto.encode(encryptedValue);\n\n            let messageStructure = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'senderCertificate'\n              }\n            };\n\n            let messageToHash = _this._filterMessageToHash(messageStructure, chatKeys.keys.premasterKey, chatKeys.hypertyFrom.messageInfo);\n\n            return _this.crypto.signRSA(chatKeys.hypertyFrom.privateKey, JSON.stringify(chatKeys.handshakeHistory) + JSON.stringify(messageToHash));\n\n          }).then(signature => {\n\n            value.signature = _this.crypto.encode(signature);\n\n            let receiverHelloMsg = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'senderCertificate',\n                value: btoa(JSON.stringify(value))\n              }\n            };\n            chatKeys.handshakeHistory.senderCertificate = _this._filterMessageToHash(receiverHelloMsg, 'ok' + iv, chatKeys.hypertyFrom.messageInfo);\n\n            resolve({message: receiverHelloMsg, chatKeys: chatKeys});\n\n          }, error => reject(error));\n\n        break;\n        case 'senderCertificate':\n\n          console.log('senderCertificate');\n          let receivedValue = JSON.parse(atob(message.body.value));\n\n          _this.validateAssertion(message.body.identity.assertion, undefined, message.body.identity.idp).then((value) => {\n            let encryptedPMS = _this.crypto.decode(receivedValue.assymetricEncryption);\n\n            //TODO remove later this verification as soon as all the IdP proxy are updated in the example\n            let encodedpublicKey = (typeof value.contents === 'string') ? value.contents : value.contents.nonce;\n\n            let senderPublicKey = _this.crypto.decode(encodedpublicKey);\n            chatKeys.hypertyTo.assertion = message.body.identity.assertion;\n            chatKeys.hypertyTo.publicKey = senderPublicKey;\n            chatKeys.hypertyTo.userID    = value.contents.email;\n\n            return _this.crypto.decryptRSA(chatKeys.hypertyFrom.privateKey, encryptedPMS);\n\n          }, (error) => {\n            console.log(error);\n            reject('Error during authentication of identity');\n\n            //obtain the PremasterKey using the private key\n          }).then(pms => {\n\n            chatKeys.keys.premasterKey = new Uint8Array(pms);\n\n            let signature = _this.crypto.decode(receivedValue.signature);\n\n            let receivedmsgToHash = _this._filterMessageToHash(message, chatKeys.keys.premasterKey);\n\n            return _this.crypto.verifyRSA(chatKeys.hypertyTo.publicKey, JSON.stringify(chatKeys.handshakeHistory) + JSON.stringify(receivedmsgToHash), signature);\n\n            // validates the signature received\n          }).then(signValidationResult => {\n\n            console.log('signature validation result ', signValidationResult);\n            let concatKey = _this.crypto.concatPMSwithRandoms(chatKeys.keys.premasterKey, chatKeys.keys.toRandom, chatKeys.keys.fromRandom);\n\n            return _this.crypto.generateMasterSecret(concatKey, 'messageHistoric' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            // generates the master keys from the Premaster key and the randoms\n          }).then(masterKey => {\n            chatKeys.keys.masterKey = masterKey;\n\n            return _this.crypto.generateKeys(masterKey, 'key expansion' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            // generates the symmetric keys to be used in the symmetric encryption\n          }).then(keys => {\n            chatKeys.keys.hypertyFromSessionKey = new Uint8Array(keys[0]);\n            chatKeys.keys.hypertyToSessionKey = new Uint8Array(keys[1]);\n            chatKeys.keys.hypertyFromHashKey = new Uint8Array(keys[2]);\n            chatKeys.keys.hypertyToHashKey = new Uint8Array(keys[3]);\n            iv = _this.crypto.decode(receivedValue.iv);\n            let data = _this.crypto.decode(receivedValue.symetricEncryption);\n\n            return _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv);\n\n          }).then(decryptedData => {\n            //console.log('decryptedData', decryptedData);\n\n            chatKeys.handshakeHistory.senderCertificate = _this._filterMessageToHash(message, decryptedData + iv);\n\n            let hashReceived = _this.crypto.decode(receivedValue.hash);\n\n            filteredMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n            return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hashReceived);\n\n          }).then(verifiedHash  => {\n\n            //console.log('result of hash verification ', verifiedHash);\n            let receiverFinishedMessage = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'receiverFinishedMessage'\n              }\n            };\n            iv = _this.crypto.generateIV();\n            value.iv = _this.crypto.encode(iv);\n\n            filteredMessage = _this._filterMessageToHash(receiverFinishedMessage, 'ok!' + iv, chatKeys.hypertyFrom.messageInfo);\n\n            return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, receiverFinishedMessage);\n          }).then(hash => {\n\n            value.hash = _this.crypto.encode(hash);\n            return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok!', iv);\n\n          }).then(encryptedValue => {\n            value.value = _this.crypto.encode(encryptedValue);\n            let receiverFinishedMessage = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'receiverFinishedMessage',\n                value: btoa(JSON.stringify(value))\n              }\n            };\n\n            chatKeys.handshakeHistory.receiverFinishedMessage = _this._filterMessageToHash(receiverFinishedMessage, 'ok!' + iv, chatKeys.hypertyFrom.messageInfo);\n            chatKeys.authenticated = true;\n            resolve({message: receiverFinishedMessage, chatKeys: chatKeys});\n          });\n\n        break;\n        case 'receiverFinishedMessage':\n\n          console.log('receiverFinishedMessage');\n          chatKeys.authenticated = true;\n\n          value = JSON.parse(atob(message.body.value));\n\n          iv = _this.crypto.decode(value.iv);\n          let data = _this.crypto.decode(value.value);\n          hash = _this.crypto.decode(value.hash);\n\n          _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv).then(decryptedData => {\n            console.log('decryptedData', decryptedData);\n            chatKeys.handshakeHistory.receiverFinishedMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n            let filteredMessage = _this._filterMessageToHash(message, data + iv);\n            _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hash).then(result => {\n              console.log('hash result', result);\n\n              // check if there was an initial message that was blocked and send it\n              if (chatKeys.initialMessage) {\n                let initialMessage = {\n                  type: 'create',\n                  to: message.from,\n                  from: message.to,\n                  body: {\n                    value: chatKeys.initialMessage.body.value\n                  }\n                };\n\n                resolve({message: initialMessage, chatKeys: chatKeys});\n\n                //sends the sessionKey to the subscriber hyperty\n              } else {\n                _this._sendReporterSessionKey(message, chatKeys).then(value => {\n                  resolve(value);\n                });\n              }\n            });\n          });\n\n        break;\n        case 'reporterSessionKey':\n\n          console.log('reporterSessionKey');\n\n          let valueIVandHash = JSON.parse(atob(message.body.value));\n          hash = _this.crypto.decode(valueIVandHash.hash);\n          iv = _this.crypto.decode(valueIVandHash.iv);\n          let encryptedValue = _this.crypto.decode(valueIVandHash.value);\n          let parsedValue;\n          let sessionKey;\n          let dataObjectURL;\n          let receiverAcknowledgeMsg;\n\n          console.log('[IdentityModule reporterSessionKey] - decryptAES: ', chatKeys.keys.hypertyToSessionKey, encryptedValue, iv);\n\n          _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, encryptedValue, iv).then(decryptedValue => {\n\n            parsedValue = JSON.parse(decryptedValue);\n            sessionKey = _this.crypto.decode(parsedValue.value);\n            dataObjectURL = parsedValue.dataObjectURL;\n\n            let messageToHash = _this._filterMessageToHash(message, decryptedValue + iv);\n\n            return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, messageToHash, hash);\n\n          }).then(hashResult => {\n\n            //console.log('hash successfully validated ', hashResult);\n\n            _this.dataObjectSessionKeys[dataObjectURL] =  {sessionKey: sessionKey, isToEncrypt: true};\n\n            // TIAGO - persistence issue #147\n            _this.storageManager.set('dataObjectSessionKeys', 0, _this.dataObjectSessionKeys);\n\n            iv = _this.crypto.generateIV();\n            value.iv = _this.crypto.encode(iv);\n\n            return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok!!', iv);\n          }).then(encryptedValue => {\n\n            receiverAcknowledgeMsg = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'receiverAcknowledge'\n              }\n            };\n\n            value.value = _this.crypto.encode(encryptedValue);\n            let messageToHash = _this._filterMessageToHash(receiverAcknowledgeMsg, 'ok!!' + iv, chatKeys.hypertyFrom.messageInfo);\n\n            return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, messageToHash);\n          }).then(hashedMessage => {\n            let finalValue = btoa(JSON.stringify({value: value.value, hash: _this.crypto.encode(hashedMessage), iv: value.iv}));\n\n            receiverAcknowledgeMsg.body.value = finalValue;\n            resolve({message: receiverAcknowledgeMsg, chatKeys: chatKeys});\n          });\n\n        break;\n        case 'receiverAcknowledge':\n\n          console.log('receiverAcknowledge');\n\n          let receivedvalueIVandHash = JSON.parse(atob(message.body.value));\n          let receivedHash = _this.crypto.decode(receivedvalueIVandHash.hash);\n          iv = _this.crypto.decode(receivedvalueIVandHash.iv);\n          let receivedEncryptedValue = _this.crypto.decode(receivedvalueIVandHash.value);\n\n          _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, receivedEncryptedValue, iv).then(decryptedValue => {\n\n            let filteredMessage = _this._filterMessageToHash(message, decryptedValue + iv);\n            return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, receivedHash);\n          }).then(hashResult => {\n            //console.log('hashResult ', hashResult);\n\n            let callback = chatKeys.callback;\n\n            if (callback) {\n              callback('handShakeEnd');\n            }\n            resolve('handShakeEnd');\n          });\n\n        break;\n        default:\n          reject(message);\n      }\n    });\n  }\n\n  _sendReporterSessionKey(message, chatKeys) {\n    let _this = this;\n    let sessionKeyBundle = _this.dataObjectSessionKeys[chatKeys.dataObjectURL];\n    let reporterSessionKeyMsg;\n    let valueToEncrypt;\n    let sessionKey;\n    let iv;\n    let value = {};\n\n    return new Promise(function(resolve, reject) {\n\n      //if there is not yet a session Key, generates a new one\n      if (!sessionKeyBundle) {\n        sessionKey = _this.crypto.generateRandom();\n        _this.dataObjectSessionKeys[chatKeys.dataObjectURL] = {sessionKey: sessionKey, isToEncrypt: true};\n\n        // TIAGO - persistence issue #147\n        _this.storageManager.set('dataObjectSessionKeys', 0, _this.dataObjectSessionKeys);\n      } else {\n        sessionKey = sessionKeyBundle.sessionKey;\n      }\n\n      valueToEncrypt = JSON.stringify({value: _this.crypto.encode(sessionKey), dataObjectURL: chatKeys.dataObjectURL});\n\n      iv = _this.crypto.generateIV();\n      value.iv = _this.crypto.encode(iv);\n      _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, valueToEncrypt, iv).then(encryptedValue => {\n\n        reporterSessionKeyMsg = {\n          type: 'handshake',\n          to: message.from,\n          from: message.to,\n          body: {\n            handshakePhase: 'reporterSessionKey',\n            value: _this.crypto.encode(encryptedValue)\n          }\n        };\n\n        let filteredMessage = _this._filterMessageToHash(reporterSessionKeyMsg, valueToEncrypt + iv, chatKeys.hypertyFrom.messageInfo);\n\n        return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage);\n      }).then(hashedMessage => {\n\n        let valueWithHash = btoa(JSON.stringify({value: reporterSessionKeyMsg.body.value, hash: _this.crypto.encode(hashedMessage), iv: value.iv}));\n\n        reporterSessionKeyMsg.body.value = valueWithHash;\n        resolve({message: reporterSessionKeyMsg, chatKeys: chatKeys});\n      });\n    });\n  }\n\n  /**\n  * returns the reporter associated to the dataObject URL\n  * @param   {String}   dataObjectURL         dataObject url\n  * @return   {String}  reporter              dataObject url reporter\n  */\n  _getHypertyFromDataObject(dataObjectURL) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      //TODO remove this logic and move it to a util function\n\n      let splitedURL = dataObjectURL.split('/');\n      let finalURL = splitedURL[0] + '//' + splitedURL[2] + '/' + splitedURL[3];\n      if (splitedURL.length > 6) {\n        finalURL = splitedURL[0] + '//' + splitedURL[2] + '/' + splitedURL[3] + '/' + splitedURL[4];\n      }\n\n      // check if is the creator of the hyperty\n      let reporterURL = _this.registry.getReporterURLSynchonous(finalURL);\n\n      if (reporterURL) {\n        resolve(reporterURL);\n      } else {\n        // check if there is already an association from an hypertyURL to the dataObject\n        let storedReporterURL = _this.dataObjectsIdentity[finalURL];\n\n        if (storedReporterURL) {\n          resolve(storedReporterURL);\n        } else {\n          // check if there is any hyperty that subscribed the dataObjectURL\n          let subscriberHyperty = _this.registry.getDataObjectSubscriberHyperty(dataObjectURL);\n\n          if (subscriberHyperty) {\n            resolve(subscriberHyperty);\n          } else {\n\n            // search in domain registry for the hyperty associated to the dataObject\n            // search in case is a subscriber who wants to know the reporter\n            _this.registry.discoverDataObjectPerURL(finalURL, splitedURL[2]).then(dataObject => {\n              _this.dataObjectsIdentity[finalURL] = dataObject.reporter;\n              resolve(dataObject.reporter);\n            }, err => {\n              reject(err);\n            });\n          }\n        }\n      }\n    });\n  }\n\n  /**\n  * filter the messages to hash, by removing some fields not generated by the runtime core\n  * @param {Message}  message                     message\n  * @param {String}  decryptedValue (Optional)    value from body.value in case it originally comes encrypted\n  * @param {JSON}  identity(Optional)    add the hyperty identity associated in case is not added to the initial message\n  * @return {Message}  new message filtered\n  */\n  _filterMessageToHash(message, decryptedValue, identity) {\n\n    return {\n      type: message.type,\n      from: message.from,\n      to:   message.to,\n      body: {\n        identity: identity || message.body.identity,\n        value: decryptedValue || message.body.value,\n        handshakePhase: message.body.handshakePhase\n      }\n    };\n  }\n\n  /**\n  * generates the initial structure for the keys between two users\n  * @param {JSON}    message              initial message that triggers the mutual authentication\n  * @param {String}  userURL              userURL\n  * @param {boolean} receiver(Optional)  indicates if is the sender or the receiver that creates a new chat crypto\n  * @return {JSON} newChatCrypto  new JSON structure for the chat crypto\n  */\n  _newChatCrypto(message, userURL, receiver) {\n    let _this = this;\n\n    //check whether is the sender or the receiver to create a new chatCrypto\n    //to mantain consistency on the keys if the receiver create a new chatCrypto,\n    //then invert the fields\n    let from = (receiver) ? message.to : message.from;\n    let to = (receiver) ? message.from : message.to;\n\n    let userInfo = _this.getIdentity(userURL);\n\n    let newChatCrypto =\n    {\n      hypertyFrom:\n      {\n        hyperty: from,\n        userID: userInfo.messageInfo.userProfile.username,\n        privateKey: userInfo.keyPair.private,\n        publicKey: userInfo.keyPair.public,\n        assertion: userInfo.assertion,\n        messageInfo: userInfo.messageInfo\n      },\n      hypertyTo:\n      {\n        hyperty: to,\n        userID: undefined,\n        publicKey: undefined,\n        assertion: undefined\n      },\n      keys:\n      {\n        hypertyToSessionKey: undefined,\n        hypertyFromSessionKey: undefined,\n        hypertyToHashKey: undefined,\n        hypertyFromHashKey: undefined,\n        toRandom: undefined,\n        fromRandom: undefined,\n        premasterKey: undefined,\n        masterKey: undefined\n      },\n      handshakeHistory: {\n        senderHello: undefined,\n        receiverHello: undefined,\n        senderCertificate: undefined,\n        receiverFinishedMessage: undefined\n      },\n      initialMessage: (message.body.ignore) ? undefined : message,\n      callback: message.callback,\n      authenticated: false,\n      dataObjectURL: message.dataObjectURL\n    };\n\n    return newChatCrypto;\n  }\n}\n\nexport default IdentityModule;\n",
    "static": true,
    "longname": "src/identity/IdentityModule.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 203,
    "kind": "class",
    "name": "IdentityModule",
    "memberof": "src/identity/IdentityModule.js",
    "static": true,
    "longname": "src/identity/IdentityModule.js~IdentityModule",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/identity/IdentityModule.js",
    "importStyle": "IdentityModule",
    "description": "\nThe Identity Module (Id Module) is the component responsible for handling the\nuser identity and the association of this identity with the Hyperty instances,\nin order to make Hyperty instances identifiable. The identity in the reTHINK project\nis not fixed to a unique Identity Service Provider, but obtained through several\ndifferent Identity sources. With this approach, the Id Module provides to the user the\noption to choose the preferred method for authentication.\nThis module will thus able to support multiple Identity acquisition methods,\nsuch as OpenID connect 1.0, Kerberos System, or authentication through smart cards.\nFor example, a user with a Google account can use the Google as an Identity Provider to provide Identity Tokens,\n which can be used by the Identity Module to associate it with a Hyperty instance.\n\nThe Identity Module uses a node package, the HelloJS, which is a client-side JavaScript API for authentication\nthat facilitates the requests for the OpenID connect protocol. This method allows for some abstraction\nwhen making requests for different Identity Providers, such as OpenID connect used by Google, Facebook, Microsoft, for example.\n\nWhen a request for a user identity is made using the method loginWithRP(identifier, scope),\nthis method will analyse the Identity Provider chosen to obtain an identity and will use the HelloJS node package\nwith the selected Identity Provider and identity scope. After the HelloJS request for an Access Token\nto the Identity Providers, the user will be prompted to authenticate towards the Identity Provider.\nUpon receiving the Access Token, this token is validated with a RESTful web service request to an endpoint\non the Identity Provider Authorization Server, and after the validation is done,\nan ID token is obtained with the information according to the scope required.\nThis ID token is then preserved in this module that can obtained through the getIdentities()\nand is passed as return value of the loginWithRP function. The methods generateAssertion and validateAssertion have not yet been developed.",
    "lineNumber": 35,
    "interface": false
  },
  {
    "__docId__": 204,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#constructor",
    "access": null,
    "description": "This is the constructor to initialise the Identity Module it does not require any input.",
    "lineNumber": 40,
    "params": [
      {
        "name": "runtimeURL",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtimeCapabilities",
        "types": [
          "*"
        ]
      },
      {
        "name": "storageManager",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 205,
    "kind": "get",
    "name": "messageBus",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#messageBus",
    "access": null,
    "description": "return the messageBus in this Registry",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "set",
    "name": "messageBus",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#messageBus",
    "access": null,
    "description": "Set the messageBus in this Registry",
    "lineNumber": 97,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "get",
    "name": "registry",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#registry",
    "access": null,
    "description": "return the registry in this idModule",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "registry"
        ],
        "spread": false,
        "optional": false,
        "name": "registry",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "set",
    "name": "registry",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#registry",
    "access": null,
    "description": "Set the registry in this idModule",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "registry"
        ],
        "spread": false,
        "optional": false,
        "name": "reg",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "getIdentities",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdentities",
    "access": null,
    "description": "Function to return all the identities registered within a session by a user.\nThese identities are returned in an array containing a JSON package for each user identity.",
    "lineNumber": 126,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<Identities>"
      ],
      "spread": false,
      "description": "Identities"
    }
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "getIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdentity",
    "access": null,
    "description": "gets all the information from a given userURL",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userURL",
        "description": "user url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "identity    identity bundle from the userURL"
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "_loadIdentities",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_loadIdentities",
    "access": null,
    "description": null,
    "lineNumber": 150,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "deployGUI",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#deployGUI",
    "access": null,
    "description": null,
    "lineNumber": 164,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "getToken",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getToken",
    "access": null,
    "description": "get a Token to be added to a message",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "fromURL",
        "description": "origin of the message"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "toURL",
        "description": "target of the message"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "token    token to be added to the message"
    }
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "getIdToken",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdToken",
    "access": null,
    "description": "get an Id Token for a HypertyURL",
    "lineNumber": 235,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hypertyURL",
        "description": "the Hyperty address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "token    Id token to be added to the message"
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "getAccessToken",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getAccessToken",
    "access": null,
    "description": "get an Access Token for a legacyURL",
    "lineNumber": 284,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "legacyURL",
        "description": "the legacy address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "token    Access token to be added to the message"
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "getIdentitiesToChoose",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdentitiesToChoose",
    "access": null,
    "description": null,
    "lineNumber": 302,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "{\"identities\": *, \"idps\": *}"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "getUsersIDs",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getUsersIDs",
    "access": null,
    "description": "Function to return all the users URLs registered within a session\nThese users URLs are returned in an array of strings.",
    "lineNumber": 316,
    "params": [
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "emailFormat",
        "description": "(Optional)   boolean to indicate to return in email format"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<String>"
      ],
      "spread": false,
      "description": "users"
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "getCurrentIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getCurrentIdentity",
    "access": null,
    "description": "Function to return the selected Identity within a session",
    "lineNumber": 334,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Identity"
      ],
      "spread": false,
      "description": "identity         identity"
    }
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "setCurrentIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#setCurrentIdentity",
    "access": null,
    "description": "Function to set the current Identity with a given Identity",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "identity"
      }
    ]
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "deleteIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#deleteIdentity",
    "access": null,
    "description": "Function to remove an identity from the Identities array",
    "lineNumber": 352,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userID",
        "description": "userID"
      }
    ]
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "unregisterIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#unregisterIdentity",
    "access": null,
    "description": "Function to unregister an identity from the emailsList array and not show in to the GUI",
    "lineNumber": 368,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": "email"
      }
    ]
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "_resolveDomain",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_resolveDomain",
    "access": null,
    "description": "Function that resolve and create the domainURL in case it is provided one. If not, resolve the default domainURL",
    "lineNumber": 382,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "idpDomain",
        "description": "idpDomain (Optional)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "requestIdentityToGUI",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#requestIdentityToGUI",
    "access": null,
    "description": "Function that sends a request to the GUI using messages. Sends all identities registered and\nthe Idps supported, and return the identity/idp received by the GUI",
    "lineNumber": 397,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "identities",
        "description": "list of identitiies"
      },
      {
        "nullable": null,
        "types": [
          "Array<String>"
        ],
        "spread": false,
        "optional": false,
        "name": "idps",
        "description": "list of idps to authenticate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "returns a chosen identity or idp"
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "openPopup",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#openPopup",
    "access": null,
    "description": null,
    "lineNumber": 433,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "urlreceived",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "getIdentityAssertion",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdentityAssertion",
    "access": null,
    "description": "Function that fetch an identityAssertion from a user.",
    "lineNumber": 477,
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "origin",
        "types": [
          "*"
        ]
      },
      {
        "name": "usernameHint",
        "types": [
          "*"
        ]
      },
      {
        "name": "idpDomain",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IdAssertion"
      ],
      "spread": false,
      "description": "IdAssertion"
    }
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "callGenerateMethods",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#callGenerateMethods",
    "access": null,
    "description": null,
    "lineNumber": 571,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "idp",
        "types": [
          "*"
        ]
      },
      {
        "name": "origin",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "sendGenerateMessage",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#sendGenerateMessage",
    "access": null,
    "description": null,
    "lineNumber": 602,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "contents",
        "types": [
          "*"
        ]
      },
      {
        "name": "origin",
        "types": [
          "*"
        ]
      },
      {
        "name": "usernameHint",
        "types": [
          "*"
        ]
      },
      {
        "name": "idpDomain",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "storeIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#storeIdentity",
    "access": null,
    "description": null,
    "lineNumber": 618,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      },
      {
        "name": "keyPair",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "generateAssertion",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#generateAssertion",
    "access": null,
    "description": "Requests the IdpProxy from a given Domain for an identityAssertion",
    "lineNumber": 714,
    "params": [
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "contents"
      },
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "origin",
        "description": "origin"
      },
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "usernameHint",
        "description": "usernameHint"
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "keyPair",
        "description": "user keyPair"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IdAssertion"
      ],
      "spread": false,
      "description": "IdAssertion"
    }
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "validateAssertion",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#validateAssertion",
    "access": null,
    "description": "Requests the IdpProxy from a given Domain to validate an IdentityAssertion\nReturns a promise with the result from the validation.",
    "lineNumber": 757,
    "params": [
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "assertion",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "origin",
        "description": "origin"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise         promise with the result from the validation"
    }
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "encryptMessage",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#encryptMessage",
    "access": null,
    "description": null,
    "lineNumber": 776,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "decryptMessage",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#decryptMessage",
    "access": null,
    "description": null,
    "lineNumber": 913,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "doMutualAuthentication",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#doMutualAuthentication",
    "access": null,
    "description": null,
    "lineNumber": 1047,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "sender",
        "types": [
          "*"
        ]
      },
      {
        "name": "receiver",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "_doHandShakePhase",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_doHandShakePhase",
    "access": null,
    "description": null,
    "lineNumber": 1113,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "chatKeys",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "_sendReporterSessionKey",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_sendReporterSessionKey",
    "access": null,
    "description": null,
    "lineNumber": 1511,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "chatKeys",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "_getHypertyFromDataObject",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_getHypertyFromDataObject",
    "access": null,
    "description": "returns the reporter associated to the dataObject URL",
    "lineNumber": 1567,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectURL",
        "description": "dataObject url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "reporter              dataObject url reporter"
    }
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "_filterMessageToHash",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_filterMessageToHash",
    "access": null,
    "description": "filter the messages to hash, by removing some fields not generated by the runtime core",
    "lineNumber": 1620,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "message"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "decryptedValue",
        "description": "(Optional)    value from body.value in case it originally comes encrypted"
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "identity(Optional)",
        "description": "add the hyperty identity associated in case is not added to the initial message"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": "new message filtered"
    }
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "_newChatCrypto",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_newChatCrypto",
    "access": null,
    "description": "generates the initial structure for the keys between two users",
    "lineNumber": 1641,
    "params": [
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "initial message that triggers the mutual authentication"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userURL",
        "description": "userURL"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "receiver(Optional)",
        "description": "indicates if is the sender or the receiver that creates a new chat crypto"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "newChatCrypto  new JSON structure for the chat crypto"
    }
  },
  {
    "__docId__": 239,
    "kind": "file",
    "name": "src/identity/OpenIdLib.js",
    "content": "//import hello from 'hellojs';\r\n\r\n/**\r\n*  class to facilitate the operations with the openID connect, through several Identity Providers\r\n*\r\n*/\r\nclass OpenIdLib {\r\n\r\n  constructor(identityProvider, clientID) {\r\n    let _this = this;\r\n    _this.clientID = clientID;\r\n    _this.identityProvider = identityProvider;\r\n\r\n    switch (identityProvider) {\r\n      case 'google':\r\n        let googleInfo = new GoogleInfo();\r\n        _this.info = googleInfo;\r\n        break;\r\n      case 'facebook':\r\n        let facebookInfo = new FacebookInfo();\r\n        _this.info = facebookInfo;\r\n        break;\r\n      case 'windows':\r\n        let microsoftInfo = new MicrosoftInfo();\r\n        _this.info = microsoftInfo;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  openPopup() {\r\n    let _this = this;\r\n\r\n    let REDIRECT   =   _this.info.REDIRECT;\r\n    let URL        =   _this.info.URL;\r\n\r\n    let acToken;\r\n    let tokenType;\r\n    let expiresIn;\r\n\r\n    return new Promise(function(resolve,reject) {\r\n\r\n      //function to parse the query string in the given URL to obatin certain values\r\n      function gup(url, name) {\r\n        name = name.replace(/[\\[]/, '\\\\\\[').replace(/[\\]]/, '\\\\\\]');\r\n        let regexS = '[\\\\#&?]' + name + '=([^&#]*)';\r\n        let regex = new RegExp(regexS);\r\n        let results = regex.exec(url);\r\n        if (results === null)\r\n        return '';\r\n        else\r\n        return results[1];\r\n      }\r\n\r\n      /*hello.init({google: '808329566012-tqr8qoh111942gd2kg007t0s8f277roi.apps.googleusercontent.com',\r\n                 facebook: '655302667942219',\r\n                 windows: 'asdf197f6ad6-808f-4ddc-b725-3d8fe2660349'});\r\n      hello(_this.identityProvider).login({scope: 'email'}).then(function(token) {\r\n        console.log(token);\r\n        resolve(token.authResponse.access_token);\r\n      }, function(error) {\r\n        console.log('errorValidating ', error);\r\n        reject(error);\r\n      });*/\r\n\r\n      let win = window.open(URL, 'openIDrequest', 'width=800, height=600');\r\n      let pollTimer = window.setInterval(function() {\r\n        try {\r\n          //console.log(win.document.URL);\r\n\r\n          if (win.closed) {\r\n            reject('Some error occured.');\r\n            clearInterval(pollTimer);\r\n          }\r\n\r\n          let redirectURL = document.URL;//window.location.origin;\r\n          if (win.document.URL.indexOf('REDIRECT') !== -1 || win.document.URL.indexOf(redirectURL) !== -1) {\r\n            window.clearInterval(pollTimer);\r\n            let url =   win.document.URL;\r\n\r\n            //not working yet. Some problems with the 'POST' method\r\n            if (_this.identityProvider === 'windows') {\r\n              let code = gup(url, 'code');\r\n              let sessionState = gup(url, 'session_state');\r\n\r\n              let reqAccessURL = _this.info.TOKENEND + 'redirect_uri=' + _this.info.REDIRECT + '&grant_type=authorization_code' + '&client_id=' + _this.info.CLIENTID + '&code=' + code;\r\n\r\n              win.close();\r\n\r\n              let req = new XMLHttpRequest();\r\n              req.open('POST',  _this.info.TOKENEND, true);\r\n              req.setRequestHeader('Access-Control-Allow-Origin', '*');\r\n\r\n              let data = new FormData();\r\n              data.append('redirect_uri', _this.info.REDIRECT);\r\n              data.append('grant_type', 'authorization_code');\r\n              data.append('client_id', _this.info.CLIENTID);\r\n              data.append('code', code);\r\n\r\n              req.onreadystatechange = function(e) {\r\n                if (req.readyState === 4) {\r\n                  if (req.status === 200) {\r\n\r\n                    resolve('null');\r\n                  } else if (req.status === 400) {\r\n                    reject('There was an error processing the token');\r\n                  } else {\r\n                    reject('something else other than 200 was returned');\r\n                  }\r\n                }\r\n              };\r\n              req.send(data);\r\n\r\n            } else {\r\n\r\n              acToken =   gup(url, 'access_token');\r\n              tokenType = gup(url, 'token_type'); //FACEBOOK does not return tokenType in the field\r\n              expiresIn = gup(url, 'expires_in');\r\n\r\n              win.close();\r\n\r\n              if (_this.identityProvider === 'facebook') {\r\n                _this.info.VALIDURL = 'https://graph.facebook.com/debug_token?input_token=' + acToken + '&access_token=';\r\n              }\r\n\r\n              //after receiving the access token, google requires to validate first the token to prevent confused deputy problem.\r\n              resolve(acToken);\r\n            }\r\n          }\r\n        } catch (e) {\r\n          //console.log(e);\r\n        }\r\n      }, 1000);\r\n    });\r\n  }\r\n\r\n  validateToken(token) {\r\n    let _this = this;\r\n    let tokenID;\r\n    let VALIDURL = _this.info.VALIDURL;\r\n    return new Promise(function(resolve, reject) {\r\n      let req = new XMLHttpRequest();\r\n      req.open('GET', VALIDURL + token, true);\r\n\r\n      req.onreadystatechange = function(e) {\r\n        if (req.readyState === 4) {\r\n          if (req.status === 200) {\r\n            tokenID = JSON.parse(req.responseText);\r\n\r\n            resolve({token:token, tokenID: tokenID});\r\n          } else if (req.status === 400) {\r\n            reject('There was an error processing the token');\r\n          } else {\r\n            reject('something else other than 200 was returned');\r\n          }\r\n        }\r\n      };\r\n      req.send();\r\n\r\n    });\r\n  }\r\n\r\n  //function to exchange the access token with an ID Token containing the information\r\n  getInfoToken(token, tokenID) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve,reject) {\r\n      let USERINFURL =   _this.info.USERINFURL;\r\n\r\n      let req = new XMLHttpRequest();\r\n      req.open('GET', USERINFURL + token, true);\r\n\r\n      req.onreadystatechange = function(e) {\r\n        if (req.readyState === 4) {\r\n          if (req.status === 200) {\r\n            let infoToken = JSON.parse(req.responseText);\r\n            let email = infoToken.email;\r\n\r\n            //contruct the identityURL to be defined as in specification\r\n            // model: user://<idpdomain>/<user-identifier>\r\n            let identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\r\n\r\n            //TODO remove later the 'token' field key\r\n            let identityBundle = {identity: identityURL, token: infoToken, accessToken: token, idToken: tokenID, infoToken: infoToken, idp: 'google'};\r\n\r\n            resolve(identityBundle);\r\n          } else if (req.status === 400) {\r\n            reject('There was an error processing the token');\r\n          } else {\r\n            reject('something else other than 200 was returned');\r\n          }\r\n        }\r\n      };\r\n      req.send();\r\n    });\r\n  }\r\n}\r\n\r\n//Google works fine with OpenID connect\r\nclass GoogleInfo {\r\n  constructor() {\r\n    let _this = this;\r\n    _this.OAUTHURL   =   'https://accounts.google.com/o/oauth2/auth?';\r\n    _this.SCOPE      =   'email%20profile';\r\n    _this.CLIENTID   =   '808329566012-tqr8qoh111942gd2kg007t0s8f277roi.apps.googleusercontent.com';\r\n    _this.REDIRECT   =    document.URL;\r\n    _this.TYPE       =   'token';\r\n    _this.VALIDURL   =   'https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=';\r\n    _this.USERINFURL =   'https://www.googleapis.com/oauth2/v1/userinfo?access_token=';\r\n\r\n    _this.URL        =   _this.OAUTHURL + 'scope=' + _this.SCOPE + '&client_id=' + _this.CLIENTID + '&redirect_uri=' + _this.REDIRECT + '&response_type=' + _this.TYPE;\r\n  }\r\n}\r\n\r\n//Facebook only provides the support for Oauth2 Tokens, and do not directly provide support for OpenID connect. So, no 'oficial' ID token can be requested, just information about the user.\r\nclass FacebookInfo {\r\n  constructor() {\r\n    let _this = this;\r\n    _this.OAUTHURL   =    'https://www.facebook.com/dialog/oauth?';\r\n    _this.CLIENTID   =    655302667942219;\r\n    _this.REDIRECT   =    document.URL; // 'http://localhost:8080/example/index.html';\r\n    _this.TYPE       =    'token';\r\n    _this.VALIDURL   =    'https://graph.facebook.com/debug_token?input_token='; //must be updated later\r\n    _this.USERINFURL = 'https://graph.facebook.com/v2.5/me?fields=id,name,email,picture&access_token=';\r\n    _this.URL        =    _this.OAUTHURL + 'client_id=' + _this.CLIENTID + '&redirect_uri=' + _this.REDIRECT + '&response_type=' + _this.TYPE;\r\n  }\r\n}\r\n\r\n\r\n//Microsoft is not yet implemented to obtain the Access token / ID token. Some troubles to request the Access token, since it is required to make a http Post request with the authorization code.\r\nclass MicrosoftInfo {\r\n  constructor() {\r\n    let _this = this;\r\n    _this.OAUTHURL   =    'https://login.microsoftonline.com/common/oauth2/authorize?';\r\n    _this.CLIENTID   =    '7e2f3589-4b38-4b1c-a321-c9251de00ef2';\r\n    _this.REDIRECT   =    document.URL;//'http%3A%2F%2Flocalhost%3A8080%2Fexample%2Findex%2Ehtml'\r\n    _this.TYPE       =    'code';\r\n\r\n    _this.TOKENEND   =    'https://login.microsoftonline.com/3fa4042c-7c4d-4382-aba8-fc8ec61103a4/oauth2/token';\r\n    _this.AUTHEND    =    'https://login.microsoftonline.com/3fa4042c-7c4d-4382-aba8-fc8ec61103a4/oauth2/authorize?';\r\n\r\n    _this.URL        =    _this.AUTHEND + 'response_type=' + _this.TYPE + '&client_id=' +\r\n    _this.CLIENTID ;//+ '&redirect_uri=' + _this.REDIRECT;\r\n  }\r\n\r\n}\r\n\r\nexport default OpenIdLib;\r\n",
    "static": true,
    "longname": "src/identity/OpenIdLib.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 240,
    "kind": "class",
    "name": "GoogleInfo",
    "memberof": "src/identity/OpenIdLib.js",
    "static": true,
    "longname": "src/identity/OpenIdLib.js~GoogleInfo",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/identity/OpenIdLib.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 241,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/OpenIdLib.js~GoogleInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~GoogleInfo#constructor",
    "access": null,
    "description": null,
    "lineNumber": 202,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 242,
    "kind": "class",
    "name": "FacebookInfo",
    "memberof": "src/identity/OpenIdLib.js",
    "static": true,
    "longname": "src/identity/OpenIdLib.js~FacebookInfo",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/identity/OpenIdLib.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 243,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/OpenIdLib.js~FacebookInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~FacebookInfo#constructor",
    "access": null,
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 244,
    "kind": "class",
    "name": "MicrosoftInfo",
    "memberof": "src/identity/OpenIdLib.js",
    "static": true,
    "longname": "src/identity/OpenIdLib.js~MicrosoftInfo",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/identity/OpenIdLib.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 232,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 245,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/OpenIdLib.js~MicrosoftInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~MicrosoftInfo#constructor",
    "access": null,
    "description": null,
    "lineNumber": 233,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 246,
    "kind": "class",
    "name": "OpenIdLib",
    "memberof": "src/identity/OpenIdLib.js",
    "static": true,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/identity/OpenIdLib.js",
    "importStyle": "OpenIdLib",
    "description": " class to facilitate the operations with the openID connect, through several Identity Providers",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 247,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/OpenIdLib.js~OpenIdLib",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib#constructor",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identityProvider",
        "types": [
          "*"
        ]
      },
      {
        "name": "clientID",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "openPopup",
    "memberof": "src/identity/OpenIdLib.js~OpenIdLib",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib#openPopup",
    "access": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "validateToken",
    "memberof": "src/identity/OpenIdLib.js~OpenIdLib",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib#validateToken",
    "access": null,
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "token",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "getInfoToken",
    "memberof": "src/identity/OpenIdLib.js~OpenIdLib",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib#getInfoToken",
    "access": null,
    "description": null,
    "lineNumber": 165,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "token",
        "types": [
          "*"
        ]
      },
      {
        "name": "tokenID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 251,
    "kind": "file",
    "name": "src/minibus.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\nimport MiniBus from './bus/MiniBus';\r\nexport default MiniBus;\r\n",
    "static": true,
    "longname": "src/minibus.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 252,
    "kind": "file",
    "name": "src/policy/ActionsService.js",
    "content": "class ActionsService {\r\n\r\n  constructor(context) {\r\n    this.context = context;\r\n  }\r\n\r\n  enforcePolicies(message, isIncomingMessage) {\r\n    let _this = this;\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let policies = _this.context.getPolicies(message, isIncomingMessage);\r\n\r\n      if (policies !== undefined) {\r\n        if (policies.serviceProviderPolicy !== undefined) {\r\n          policies.serviceProviderPolicy.enforceActions(_this.context, message).then(messages => {\r\n            resolve(messages);\r\n          }, (error) => {\r\n            reject(error);\r\n          });\r\n        } else {\r\n          if (policies.userPolicy !== undefined) {\r\n            policies.userPolicy.enforceActions(_this.context, message).then(messages => {\r\n              resolve(messages);\r\n            }, (error) => {\r\n              reject(error);\r\n            });\r\n          } else {\r\n            resolve([message]);\r\n          }\r\n        }\r\n      } else {\r\n        resolve([message]);\r\n      }\r\n    });\r\n  }\r\n\r\n  forwardToID(message, email) {\r\n    let _this = this;\r\n    if (!_this.context.runtimeRegistry) throw new Error('forward message to given ID is unsupported in this environment');\r\n\r\n    return new Promise((resolve, reject) => {\r\n      if (_this.context.runtimeRegistry.hypertiesList[0].hypertyURL === message.to) {\r\n        let splitTo = (message.to).split('://');\r\n        if (splitTo[0] !== 'runtime') {\r\n          _this.context.runtimeRegistry.discoverHypertyPerUser(email).then(result => {\r\n            message.to = result.hypertyURL;\r\n            message.body.via = undefined;\r\n            resolve(message);\r\n            _this.context.runtimeRegistry._messageBus.postMessage(message);\r\n          }, (error) => {\r\n            reject(error);\r\n          });\r\n        } else {\r\n          resolve(message);\r\n        }\r\n      } else {\r\n        resolve(message);\r\n      }\r\n    });\r\n  }\r\n\r\n  forwardToHyperty(message, hypertyURL) {\r\n    let _this = this;\r\n    if (!_this.context.runtimeRegistry) throw new Error('forward message to given ID is unsupported in this environment');\r\n\r\n    return new Promise((resolve) => {\r\n      if (_this.context.runtimeRegistry.hypertiesList[0].hypertyURL === message.to) {\r\n        let splitTo = (message.to).split('://');\r\n        if (splitTo[0] !== 'runtime') {\r\n          message.to = hypertyURL;\r\n          message.body.via = undefined;\r\n          resolve(message);\r\n          _this.context.runtimeRegistry._messageBus.postMessage(message);\r\n        } else {\r\n          resolve(message);\r\n        }\r\n      } else {\r\n        resolve(message);\r\n      }\r\n    });\r\n  }\r\n\r\n  sendAutomaticMessage(message, text) {\r\n    let _this = this;\r\n    return new Promise((resolve) => {\r\n      let automaticMessage = {\r\n        from: message.to,\r\n        to: message.from,\r\n        body: {\r\n          value: text\r\n        },\r\n        type: message.type\r\n      };\r\n      resolve(message);\r\n      _this.context.runtimeRegistry._messageBus.postMessage(automaticMessage);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default ActionsService;\r\n",
    "static": true,
    "longname": "src/policy/ActionsService.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 253,
    "kind": "class",
    "name": "ActionsService",
    "memberof": "src/policy/ActionsService.js",
    "static": true,
    "longname": "src/policy/ActionsService.js~ActionsService",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/ActionsService.js",
    "importStyle": "ActionsService",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 254,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/ActionsService.js~ActionsService",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ActionsService.js~ActionsService#constructor",
    "access": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "context",
    "memberof": "src/policy/ActionsService.js~ActionsService",
    "static": false,
    "longname": "src/policy/ActionsService.js~ActionsService#context",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "enforcePolicies",
    "memberof": "src/policy/ActionsService.js~ActionsService",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ActionsService.js~ActionsService#enforcePolicies",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "isIncomingMessage",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "forwardToID",
    "memberof": "src/policy/ActionsService.js~ActionsService",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ActionsService.js~ActionsService#forwardToID",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "email",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "forwardToHyperty",
    "memberof": "src/policy/ActionsService.js~ActionsService",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ActionsService.js~ActionsService#forwardToHyperty",
    "access": null,
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "hypertyURL",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "method",
    "name": "sendAutomaticMessage",
    "memberof": "src/policy/ActionsService.js~ActionsService",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ActionsService.js~ActionsService#sendAutomaticMessage",
    "access": null,
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "file",
    "name": "src/policy/CombiningAlgorithm.js",
    "content": "class CombiningAlgorithm {\r\n\r\n}\r\n\r\nexport default CombiningAlgorithm;\r\n",
    "static": true,
    "longname": "src/policy/CombiningAlgorithm.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 261,
    "kind": "class",
    "name": "CombiningAlgorithm",
    "memberof": "src/policy/CombiningAlgorithm.js",
    "static": true,
    "longname": "src/policy/CombiningAlgorithm.js~CombiningAlgorithm",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/CombiningAlgorithm.js",
    "importStyle": "CombiningAlgorithm",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 262,
    "kind": "file",
    "name": "src/policy/combiningAlgorithms/AllowOverrides.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\n/**\r\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\r\n* @classdesc Class to combine the authorization decisions that result from rules evaluation.\r\n*/\r\nclass AllowOverrides {\r\n\r\n  /**\r\n  * Given an array of individual authorization decisions, prioritizes a positive one.\r\n  * @param    {boolean[]}   decisions\r\n  * @returns  {boolean}\r\n  */\r\n  combine(decisions) {\r\n    if (decisions.indexOf(true) !== -1) {\r\n      return true;\r\n    } else {\r\n      if (decisions.indexOf(false) !== -1) {\r\n        return false;\r\n      } else {\r\n        return 'Not Applicable';\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default AllowOverrides;\r\n",
    "static": true,
    "longname": "src/policy/combiningAlgorithms/AllowOverrides.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 263,
    "kind": "class",
    "name": "AllowOverrides",
    "memberof": "src/policy/combiningAlgorithms/AllowOverrides.js",
    "static": true,
    "longname": "src/policy/combiningAlgorithms/AllowOverrides.js~AllowOverrides",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/combiningAlgorithms/AllowOverrides.js",
    "importStyle": "AllowOverrides",
    "description": "",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>"
      },
      {
        "tagName": "@classdesc",
        "tagValue": "Class to combine the authorization decisions that result from rules evaluation."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "combine",
    "memberof": "src/policy/combiningAlgorithms/AllowOverrides.js~AllowOverrides",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/combiningAlgorithms/AllowOverrides.js~AllowOverrides#combine",
    "access": null,
    "description": "Given an array of individual authorization decisions, prioritizes a positive one.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": false,
        "name": "decisions",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 265,
    "kind": "file",
    "name": "src/policy/combiningAlgorithms/BlockOverrides.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\n/**\r\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\r\n* @classdesc Class to combine the authorization decisions that result from rules evaluation.\r\n*/\r\nclass BlockOverrides {\r\n\r\n  /**\r\n  * Given an array of individual authorisation decisions, prioritises a negative one.\r\n  * @param    {boolean[]}   decisions\r\n  * @returns  {boolean}\r\n  */\r\n  combine(decisions) {\r\n    if (decisions.indexOf(false) !== -1) {\r\n      return false;\r\n    } else {\r\n      if (decisions.indexOf(true) !== -1) {\r\n        return true;\r\n      } else {\r\n        return 'Not Applicable';\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default BlockOverrides;\r\n",
    "static": true,
    "longname": "src/policy/combiningAlgorithms/BlockOverrides.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 266,
    "kind": "class",
    "name": "BlockOverrides",
    "memberof": "src/policy/combiningAlgorithms/BlockOverrides.js",
    "static": true,
    "longname": "src/policy/combiningAlgorithms/BlockOverrides.js~BlockOverrides",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/combiningAlgorithms/BlockOverrides.js",
    "importStyle": "BlockOverrides",
    "description": "",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>"
      },
      {
        "tagName": "@classdesc",
        "tagValue": "Class to combine the authorization decisions that result from rules evaluation."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "combine",
    "memberof": "src/policy/combiningAlgorithms/BlockOverrides.js~BlockOverrides",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/combiningAlgorithms/BlockOverrides.js~BlockOverrides#combine",
    "access": null,
    "description": "Given an array of individual authorisation decisions, prioritises a negative one.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": false,
        "name": "decisions",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 268,
    "kind": "file",
    "name": "src/policy/combiningAlgorithms/FirstApplicable.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\n/**\r\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\r\n* @classdesc Class to combine the authorization decisions that result from rules evaluation.\r\n*/\r\nclass FirstApplicable {\r\n\r\n  /**\r\n  * Given an array of individual authorisation decisions, returns the first one different from 'Not Applicable', either positive or negative.\r\n  * @param    {boolean[]}     decisions\r\n  * @returns  {boolean}\r\n  */\r\n  combine(decisions) {\r\n    for (let i in decisions) {\r\n      if (decisions[i] !== 'Not Applicable') {\r\n        return decisions[i];\r\n      }\r\n    }\r\n    return 'Not Applicable';\r\n  }\r\n\r\n}\r\n\r\nexport default FirstApplicable;\r\n",
    "static": true,
    "longname": "src/policy/combiningAlgorithms/FirstApplicable.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 269,
    "kind": "class",
    "name": "FirstApplicable",
    "memberof": "src/policy/combiningAlgorithms/FirstApplicable.js",
    "static": true,
    "longname": "src/policy/combiningAlgorithms/FirstApplicable.js~FirstApplicable",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/combiningAlgorithms/FirstApplicable.js",
    "importStyle": "FirstApplicable",
    "description": "",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>"
      },
      {
        "tagName": "@classdesc",
        "tagValue": "Class to combine the authorization decisions that result from rules evaluation."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "combine",
    "memberof": "src/policy/combiningAlgorithms/FirstApplicable.js~FirstApplicable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/combiningAlgorithms/FirstApplicable.js~FirstApplicable#combine",
    "access": null,
    "description": "Given an array of individual authorisation decisions, returns the first one different from 'Not Applicable', either positive or negative.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": false,
        "name": "decisions",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 271,
    "kind": "file",
    "name": "src/policy/conditions/AdvancedCondition.js",
    "content": "import Condition from './Condition';\r\nimport Operators from '../Operators';\r\nimport SubscriptionCondition from './SubscriptionCondition';\r\n\r\nclass AdvancedCondition {\r\n\r\n  constructor(condition) {\r\n    this.operators = new Operators();\r\n    if (condition.operators !== undefined) {\r\n      condition = condition.condition;\r\n    }\r\n    condition = this.buildCondition(condition);\r\n    this.condition = condition;\r\n  }\r\n\r\n  buildCondition(condition) {\r\n    if (Array.isArray(condition[1])) {\r\n      condition[1] = this.buildCondition(condition[1]);\r\n    } else {\r\n      if (condition[1].attribute === 'subscription') {\r\n        condition[1] = new SubscriptionCondition(condition[1].attribute, condition[1].operator, condition[1].params);\r\n      } else {\r\n        condition[1] = new Condition(condition[1].attribute, condition[1].operator, condition[1].params);\r\n      }\r\n    }\r\n\r\n    if (condition[2] !== undefined) {\r\n      if (Array.isArray(condition[2])) {\r\n        condition[2] = this.buildCondition(condition[2]);\r\n      } else {\r\n        if (condition[2].attribute === 'subscription') {\r\n          condition[2] = new SubscriptionCondition(condition[2].attribute, condition[2].operator, condition[2].params);\r\n        } else {\r\n          condition[2] = new Condition(condition[2].attribute, condition[2].operator, condition[2].params);\r\n        }\r\n      }\r\n    }\r\n    return condition;\r\n  }\r\n\r\n  isApplicable(context, message, scope, target, operator, left, right) {\r\n    if (!operator) {\r\n      operator = this.condition[0];\r\n      left = this.condition[1];\r\n      right = this.condition[2];\r\n    }\r\n\r\n    while (!(left instanceof Condition) & !(left instanceof SubscriptionCondition) & (typeof left !== 'boolean')) {\r\n      left = this.isApplicable(context, message, scope, target, left[0], left[1], left[2]);\r\n    }\r\n    if (right !== undefined) {\r\n      while (!(right instanceof Condition) & !(right instanceof SubscriptionCondition) & (typeof right !== 'boolean')) {\r\n        right = this.isApplicable(context, message, scope, target, right[0], right[1], right[2]);\r\n      }\r\n    }\r\n\r\n    let resultLeft = (typeof left === 'boolean') ? left : left.isApplicable(context, message, scope, target);\r\n    let resultRight;\r\n    if (right !== undefined) {\r\n      resultRight = (typeof right === 'boolean') ? right : right.isApplicable(context, message, scope, target);\r\n    }\r\n    return this.operators[operator]([resultLeft, resultRight]);\r\n  }\r\n\r\n}\r\n\r\nexport default AdvancedCondition;\r\n",
    "static": true,
    "longname": "src/policy/conditions/AdvancedCondition.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 272,
    "kind": "class",
    "name": "AdvancedCondition",
    "memberof": "src/policy/conditions/AdvancedCondition.js",
    "static": true,
    "longname": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/conditions/AdvancedCondition.js",
    "importStyle": "AdvancedCondition",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 273,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition#constructor",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "condition",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 274,
    "kind": "member",
    "name": "operators",
    "memberof": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition",
    "static": false,
    "longname": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition#operators",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "member",
    "name": "condition",
    "memberof": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition",
    "static": false,
    "longname": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition#condition",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "buildCondition",
    "memberof": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition#buildCondition",
    "access": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "condition",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "isApplicable",
    "memberof": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/conditions/AdvancedCondition.js~AdvancedCondition#isApplicable",
    "access": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "scope",
        "types": [
          "*"
        ]
      },
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "operator",
        "types": [
          "*"
        ]
      },
      {
        "name": "left",
        "types": [
          "*"
        ]
      },
      {
        "name": "right",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 278,
    "kind": "file",
    "name": "src/policy/conditions/Condition.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\nimport Operators from '../Operators';\r\n\r\n/**\r\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\r\n* @classdesc Class to represent a condition and evaluate its applicability.\r\n*/\r\nclass Condition {\r\n\r\n  /**\r\n  * Creates a new Condition.\r\n  * @class\r\n  * @param  {string}  attribute\r\n  * @param  {string}  operator\r\n  * @param  {*}       params\r\n  */\r\n  constructor(attribute, operator, params) {\r\n    this.attribute = attribute;\r\n    this.operator = operator;\r\n    this.params = params;\r\n    this.operators = new Operators();\r\n  }\r\n\r\n  /**\r\n  * Verifies if the condition is applicable to the message. First, the system value that corresponds to the attribute is retrieved; then, that value is compared with the parameter specified in the condition by executing the operator implementation. If the operator is 'in' and the name of a group is given, then the array holding the members of the group is retrieved before the comparison.\r\n  * @param  {Object}    context   environment where the Policy Engine is being used\r\n  * @param  {Object}    message\r\n  */\r\n  isApplicable(context, message) {\r\n    context[this.attribute] = { message: message };\r\n    let value = context[this.attribute];\r\n    let tempParam;\r\n\r\n    if (this.operator === 'in') {\r\n      if (!(Array.isArray(this.params))) {\r\n        tempParam = context.getGroup(this.params, message.to);\r\n        return this.operators[this.operator]([tempParam, value]);\r\n      }\r\n    }\r\n\r\n    return this.operators[this.operator]([this.params, value]);\r\n  }\r\n\r\n}\r\n\r\nexport default Condition;\r\n",
    "static": true,
    "longname": "src/policy/conditions/Condition.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 279,
    "kind": "class",
    "name": "Condition",
    "memberof": "src/policy/conditions/Condition.js",
    "static": true,
    "longname": "src/policy/conditions/Condition.js~Condition",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/conditions/Condition.js",
    "importStyle": "Condition",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>"
      },
      {
        "tagName": "@classdesc",
        "tagValue": "Class to represent a condition and evaluate its applicability."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 280,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/conditions/Condition.js~Condition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/conditions/Condition.js~Condition#constructor",
    "access": null,
    "description": "Creates a new Condition.",
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attribute",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "operator",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 281,
    "kind": "member",
    "name": "attribute",
    "memberof": "src/policy/conditions/Condition.js~Condition",
    "static": false,
    "longname": "src/policy/conditions/Condition.js~Condition#attribute",
    "access": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "member",
    "name": "operator",
    "memberof": "src/policy/conditions/Condition.js~Condition",
    "static": false,
    "longname": "src/policy/conditions/Condition.js~Condition#operator",
    "access": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "member",
    "name": "params",
    "memberof": "src/policy/conditions/Condition.js~Condition",
    "static": false,
    "longname": "src/policy/conditions/Condition.js~Condition#params",
    "access": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "member",
    "name": "operators",
    "memberof": "src/policy/conditions/Condition.js~Condition",
    "static": false,
    "longname": "src/policy/conditions/Condition.js~Condition#operators",
    "access": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "method",
    "name": "isApplicable",
    "memberof": "src/policy/conditions/Condition.js~Condition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/conditions/Condition.js~Condition#isApplicable",
    "access": null,
    "description": "Verifies if the condition is applicable to the message. First, the system value that corresponds to the attribute is retrieved; then, that value is compared with the parameter specified in the condition by executing the operator implementation. If the operator is 'in' and the name of a group is given, then the array holding the members of the group is retrieved before the comparison.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": "environment where the Policy Engine is being used"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "file",
    "name": "src/policy/conditions/SubscriptionCondition.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\nimport Condition from './Condition';\r\n\r\n/**\r\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\r\n* @classdesc Class to represent a subscription condition and evaluate its applicability.\r\n*/\r\nclass SubscriptionCondition extends Condition {\r\n\r\n  /**\r\n  * Creates a new SubscriptionCondition.\r\n  * @class\r\n  * @param  {string}  attribute\r\n  * @param  {string}  operator\r\n  * @param  {*}       params\r\n  */\r\n  constructor(attribute, operator, params) {\r\n    super(attribute, operator, params);\r\n  }\r\n\r\n  /**\r\n  * Verifies if the subscription condition is applicable to the message. First, verifies if the message is of the subscription type; second, verifies if the message is from a remote runtime to guarantee that the subscription is being validated in the destination runtime; third, verifies if the subscription preference is met.\r\n  * @param  {Object}    context   environment where the Policy Engine is being used\r\n  * @param  {Object}    message\r\n  */\r\n  isApplicable(context, message) {\r\n    let isSubscription = message.type === 'subscribe';\r\n    let isFromRemoteSM = context.isFromRemoteSM(message.from);\r\n    if (isSubscription & isFromRemoteSM) {\r\n      return super.isApplicable(context, message);\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default SubscriptionCondition;\r\n",
    "static": true,
    "longname": "src/policy/conditions/SubscriptionCondition.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 287,
    "kind": "class",
    "name": "SubscriptionCondition",
    "memberof": "src/policy/conditions/SubscriptionCondition.js",
    "static": true,
    "longname": "src/policy/conditions/SubscriptionCondition.js~SubscriptionCondition",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/conditions/SubscriptionCondition.js",
    "importStyle": "SubscriptionCondition",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>"
      },
      {
        "tagName": "@classdesc",
        "tagValue": "Class to represent a subscription condition and evaluate its applicability."
      }
    ],
    "interface": false,
    "extends": [
      "src/policy/conditions/Condition.js~Condition"
    ]
  },
  {
    "__docId__": 288,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/conditions/SubscriptionCondition.js~SubscriptionCondition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/conditions/SubscriptionCondition.js~SubscriptionCondition#constructor",
    "access": null,
    "description": "Creates a new SubscriptionCondition.",
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attribute",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "operator",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "isApplicable",
    "memberof": "src/policy/conditions/SubscriptionCondition.js~SubscriptionCondition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/conditions/SubscriptionCondition.js~SubscriptionCondition#isApplicable",
    "access": null,
    "description": "Verifies if the subscription condition is applicable to the message. First, verifies if the message is of the subscription type; second, verifies if the message is from a remote runtime to guarantee that the subscription is being validated in the destination runtime; third, verifies if the subscription preference is met.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": "environment where the Policy Engine is being used"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 290,
    "kind": "file",
    "name": "src/policy/context/RuntimeCoreCtx.js",
    "content": "import AllowOverrides from '../combiningAlgorithms/AllowOverrides';\nimport BlockOverrides from '../combiningAlgorithms/BlockOverrides';\nimport {divideURL, getUserEmailFromURL, isDataObjectURL} from '../../utils/utils';\nimport FirstApplicable from '../combiningAlgorithms/FirstApplicable';\nimport ReThinkCtx from '../ReThinkCtx';\n\nclass RuntimeCoreCtx extends ReThinkCtx {\n\n  constructor(idModule, runtimeRegistry, storageManager, runtimeCapabilities) {\n    super();\n    this.idModule = idModule;\n    this.runtimeRegistry = runtimeRegistry;\n    this.activeUserPolicy = undefined;\n    this.serviceProviderPolicy = {};\n    this.userPolicies = {};\n    this.storageManager = storageManager;\n    this.runtimeCapabilities = runtimeCapabilities;\n  }\n\n  get subscription() {\n    return this._subscription;\n  }\n\n  set subscription(params) {\n    this._subscription = params.message.body.subscriber;\n  }\n\n  loadConfigurations() {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      _this.storageManager.get('rethink:activePolicy').then((value) => {\n        _this.activeUserPolicy = value;\n\n        return _this.storageManager.get('rethink:groups');\n      }).then((groupInfo) => {\n        let groups = groupInfo;\n        _this.groups = (groups === undefined) ? {} : groups;\n\n        return _this.storageManager.get('rethink:spPolicies');\n      }).then((policiesInfo) => {\n        let spPolicies = policiesInfo;\n        _this.serviceProviderPolicy = (spPolicies === undefined) ? {} : spPolicies;\n\n        _this._loadUserPolicies().then(() => {\n          resolve();\n        });\n      });\n    });\n  }\n\n  prepareForEvaluation(message, isIncoming) {\n    return new Promise((resolve, reject) => {\n\n      let _this = this;\n      if (isIncoming) {\n        if (_this._isToCypherModule(message)) {\n          _this.idModule.decryptMessage(message).then(function(message) {\n            /*if (message.type === 'update') {\n              _this._isValidUpdate(message).then(message => {*/\n            resolve(message);\n          }, (error) => {\n            reject(error);\n            /*});\n            } else {\n              resolve(message);\n            }*/\n          });\n        } else {\n          resolve(message);\n        }\n      } else {\n        console.log('ON prepareForEvaluation', message);\n        if (_this._isToSetID(message)) {\n          _this._getIdentity(message).then(identity => {\n            message.body.identity = identity;\n            resolve(message);\n          }, (error) => {\n            reject(error);\n          });\n        } else {\n          resolve(message);\n        }\n      }\n\n    });\n  }\n\n  getPolicies(message, isIncomingMessage) {\n    let policies = {};\n\n    if (this.activeUserPolicy !== undefined) {\n      policies.userPolicy = this.userPolicies[this.activeUserPolicy];\n    }\n\n    policies.serviceProviderPolicy = this.getServiceProviderPolicy(message, isIncomingMessage);\n\n    return policies;\n  }\n\n  _isValidUpdate(message) {\n    let _this = this;\n    return new Promise((resolve, reject) => {\n      if (message.from.split('://').length > 1) {\n        _this.idModule._getHypertyFromDataObject(message.from).then(hypertyURL => {\n          if (hypertyURL === message.body.source) {\n            resolve(message);\n          } else {\n            reject('The source of the message is not valid.');\n          }\n        }, (error) => {\n          reject(error);\n        });\n      } else {\n        resolve(message);\n      }\n    });\n  }\n\n  prepareToForward(message, isIncoming, result) {\n    let _this = this;\n    return new Promise((resolve, reject) => {\n\n      // TODO remove this validation. When the Nodejs auth was completed this should work like browser;\n      this.runtimeCapabilities.isAvailable('node').then((result) => {\n\n        if (result) {\n          return resolve(message);\n        }\n      });\n\n      if (isIncoming & result) {\n        let isSubscription = message.type === 'subscribe';\n        let isFromRemoteSM = _this.isFromRemoteSM(message.from);\n        if (isSubscription & isFromRemoteSM) {\n          _this.doMutualAuthentication(message).then(() => {\n            resolve(message);\n          }, (error) => {\n            reject(error);\n          });\n        } else {\n          resolve(message);\n        }\n      } else {\n        if (_this._isToCypherModule(message)) {\n          _this.idModule.encryptMessage(message).then((message) => {\n            resolve(message);\n          }, (error) => {\n            reject(error);\n          });\n        } else {\n          resolve(message);\n        }\n      }\n    });\n  }\n\n  doMutualAuthentication(message) {\n    let _this = this;\n    return new Promise(function(resolve, reject) {\n      let to = message.to.split('/');\n      let subsIndex = to.indexOf('subscription');\n      let isDataObjectSubscription = subsIndex !== -1;\n      let isFromRemoteSM = _this.isFromRemoteSM(message.from);\n      if (isDataObjectSubscription & isFromRemoteSM) {\n        to.pop();\n        let dataObjectURL = to[0] + '//' + to[2] + '/' + to[3];\n        _this.idModule.doMutualAuthentication(dataObjectURL, message.body.subscriber).then(() => {\n          _this.runtimeRegistry.registerSubscriber(dataObjectURL, message.body.subscriber);\n          resolve();\n        }, (error) => {\n          reject(error);\n        });\n      }\n    });\n  }\n\n  getMyEmails() {\n    let identities = this.idModule.getIdentities();\n    let emails = [];\n\n    for (let i in identities) {\n      emails.push(getUserEmailFromURL(identities[i].identity));\n    }\n\n    return emails;\n  }\n\n  getMyHyperties() {\n    let hyperties = this.runtimeRegistry.hypertiesList;\n    let hypertiesNames = [];\n\n    for (let i in hyperties) {\n      let hypertyName = hyperties[i].objectName;\n      if (hypertiesNames.indexOf(hypertyName) === -1) {\n        hypertiesNames.push(hypertyName);\n      }\n    }\n\n    return hypertiesNames;\n  }\n\n  getServiceProviderPolicy(message, isIncoming) {\n    let policy;\n\n    if (isIncoming) {\n      let toHyperty = this.runtimeRegistry.getHypertyName(message.to);\n      policy = this.serviceProviderPolicy[toHyperty];\n    } else {\n      let fromHyperty = this.runtimeRegistry.getHypertyName(message.from);\n      policy = this.serviceProviderPolicy[fromHyperty];\n    }\n    return policy;\n  }\n\n  isFromRemoteSM(from) {\n    let splitFrom = from.split('://');\n    return splitFrom[0] === 'runtime' && from !== this.runtimeRegistry.runtimeURL + '/sm';\n  }\n\n  isLocal(url) {\n    return this.runtimeRegistry.isLocal(url);\n  }\n\n  isInterworkingProtoStub(url) {\n    return this.runtimeRegistry.isInterworkingProtoStub(url);\n  }\n\n  _isToSetID(message) {\n    let schemasToIgnore = ['domain-idp', 'runtime', 'domain'];\n    let splitFrom = (message.from).split('://');\n    let fromSchema = splitFrom[0];\n\n    let _from = message.from;\n\n    if (message.body && message.body.hasOwnProperty('source'))\n      _from = message.body.source;\n\n    // Signalling Messages between P2P Stubs don't have Identities. FFS\n\n    if (_from.includes('/p2prequester/') || _from.includes('/p2phandler/'))\n      return false;\n\n    return schemasToIgnore.indexOf(fromSchema) === -1;\n  }\n\n  getURL(url) {\n    let splitURL = url.split('/');\n    return splitURL[0] + '//' + splitURL[2] + '/' + splitURL[3];\n  }\n\n  _getIdentity(message) {\n    console.log('[Policy.RuntimeCoreCtx.getIdentity] ', message);\n\n    if (message.body.source !== undefined) {\n      return this.idModule.getToken(message.body.source, message.to);\n    } else\n\n/*    if (message.type === 'update') {\n      return this.idModule.getToken(message.body.source);\n    }\n\n    if (message.type === 'response' && message.body.source !== undefined) {\n      return this.idModule.getToken(message.body.source);\n    }*/\n\n//    if (divideURL(message.from).type === 'hyperty') {\n      return this.idModule.getToken(message.from, message.to);\n/*    } else {\n      return this.idModule.getToken(this.getURL(message.from));\n    }*/\n  }\n\n  /**\n  * Identifies the messages to be forwarded to the Identity Module for\n  * encryption/decryption and integrity validation.\n  * @param {Message}    message\n  * @returns {boolean}  returns true if the message requires encryption/decryption\n  *                     or if its type equals 'handshake'; false otherwise\n  */\n  _isToCypherModule(message) {\n    let isCreate = message.type === 'create';\n    let isFromHyperty = divideURL(message.from).type === 'hyperty';\n    let isToHyperty = divideURL(message.to).type === 'hyperty';\n    let isToDataObject = isDataObjectURL(message.to);\n\n    // todo: return false for messages coming from interworking stubs.\n    // Get descriptor from runtime catalogue and check interworking field.\n\n    return (isCreate && isFromHyperty && isToHyperty) || (isCreate && isFromHyperty && isToDataObject) || message.type === 'handshake' || message.type === 'update';\n  }\n\n  /**\n  * Creates a group with the given name.\n  * @param  {String}  groupName\n  */\n  _loadUserPolicies() {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      _this.storageManager.get('rethink:userPolicies').then((value) => {\n        let policies = value;\n        if (policies !== undefined) {\n          for (let i in policies) {\n            this.pep.addPolicy('USER', i, policies[i]);\n          }\n        }\n        resolve();\n      });\n    });\n\n  }\n\n  _getLastComponentOfURL(url) {\n    let split = url.split('/');\n    return split[split.length - 1];\n  }\n\n  _getPoliciesJSON(policies) {\n    for (let i in policies) {\n      let combiningAlgorithm = policies[i].combiningAlgorithm;\n      if (combiningAlgorithm instanceof BlockOverrides) {\n        policies[i].combiningAlgorithm = 'blockOverrides';\n      } else {\n        if (combiningAlgorithm instanceof AllowOverrides) {\n          policies[i].combiningAlgorithm = 'allowOverrides';\n        } else {\n          if (combiningAlgorithm instanceof FirstApplicable) {\n            policies[i].combiningAlgorithm = 'firstApplicable';\n          } else {\n            policies[i].combiningAlgorithm = undefined;\n          }\n        }\n      }\n    }\n\n    return policies;\n  }\n\n  saveActivePolicy() {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n      _this.storageManager.set('rethink:activePolicy', 0, this.activeUserPolicy).then(() => {\n        resolve();\n      });\n    });\n  }\n\n  saveGroups() {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n      _this.storageManager.set('rethink:groups', 0, this.groups).then(() => {\n        resolve();\n      });\n    });\n  }\n\n  savePolicies(source, policy, key) {\n    let policiesJson;\n\n    switch (source) {\n      case 'USER':\n        policiesJson = JSON.stringify(this.userPolicies);\n        policiesJson = this._getPoliciesJSON(JSON.parse(policiesJson));\n        this.storageManager.set('rethink:userPolicies', 0, policiesJson);\n        break;\n      case 'SERVICE_PROVIDER':\n        if (policy !== undefined & key !== undefined) {\n          this.serviceProviderPolicy[key] = policy;\n        }\n        policiesJson = JSON.stringify(this.serviceProviderPolicy);\n        policiesJson = this._getPoliciesJSON(JSON.parse(policiesJson));\n        this.storageManager.set('rethink:spPolicies', 0, policiesJson);\n        break;\n      default:\n        throw Error('Unknown policy source: ' + source);\n    }\n  }\n\n  getGroupsNames() {\n    let myGroups = this.groups;\n    let groupsNames = [];\n    if (myGroups !== undefined) {\n      for (let groupName in myGroups) {\n        groupsNames.push(groupName);\n      }\n    }\n    return groupsNames;\n  }\n\n  getGroup(groupName, destination) {\n    let members = [];\n\n    if (groupName === 'preauthorised') {\n      let dataObjectURL = destination.split('/');\n      dataObjectURL.pop();\n      dataObjectURL = dataObjectURL[0] + '//' + dataObjectURL[2];\n      members = this.runtimeRegistry.getPreAuthSubscribers(dataObjectURL);\n    } else {\n      if (this.groups[groupName] !== undefined) {\n        members = this.groups[groupName];\n      }\n    }\n\n    return members;\n  }\n\n  /**\n  * Creates a group with the given name.\n  * @param  {String}  groupName\n  */\n  createGroup(groupName) {\n    this.groups[groupName] = [];\n    this.saveGroups();\n  }\n\n  deleteGroup(groupName) {\n    delete this.groups[groupName];\n    this.saveGroups();\n  }\n\n  /**\n  * Adds the given user email to the group with the given name.\n  * @param  {String}  userEmail\n  * @param  {String}  groupName\n  */\n  addToGroup(groupName, userEmail) {\n    let myGroups = this.groups;\n    if (myGroups[groupName] !== undefined) {\n      if (myGroups[groupName].indexOf(userEmail) === -1) {\n        myGroups[groupName].push(userEmail);\n        this.saveGroups();\n      }\n    } else {\n      throw Error('Group \"' + groupName + '\" does not exist!');\n    }\n  }\n\n  removeFromGroup(groupName, userEmail) {\n    let group = this.groups[groupName];\n\n    group.splice(group.indexOf(userEmail), 1);\n    this.saveGroups();\n  }\n\n}\n\nexport default RuntimeCoreCtx;\n",
    "static": true,
    "longname": "src/policy/context/RuntimeCoreCtx.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 291,
    "kind": "class",
    "name": "RuntimeCoreCtx",
    "memberof": "src/policy/context/RuntimeCoreCtx.js",
    "static": true,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/context/RuntimeCoreCtx.js",
    "importStyle": "RuntimeCoreCtx",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "src/policy/ReThinkCtx.js~ReThinkCtx"
    ]
  },
  {
    "__docId__": 292,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#constructor",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "idModule",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtimeRegistry",
        "types": [
          "*"
        ]
      },
      {
        "name": "storageManager",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtimeCapabilities",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 293,
    "kind": "member",
    "name": "idModule",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#idModule",
    "access": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "member",
    "name": "runtimeRegistry",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#runtimeRegistry",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "member",
    "name": "activeUserPolicy",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#activeUserPolicy",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "member",
    "name": "serviceProviderPolicy",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#serviceProviderPolicy",
    "access": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "member",
    "name": "userPolicies",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#userPolicies",
    "access": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 298,
    "kind": "member",
    "name": "storageManager",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#storageManager",
    "access": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "member",
    "name": "runtimeCapabilities",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#runtimeCapabilities",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "get",
    "name": "subscription",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#subscription",
    "access": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "set",
    "name": "subscription",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#subscription",
    "access": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "member",
    "name": "_subscription",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#_subscription",
    "access": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 303,
    "kind": "method",
    "name": "loadConfigurations",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#loadConfigurations",
    "access": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 304,
    "kind": "method",
    "name": "prepareForEvaluation",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#prepareForEvaluation",
    "access": null,
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "isIncoming",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "getPolicies",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#getPolicies",
    "access": null,
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "isIncomingMessage",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "_isValidUpdate",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#_isValidUpdate",
    "access": null,
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "prepareToForward",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#prepareToForward",
    "access": null,
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "isIncoming",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "doMutualAuthentication",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#doMutualAuthentication",
    "access": null,
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "getMyEmails",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#getMyEmails",
    "access": null,
    "description": null,
    "lineNumber": 179,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "getMyHyperties",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#getMyHyperties",
    "access": null,
    "description": null,
    "lineNumber": 190,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 311,
    "kind": "method",
    "name": "getServiceProviderPolicy",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#getServiceProviderPolicy",
    "access": null,
    "description": null,
    "lineNumber": 204,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "isIncoming",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "method",
    "name": "isFromRemoteSM",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#isFromRemoteSM",
    "access": null,
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "from",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "method",
    "name": "isLocal",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#isLocal",
    "access": null,
    "description": null,
    "lineNumber": 222,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "method",
    "name": "isInterworkingProtoStub",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#isInterworkingProtoStub",
    "access": null,
    "description": null,
    "lineNumber": 226,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "method",
    "name": "_isToSetID",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#_isToSetID",
    "access": null,
    "description": null,
    "lineNumber": 230,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "getURL",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#getURL",
    "access": null,
    "description": null,
    "lineNumber": 248,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "method",
    "name": "_getIdentity",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#_getIdentity",
    "access": null,
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "_isToCypherModule",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#_isToCypherModule",
    "access": null,
    "description": "Identifies the messages to be forwarded to the Identity Module for\nencryption/decryption and integrity validation.",
    "lineNumber": 282,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}  returns true if the message requires encryption/decryption\n                    or if its type equals 'handshake'; false otherwise"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "returns true if the message requires encryption/decryption\n                    or if its type equals 'handshake'; false otherwise"
    }
  },
  {
    "__docId__": 319,
    "kind": "method",
    "name": "_loadUserPolicies",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#_loadUserPolicies",
    "access": null,
    "description": "Creates a group with the given name.",
    "lineNumber": 298,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "groupName",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 320,
    "kind": "method",
    "name": "_getLastComponentOfURL",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#_getLastComponentOfURL",
    "access": null,
    "description": null,
    "lineNumber": 316,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "_getPoliciesJSON",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#_getPoliciesJSON",
    "access": null,
    "description": null,
    "lineNumber": 321,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "policies",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "method",
    "name": "saveActivePolicy",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#saveActivePolicy",
    "access": null,
    "description": null,
    "lineNumber": 342,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "method",
    "name": "saveGroups",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#saveGroups",
    "access": null,
    "description": null,
    "lineNumber": 352,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "method",
    "name": "savePolicies",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#savePolicies",
    "access": null,
    "description": null,
    "lineNumber": 362,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      },
      {
        "name": "policy",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 325,
    "kind": "method",
    "name": "getGroupsNames",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#getGroupsNames",
    "access": null,
    "description": null,
    "lineNumber": 384,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "getGroup",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#getGroup",
    "access": null,
    "description": null,
    "lineNumber": 395,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "groupName",
        "types": [
          "*"
        ]
      },
      {
        "name": "destination",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "createGroup",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#createGroup",
    "access": null,
    "description": "Creates a group with the given name.",
    "lineNumber": 416,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "groupName",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "deleteGroup",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#deleteGroup",
    "access": null,
    "description": null,
    "lineNumber": 421,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "groupName",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 329,
    "kind": "method",
    "name": "addToGroup",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#addToGroup",
    "access": null,
    "description": "Adds the given user email to the group with the given name.",
    "lineNumber": 431,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userEmail",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "groupName",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "removeFromGroup",
    "memberof": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx#removeFromGroup",
    "access": null,
    "description": null,
    "lineNumber": 443,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "groupName",
        "types": [
          "*"
        ]
      },
      {
        "name": "userEmail",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 331,
    "kind": "file",
    "name": "src/policy/Operators.js",
    "content": "class Operators {\r\n\r\n  and(params) {\r\n    return params[0] && params[1];\r\n  }\r\n\r\n  between(params) {\r\n    let start = parseInt(params[0][0]);\r\n    let end = parseInt(params[0][1]);\r\n    let now = params[1];\r\n\r\n    if (end < start) {\r\n      now = (now < start) ? now += 2400 : now;\r\n      end += 2400;\r\n    }\r\n\r\n    return (now > start && now < end);\r\n  }\r\n\r\n  equals(params) {\r\n    return String(params[0]) === '*' || String(params[0]) === String(params[1]);\r\n  }\r\n\r\n  greaterThan(params) {\r\n    return params[1] > params[0];\r\n  }\r\n\r\n  in(params) {\r\n    return params[0].indexOf(params[1]) > -1;\r\n  }\r\n\r\n  lessThan(params) {\r\n    return params[1] < params[0];\r\n  }\r\n\r\n  not(params) {\r\n    return !params[0];\r\n  }\r\n\r\n  or(params) {\r\n    return params[0] || params[1];\r\n  }\r\n\r\n}\r\n\r\nexport default Operators;\r\n",
    "static": true,
    "longname": "src/policy/Operators.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 332,
    "kind": "class",
    "name": "Operators",
    "memberof": "src/policy/Operators.js",
    "static": true,
    "longname": "src/policy/Operators.js~Operators",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/Operators.js",
    "importStyle": "Operators",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 333,
    "kind": "method",
    "name": "and",
    "memberof": "src/policy/Operators.js~Operators",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Operators.js~Operators#and",
    "access": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "between",
    "memberof": "src/policy/Operators.js~Operators",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Operators.js~Operators#between",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 335,
    "kind": "method",
    "name": "equals",
    "memberof": "src/policy/Operators.js~Operators",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Operators.js~Operators#equals",
    "access": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 336,
    "kind": "method",
    "name": "greaterThan",
    "memberof": "src/policy/Operators.js~Operators",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Operators.js~Operators#greaterThan",
    "access": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 337,
    "kind": "method",
    "name": "in",
    "memberof": "src/policy/Operators.js~Operators",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Operators.js~Operators#in",
    "access": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 338,
    "kind": "method",
    "name": "lessThan",
    "memberof": "src/policy/Operators.js~Operators",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Operators.js~Operators#lessThan",
    "access": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "method",
    "name": "not",
    "memberof": "src/policy/Operators.js~Operators",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Operators.js~Operators#not",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 340,
    "kind": "method",
    "name": "or",
    "memberof": "src/policy/Operators.js~Operators",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Operators.js~Operators#or",
    "access": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 341,
    "kind": "file",
    "name": "src/policy/PDP.js",
    "content": "import Operators from './Operators';\r\n\r\n/**\r\n* The Policy Decision Point (PDP) decides if a message is to be authorised by checking a set of\r\n* policies. The resource to be verified is specified in the first word of the 'condition' field of\r\n* a Policy object. The implementation that verifies if the message is compliant with a policy is\r\n* specified in a hashtable to allow dynamic definition of the implementation, providing\r\n* extensibility to the Policy Engine functionalities.\r\n*/\r\nclass PDP {\r\n\r\n  constructor(context) {\r\n    this.context = context;\r\n    this.operators = new Operators();\r\n  }\r\n\r\n  evaluatePolicies(message, isIncomingMessage) {\r\n    let policies = this.context.getPolicies(message, isIncomingMessage);\r\n    let result = 'Not Applicable';\r\n    if (policies !== undefined) {\r\n      result = this.evaluatePolicy(message, policies.serviceProviderPolicy, isIncomingMessage);\r\n      if (result || result === 'Not Applicable') {\r\n        let userResult = this.evaluatePolicy(message, policies.userPolicy, isIncomingMessage);\r\n        if (userResult !== 'Not Applicable') {\r\n          result = userResult;\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  evaluatePolicy(message, policy, isIncoming) {\r\n    let result = 'Not Applicable';\r\n    if (policy) {\r\n      result = policy.evaluateRules(this.context, message, isIncoming);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n}\r\n\r\nexport default PDP;\r\n",
    "static": true,
    "longname": "src/policy/PDP.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 342,
    "kind": "class",
    "name": "PDP",
    "memberof": "src/policy/PDP.js",
    "static": true,
    "longname": "src/policy/PDP.js~PDP",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/PDP.js",
    "importStyle": "PDP",
    "description": "The Policy Decision Point (PDP) decides if a message is to be authorised by checking a set of\npolicies. The resource to be verified is specified in the first word of the 'condition' field of\na Policy object. The implementation that verifies if the message is compliant with a policy is\nspecified in a hashtable to allow dynamic definition of the implementation, providing\nextensibility to the Policy Engine functionalities.",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 343,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/PDP.js~PDP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PDP.js~PDP#constructor",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 344,
    "kind": "member",
    "name": "context",
    "memberof": "src/policy/PDP.js~PDP",
    "static": false,
    "longname": "src/policy/PDP.js~PDP#context",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "member",
    "name": "operators",
    "memberof": "src/policy/PDP.js~PDP",
    "static": false,
    "longname": "src/policy/PDP.js~PDP#operators",
    "access": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "evaluatePolicies",
    "memberof": "src/policy/PDP.js~PDP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PDP.js~PDP#evaluatePolicies",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "isIncomingMessage",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "evaluatePolicy",
    "memberof": "src/policy/PDP.js~PDP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PDP.js~PDP#evaluatePolicy",
    "access": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "policy",
        "types": [
          "*"
        ]
      },
      {
        "name": "isIncoming",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 348,
    "kind": "file",
    "name": "src/policy/PEP.js",
    "content": "import ActionsService from './ActionsService';\r\nimport PDP from './PDP';\r\nimport Policy from './Policy';\r\nimport {isHypertyURL} from '../utils/utils';\r\n\r\nclass PEP {\r\n\r\n  /**\r\n  * Creates a Policy Enforcement Point (PEP) instance\r\n  * @param    {Object}    context\r\n  */\r\n  constructor(context) {\r\n    let _this = this;\r\n\r\n    _this.pdp = new PDP(context);\r\n    _this.actionsService = new ActionsService(context);\r\n    _this.context = context;\r\n    context.pep = _this;\r\n\r\n    //TODO should be added a trigger to verify when the loadConfigurations is successfully completed\r\n    context.loadConfigurations();\r\n  }\r\n\r\n  /**\r\n  * Adds a policy to the Policy Enforcement Point (PEP). The policy can be created by the service\r\n  * provider or by the user.\r\n  * @param    {String}    source\r\n  * @param    {String}    key\r\n  * @param    {Object}    policy\r\n  */\r\n  addPolicy(source, key, policy, combiningAlgorithm) {\r\n    if (!source) throw new Error('source is not defined');\r\n    if (!key) throw new Error('key is not defined');\r\n\r\n    if (policy === undefined) {\r\n      policy = new Policy(key, [], [], combiningAlgorithm);\r\n    } else {\r\n      if (!(policy instanceof Policy)) {\r\n        policy = new Policy(policy.key, policy.rules, policy.actions, policy.combiningAlgorithm);\r\n      }\r\n    }\r\n\r\n    switch (source) {\r\n      case 'SERVICE_PROVIDER':\r\n        this.context.savePolicies(source, policy, key);\r\n        break;\r\n      case 'USER':\r\n        this.context.userPolicies[key] = policy;\r\n        this.context.savePolicies(source);\r\n        break;\r\n      default:\r\n        throw Error('Unknown policy source: ' + source);\r\n    }\r\n  }\r\n\r\n  authorise(message) {\r\n    console.log('[Policy.PEP Authorise] ', message);\r\n    console.log(message);\r\n    if (!message) throw new Error('message is not defined');\r\n    if (!message.from) throw new Error('message.from is not defined');\r\n    if (!message.to) throw new Error('message.to is not defined');\r\n    if (!message.type) throw new Error('message.type is not defined');\r\n    message.body = message.body || {};\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      message.body = message.body || {};\r\n      let _this = this;\r\n      let result;\r\n      if (_this._isToVerify(message)) {\r\n        let isIncoming = _this._isIncomingMessage(message);\r\n        _this.context.prepareForEvaluation(message, isIncoming).then(message => {\r\n          result = _this.pdp.evaluatePolicies(message, isIncoming);\r\n          if (result === 'Not Applicable') {\r\n            result = _this.context.defaultBehaviour;\r\n            message.body.auth = false;\r\n          }\r\n          _this.actionsService.enforcePolicies(message, isIncoming).then(messages => {\r\n            for (let i in messages) {\r\n              message = messages[i];\r\n              _this.context.prepareToForward(message, isIncoming, result).then(message => {\r\n                if (result) {\r\n                  message.body.auth = (message.body.auth === undefined) ? true : message.body.auth;\r\n                  resolve(message);\r\n                } else {\r\n                  let errorMessage = { body: { code: 403, description: 'Blocked by policy' }, from: message.to, to: message.from, type: 'response' };\r\n                  reject(errorMessage);\r\n                }\r\n              }, (error) => {\r\n                reject(error);\r\n              });\r\n            }\r\n          }, (error) => {\r\n            reject(error);\r\n          });\r\n        }, (error) => {\r\n          reject(error);\r\n        });\r\n      } else {\r\n        result = _this.context.defaultBehaviour;\r\n        if (result) {\r\n          message.body.auth = false;\r\n          resolve(message);\r\n        } else {\r\n          let errorMessage = { body: { code: 403, description: 'Blocked by policy' }, from: message.to, to: message.from, type: 'response' };\r\n          reject(errorMessage);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  authoriseSync(message) {\r\n    let result;\r\n    message.body = message.body || {};\r\n    if (this._isToVerify(message)) {\r\n      let isIncoming = this._isIncomingMessage(message);\r\n      message = this.context.prepareForEvaluation(message, isIncoming);\r\n      result = this.pdp.evaluatePolicies(message, isIncoming);\r\n      if (result === 'Not Applicable') {\r\n        result = this.context.defaultBehaviour;\r\n        message.body.auth = false;\r\n      }\r\n      this.actionsService.enforcePolicies(message, isIncoming);\r\n      message = this.context.prepareToForward(message, isIncoming, result);\r\n      if (result) {\r\n        message.body.auth = (message.body.auth === undefined) ? true : message.body.auth;\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else {\r\n      result = this.context.defaultBehaviour;\r\n      if (result) {\r\n        message.body.auth = false;\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  _isIncomingMessage(message) {\r\n\r\n    return !this.context.isLocal(message.from);\r\n  }\r\n\r\n  /**\r\n  * Identifies the messages to be verified by the Policy Engine\r\n  * @param    {Message}   message\r\n  * @returns  {boolean}   returns true if the message requires encryption/decryption\r\n  *                       or if its type equals 'handshake'; false otherwise\r\n  */\r\n  _isToVerify(message) {\r\n    let schemasToIgnore = ['domain', 'domain-idp', 'global', 'hyperty-runtime', 'runtime'];\r\n    let splitFrom = (message.from).split('://');\r\n    let fromSchema = splitFrom[0];\r\n    let splitTo = (message.to).split('://');\r\n    let toSchema =  splitTo[0];\r\n    let from = message.from;\r\n    let to = message.to;\r\n\r\n    // Signalling messages between P2P Stubs don't have to be verified. FFS\r\n\r\n    if (message.body && message.body.source)\r\n     from = message.body.source;\r\n\r\n    if (message.body && message.body.subscriber)\r\n      from = message.body.subscriber;\r\n\r\n    if (from.includes('/p2phandler/') || from.includes('/p2prequester/') || to.includes('/p2phandler/') || to.includes('/p2prequester/'))\r\n      return false;\r\n\r\n    // hack to disable Identity verification for messages coming from legacy domains while solution is not implemented\r\n\r\n    if (this.context.isInterworkingProtoStub(from))\r\n      return false;\r\n\r\n    if (message.from === fromSchema || message.to === toSchema || message.type === 'read' || message.type === 'response' || (isHypertyURL(message.from) && message.type === 'delete')) {\r\n      return false;\r\n    } else {\r\n      return schemasToIgnore.indexOf(fromSchema) === -1 || schemasToIgnore.indexOf(toSchema) === -1;\r\n    }\r\n  }\r\n\r\n  removePolicy(source, key) {\r\n    if (!source) throw new Error('source is not defined');\r\n    if (source !== '*' && !key) throw new Error('key is not defined');\r\n\r\n    switch (source) {\r\n      case '*':\r\n        this.context.serviceProviderPolicy = {};\r\n        this.context.userPolicies = {};\r\n        this.context.activeUserPolicy = undefined;\r\n        this.context.savePolicies('USER');\r\n        this.context.savePolicies('SERVICE_PROVIDER');\r\n        this.context.saveActivePolicy();\r\n        break;\r\n      case 'SERVICE_PROVIDER':\r\n        delete this.context.serviceProviderPolicy[key];\r\n        this.context.savePolicies();\r\n        break;\r\n      case 'USER':\r\n        delete this.context.userPolicies[key];\r\n        if (key === this.context.activeUserPolicy) {\r\n          this.context.activeUserPolicy = undefined;\r\n          this.context.saveActivePolicy();\r\n        }\r\n        this.context.savePolicies('USER');\r\n        break;\r\n      default:\r\n        throw Error('Unknown policy source: ' + source);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default PEP;\r\n",
    "static": true,
    "longname": "src/policy/PEP.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 349,
    "kind": "class",
    "name": "PEP",
    "memberof": "src/policy/PEP.js",
    "static": true,
    "longname": "src/policy/PEP.js~PEP",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/PEP.js",
    "importStyle": "PEP",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 350,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/PEP.js~PEP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PEP.js~PEP#constructor",
    "access": null,
    "description": "Creates a Policy Enforcement Point (PEP) instance",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "addPolicy",
    "memberof": "src/policy/PEP.js~PEP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PEP.js~PEP#addPolicy",
    "access": null,
    "description": "Adds a policy to the Policy Enforcement Point (PEP). The policy can be created by the service\nprovider or by the user.",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "policy",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 352,
    "kind": "method",
    "name": "authorise",
    "memberof": "src/policy/PEP.js~PEP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PEP.js~PEP#authorise",
    "access": null,
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 353,
    "kind": "method",
    "name": "authoriseSync",
    "memberof": "src/policy/PEP.js~PEP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PEP.js~PEP#authoriseSync",
    "access": null,
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "method",
    "name": "_isIncomingMessage",
    "memberof": "src/policy/PEP.js~PEP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PEP.js~PEP#_isIncomingMessage",
    "access": null,
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "method",
    "name": "_isToVerify",
    "memberof": "src/policy/PEP.js~PEP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PEP.js~PEP#_isToVerify",
    "access": null,
    "description": "Identifies the messages to be verified by the Policy Engine",
    "lineNumber": 153,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": " {boolean}   returns true if the message requires encryption/decryption\n                      or if its type equals 'handshake'; false otherwise"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "returns true if the message requires encryption/decryption\n                      or if its type equals 'handshake'; false otherwise"
    }
  },
  {
    "__docId__": 356,
    "kind": "method",
    "name": "removePolicy",
    "memberof": "src/policy/PEP.js~PEP",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/PEP.js~PEP#removePolicy",
    "access": null,
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 357,
    "kind": "file",
    "name": "src/policy/Policy.js",
    "content": "import AllowOverrides from './combiningAlgorithms/AllowOverrides';\r\nimport BlockOverrides from './combiningAlgorithms/BlockOverrides';\r\nimport FirstApplicable from './combiningAlgorithms/FirstApplicable';\r\nimport Rule from './Rule';\r\n\r\nclass Policy {\r\n\r\n  constructor(key, rules, actions, combiningAlgorithm) {\r\n    if (!key) throw new Error('key is not defined');\r\n    if (!actions) throw new Error('actions are not defined');\r\n\r\n    this.actions = actions;\r\n    this.key = key;\r\n    this._setRules(rules);\r\n    this._setCombiningAlgorithm(combiningAlgorithm);\r\n  }\r\n\r\n  addAction(method, param) {\r\n    this.actions.push({ method: method, param: param });\r\n  }\r\n\r\n  createRule(decision, condition, scope, target, priority) {\r\n    if (priority === undefined) {\r\n      priority = this.getLastPriority() + 1;\r\n    }\r\n    let rule = new Rule(decision, condition, scope, target, priority);\r\n    this.rules.push(rule);\r\n  }\r\n\r\n  deleteRule(rule) {\r\n    let indexToRemove = this.rules.indexOf(rule);\r\n    this.rules.splice(indexToRemove, 1);\r\n  }\r\n\r\n  enforceActions(context, message) {\r\n    return new Promise((resolve, reject) => {\r\n      let results = [];\r\n      if (this.actions.length !== 0) {\r\n        for (let i in this.actions) {\r\n          let result = context.pep.actionsService[this.actions[i].method](message, this.actions[i].param);\r\n          results.push(result);\r\n        }\r\n        Promise.all(results).then((messages) => {\r\n          resolve(messages);\r\n        }, error => {\r\n          reject(error);\r\n        });\r\n      } else {\r\n        resolve([message]);\r\n      }\r\n    });\r\n  }\r\n\r\n  evaluateRules(context, message, isIncoming) {\r\n    let results = [];\r\n    for (let i in this.rules) {\r\n      results.push(this.rules[i].evaluate(context, message, isIncoming));\r\n    }\r\n\r\n    return this.combiningAlgorithm.combine(results);\r\n  }\r\n\r\n  getLastPriority() {\r\n    let priorities = [];\r\n\r\n    if (this.rules.length !== 0) {\r\n      for (let i in this.rules) {\r\n        priorities.push(this.rules[i].priority);\r\n      }\r\n      return Math.max.apply(Math, priorities);\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  getRuleByPriority(priority) {\r\n    for (let i in this.rules) {\r\n      if (String(this.rules[i].priority) === String(priority)) {\r\n        return this.rules[i];\r\n      }\r\n    }\r\n    throw Error('Rule with priority ' + priority + ' does not exist!');\r\n  }\r\n\r\n  _setCombiningAlgorithm(combiningAlgorithm) {\r\n    if (!combiningAlgorithm) {\r\n      combiningAlgorithm = 'blockOverrides';\r\n    }\r\n    switch (combiningAlgorithm) {\r\n      case 'blockOverrides':\r\n        this.combiningAlgorithm = new BlockOverrides();\r\n        break;\r\n      case 'allowOverrides':\r\n        this.combiningAlgorithm = new AllowOverrides();\r\n        break;\r\n      case 'firstApplicable':\r\n        this.combiningAlgorithm = new FirstApplicable();\r\n        break;\r\n      default:\r\n        throw Error('Unknown algorithm: ' + combiningAlgorithm);\r\n    }\r\n  }\r\n\r\n  _setRules(rules) {\r\n    this.rules = [];\r\n\r\n    for (let i in rules) {\r\n      let rule = rules[i];\r\n      if (rule.priority === undefined) {\r\n        rule.priority = this.getLastPriority() + 1;\r\n      }\r\n      if (!(rule instanceof Rule)) {\r\n        rule = new Rule(rule.decision, rule.condition, rule.scope, rule.target, rule.priority);\r\n      }\r\n      this.rules.push(rule);\r\n    }\r\n  }\r\n\r\n  sortRules() {\r\n    return this.rules.sort(function(a, b) {\r\n      let x = a.priority; let y = b.priority;\r\n      return ((x < y) ? -1 : ((x > y) ? 1 : 0));\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default Policy;\r\n",
    "static": true,
    "longname": "src/policy/Policy.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 358,
    "kind": "class",
    "name": "Policy",
    "memberof": "src/policy/Policy.js",
    "static": true,
    "longname": "src/policy/Policy.js~Policy",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/Policy.js",
    "importStyle": "Policy",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 359,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#constructor",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "rules",
        "types": [
          "*"
        ]
      },
      {
        "name": "actions",
        "types": [
          "*"
        ]
      },
      {
        "name": "combiningAlgorithm",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 360,
    "kind": "member",
    "name": "actions",
    "memberof": "src/policy/Policy.js~Policy",
    "static": false,
    "longname": "src/policy/Policy.js~Policy#actions",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "member",
    "name": "key",
    "memberof": "src/policy/Policy.js~Policy",
    "static": false,
    "longname": "src/policy/Policy.js~Policy#key",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 362,
    "kind": "method",
    "name": "addAction",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#addAction",
    "access": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "method",
        "types": [
          "*"
        ]
      },
      {
        "name": "param",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 363,
    "kind": "method",
    "name": "createRule",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#createRule",
    "access": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "decision",
        "types": [
          "*"
        ]
      },
      {
        "name": "condition",
        "types": [
          "*"
        ]
      },
      {
        "name": "scope",
        "types": [
          "*"
        ]
      },
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "priority",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 364,
    "kind": "method",
    "name": "deleteRule",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#deleteRule",
    "access": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "rule",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "enforceActions",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#enforceActions",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "evaluateRules",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#evaluateRules",
    "access": null,
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "isIncoming",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "getLastPriority",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#getLastPriority",
    "access": null,
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "getRuleByPriority",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#getRuleByPriority",
    "access": null,
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "priority",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 369,
    "kind": "method",
    "name": "_setCombiningAlgorithm",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#_setCombiningAlgorithm",
    "access": null,
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "combiningAlgorithm",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 370,
    "kind": "member",
    "name": "combiningAlgorithm",
    "memberof": "src/policy/Policy.js~Policy",
    "static": false,
    "longname": "src/policy/Policy.js~Policy#combiningAlgorithm",
    "access": null,
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 371,
    "kind": "member",
    "name": "combiningAlgorithm",
    "memberof": "src/policy/Policy.js~Policy",
    "static": false,
    "longname": "src/policy/Policy.js~Policy#combiningAlgorithm",
    "access": null,
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 372,
    "kind": "member",
    "name": "combiningAlgorithm",
    "memberof": "src/policy/Policy.js~Policy",
    "static": false,
    "longname": "src/policy/Policy.js~Policy#combiningAlgorithm",
    "access": null,
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 373,
    "kind": "method",
    "name": "_setRules",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#_setRules",
    "access": null,
    "description": null,
    "lineNumber": 104,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "rules",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "rules",
    "memberof": "src/policy/Policy.js~Policy",
    "static": false,
    "longname": "src/policy/Policy.js~Policy#rules",
    "access": null,
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 375,
    "kind": "method",
    "name": "sortRules",
    "memberof": "src/policy/Policy.js~Policy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Policy.js~Policy#sortRules",
    "access": null,
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 376,
    "kind": "file",
    "name": "src/policy/ReThinkCtx.js",
    "content": "import {divideEmail, divideURL, isDataObjectURL} from '../utils/utils';\r\n\r\nclass ReThinkCtx {\r\n\r\n  constructor() {\r\n    this.defaultBehaviour = true;\r\n    this.groups = {};\r\n  }\r\n\r\n  get scheme() {\r\n    return this._scheme;\r\n  }\r\n\r\n  get date() {\r\n    return this._date;\r\n  }\r\n\r\n  get domain() {\r\n    return this._domain;\r\n  }\r\n\r\n  get type() {\r\n    return this._type;\r\n  }\r\n\r\n  get source() {\r\n    return this._source;\r\n  }\r\n\r\n  get time() {\r\n    return this._time;\r\n  }\r\n\r\n  get weekday() {\r\n    return this._weekday;\r\n  }\r\n\r\n  set scheme(params) {\r\n    let from = params.message.from;\r\n    if (isDataObjectURL(from)) {\r\n      this._scheme = divideURL(from).type;\r\n    } else {\r\n      this._scheme = undefined;\r\n    }\r\n  }\r\n\r\n  set date(now) {\r\n    let date = new Date();\r\n    let day = String(date.getDate());\r\n    if (day.length === 1) {\r\n      day = '0' + day;\r\n    }\r\n    let month = String(date.getMonth() + 1);\r\n    if (month.length === 1) {\r\n      month = '0' + month;\r\n    }\r\n    this._date = day + '/' + month + '/' + date.getFullYear();\r\n  }\r\n\r\n  set domain(params) {\r\n    if (params.message.body.identity !== undefined) {\r\n      this._domain = divideEmail(params.message.body.identity.userProfile.username).domain;\r\n    }\r\n  }\r\n\r\n  set type(params) {\r\n    let message = params.message;\r\n    if (message.body.value !== undefined) {\r\n      this._type = message.body.value.resourceType;\r\n    }\r\n  }\r\n\r\n  set source(params) {\r\n    if (params.message.body.identity !== undefined) {\r\n      this._source = params.message.body.identity.userProfile.username;\r\n    }\r\n  }\r\n\r\n  set time(now) {\r\n    now = new Date();\r\n    let minutes = String(now.getMinutes());\r\n    if (minutes.length === 1) {\r\n      minutes = '0' + minutes;\r\n    }\r\n    this._time = parseInt(String(now.getHours()) + minutes);\r\n  }\r\n\r\n  set weekday(now) {\r\n    this._weekday = String(new Date().getDay());\r\n  }\r\n\r\n}\r\n\r\nexport default ReThinkCtx;\r\n",
    "static": true,
    "longname": "src/policy/ReThinkCtx.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 377,
    "kind": "class",
    "name": "ReThinkCtx",
    "memberof": "src/policy/ReThinkCtx.js",
    "static": true,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/ReThinkCtx.js",
    "importStyle": "ReThinkCtx",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 378,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#constructor",
    "access": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 379,
    "kind": "member",
    "name": "defaultBehaviour",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#defaultBehaviour",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 380,
    "kind": "member",
    "name": "groups",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#groups",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 381,
    "kind": "get",
    "name": "scheme",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#scheme",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 382,
    "kind": "get",
    "name": "date",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#date",
    "access": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "get",
    "name": "domain",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#domain",
    "access": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 384,
    "kind": "get",
    "name": "type",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#type",
    "access": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 385,
    "kind": "get",
    "name": "source",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#source",
    "access": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 386,
    "kind": "get",
    "name": "time",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#time",
    "access": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 387,
    "kind": "get",
    "name": "weekday",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#weekday",
    "access": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "set",
    "name": "scheme",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#scheme",
    "access": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "member",
    "name": "_scheme",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#_scheme",
    "access": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 390,
    "kind": "member",
    "name": "_scheme",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#_scheme",
    "access": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 391,
    "kind": "set",
    "name": "date",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#date",
    "access": null,
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 392,
    "kind": "member",
    "name": "_date",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#_date",
    "access": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 393,
    "kind": "set",
    "name": "domain",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#domain",
    "access": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 394,
    "kind": "member",
    "name": "_domain",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#_domain",
    "access": null,
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 395,
    "kind": "set",
    "name": "type",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#type",
    "access": null,
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 396,
    "kind": "member",
    "name": "_type",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#_type",
    "access": null,
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 397,
    "kind": "set",
    "name": "source",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#source",
    "access": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "member",
    "name": "_source",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#_source",
    "access": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 399,
    "kind": "set",
    "name": "time",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#time",
    "access": null,
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 400,
    "kind": "member",
    "name": "_time",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#_time",
    "access": null,
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 401,
    "kind": "set",
    "name": "weekday",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#weekday",
    "access": null,
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 402,
    "kind": "member",
    "name": "_weekday",
    "memberof": "src/policy/ReThinkCtx.js~ReThinkCtx",
    "static": false,
    "longname": "src/policy/ReThinkCtx.js~ReThinkCtx#_weekday",
    "access": null,
    "description": null,
    "lineNumber": 89,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 403,
    "kind": "file",
    "name": "src/policy/Rule.js",
    "content": "import AdvancedCondition from './conditions/AdvancedCondition';\r\nimport Condition from './conditions/Condition';\r\nimport {getUserEmailFromURL, isDataObjectURL, removePathFromURL} from '../utils/utils';\r\nimport SubscriptionCondition from './conditions/AdvancedCondition';\r\n\r\nclass Rule {\r\n\r\n  constructor(decision, condition, scope, target, priority) {\r\n    this.decision = decision;\r\n    this.setCondition(condition);\r\n    this.priority = priority;\r\n    this.scope = scope;\r\n    this.target = target;\r\n  }\r\n\r\n  setCondition(condition) {\r\n    if (!(condition instanceof Condition || condition instanceof SubscriptionCondition || condition instanceof AdvancedCondition)) {\r\n      let attribute = condition.attribute;\r\n      switch (attribute) {\r\n        case 'subscription':\r\n          this.condition = new SubscriptionCondition(condition.attribute, condition.operator, condition.params);\r\n          break;\r\n        case undefined:\r\n          this.condition = new AdvancedCondition(condition);\r\n          break;\r\n        default:\r\n          this.condition = new Condition(condition.attribute, condition.operator, condition.params);\r\n      }\r\n    } else {\r\n      this.condition = condition;\r\n    }\r\n  }\r\n\r\n  evaluate(context, message, isIncoming) {\r\n    let field = (isIncoming) ? message.to : message.from;\r\n    let hypertyName;\r\n    switch (this.scope) {\r\n      case 'global':\r\n        break;\r\n\r\n      case 'hyperty':\r\n        if (isDataObjectURL(field)) {\r\n          let reporter = context.runtimeRegistry.getReporterURLSynchonous(removePathFromURL(field));\r\n          if (reporter !== undefined) {\r\n            hypertyName = context.runtimeRegistry.getHypertyName(reporter);\r\n          }\r\n        } else {\r\n          if (field.split('://')[0] === 'hyperty') {\r\n            hypertyName = context.runtimeRegistry.getHypertyName(removePathFromURL(field));\r\n          }\r\n        }\r\n        if (hypertyName === this.target) {\r\n          break;\r\n        }\r\n\r\n        return 'Not Applicable';\r\n\r\n      case 'identity':\r\n        let owner;\r\n\r\n        if (isDataObjectURL(field)) {\r\n          let reporter = context.runtimeRegistry.getReporterURLSynchonous(removePathFromURL(field));\r\n          owner = context.runtimeRegistry.getHypertyOwner(reporter);\r\n        } else {\r\n          if (field.split('://')[0] === 'hyperty') {\r\n            owner = context.runtimeRegistry.getHypertyOwner(removePathFromURL(field));\r\n          }\r\n        }\r\n        if (owner !== undefined) {\r\n          owner = getUserEmailFromURL(owner);\r\n        }\r\n        if (owner === this.target) {\r\n          break;\r\n        }\r\n\r\n        return 'Not Applicable';\r\n    }\r\n\r\n    if (this.condition.isApplicable(context, message, this.scope, this.target)) {\r\n      return this.decision;\r\n    } else {\r\n      return 'Not Applicable';\r\n    }\r\n  }\r\n}\r\n\r\nexport default Rule;\r\n",
    "static": true,
    "longname": "src/policy/Rule.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 404,
    "kind": "class",
    "name": "Rule",
    "memberof": "src/policy/Rule.js",
    "static": true,
    "longname": "src/policy/Rule.js~Rule",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/policy/Rule.js",
    "importStyle": "Rule",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 405,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/policy/Rule.js~Rule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Rule.js~Rule#constructor",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "decision",
        "types": [
          "*"
        ]
      },
      {
        "name": "condition",
        "types": [
          "*"
        ]
      },
      {
        "name": "scope",
        "types": [
          "*"
        ]
      },
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "priority",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 406,
    "kind": "member",
    "name": "decision",
    "memberof": "src/policy/Rule.js~Rule",
    "static": false,
    "longname": "src/policy/Rule.js~Rule#decision",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 407,
    "kind": "member",
    "name": "priority",
    "memberof": "src/policy/Rule.js~Rule",
    "static": false,
    "longname": "src/policy/Rule.js~Rule#priority",
    "access": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 408,
    "kind": "member",
    "name": "scope",
    "memberof": "src/policy/Rule.js~Rule",
    "static": false,
    "longname": "src/policy/Rule.js~Rule#scope",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 409,
    "kind": "member",
    "name": "target",
    "memberof": "src/policy/Rule.js~Rule",
    "static": false,
    "longname": "src/policy/Rule.js~Rule#target",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "setCondition",
    "memberof": "src/policy/Rule.js~Rule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Rule.js~Rule#setCondition",
    "access": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "condition",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 411,
    "kind": "member",
    "name": "condition",
    "memberof": "src/policy/Rule.js~Rule",
    "static": false,
    "longname": "src/policy/Rule.js~Rule#condition",
    "access": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 412,
    "kind": "member",
    "name": "condition",
    "memberof": "src/policy/Rule.js~Rule",
    "static": false,
    "longname": "src/policy/Rule.js~Rule#condition",
    "access": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 413,
    "kind": "member",
    "name": "condition",
    "memberof": "src/policy/Rule.js~Rule",
    "static": false,
    "longname": "src/policy/Rule.js~Rule#condition",
    "access": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 414,
    "kind": "member",
    "name": "condition",
    "memberof": "src/policy/Rule.js~Rule",
    "static": false,
    "longname": "src/policy/Rule.js~Rule#condition",
    "access": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 415,
    "kind": "method",
    "name": "evaluate",
    "memberof": "src/policy/Rule.js~Rule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/policy/Rule.js~Rule#evaluate",
    "access": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "isIncoming",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 416,
    "kind": "file",
    "name": "src/protostub/IdpProxyStub.js",
    "content": "/**\r\n* Identity Provider Proxy Protocol Stub\r\n*/\r\nclass IdpProxyStub {\r\n\r\n  /**\r\n  * Constructor of the IdpProxy Stub\r\n  * The constructor add a listener in the messageBus received and start a web worker with the idpProxy received\r\n  *\r\n  * @param  {messageBus}      messageBus\r\n  * @param  {domain}          Domain\r\n  * @param  {idpProxy}    identity Provider Proxy javascript file\r\n  */\r\n  constructor(messageBus, domain, idpProxy) {\r\n    let _this = this;\r\n    _this.messageBus = messageBus;\r\n    _this.domain = domain;\r\n    _this.idpProxy = idpProxy;\r\n\r\n    _this.messageBus.addListener('domain://' + idpProxy, function(msg) {\r\n      _this.requestToIdp(msg);\r\n    });\r\n\r\n    //start the web worker with the idpProxy\r\n    _this.start(idpProxy);\r\n  }\r\n\r\n  /**\r\n  * Function that see the intended method in the message received and call the respective function\r\n  *\r\n  * @param {message}  message received in the messageBus\r\n  */\r\n  requestToIdp(msg) {\r\n    let _this = this;\r\n    let params = msg.body.params;\r\n    switch (msg.body.method) {\r\n      case 'login':\r\n        _this.login(params).then(function(value) { _this.replyMessage(msg, value);});\r\n        break;\r\n      case 'generateAssertion':\r\n        _this.generate(params).then(function(value) { _this.replyMessage(msg, value);});\r\n        break;\r\n      case 'validateAssertion':\r\n        _this.validate(params).then(function(value) { _this.replyMessage(msg, value);});\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Starts a web worker with the idpProxy javascipt file\r\n  *\r\n  * @param  {idpProxy}    identity Provider Proxy javascript file\r\n  */\r\n  start(idpProxy) {\r\n    let _this = this;\r\n    if (window.Worker) { //check if the browser supports the worker API\r\n\r\n      let myWorker = new Worker('/src/identity/IdpProxy.js');\r\n      _this.myWorker = myWorker;\r\n      _this.myWorker.postMessage(['create','IdpProxy']);\r\n\r\n    } else {\r\n      return 'error';\r\n    }\r\n  }\r\n\r\n  /**\r\n  * function that makes a request for an identity assertion to the web worker running the idpProxy\r\n  *\r\n  * @param  {params}  parameters received in the message. In this case contains the content, origin and usernamehint\r\n  * @return {Promise} returns a promise with an identity assertion generate by the idpProxy\r\n  */\r\n  generate(params) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve,reject) {\r\n      if (window.Worker) { //check if the browser supports the worker API\r\n\r\n        _this.myWorker.postMessage(['generate', params]);\r\n\r\n        _this.myWorker.onmessage = function(e) {\r\n          resolve(e.data);\r\n          console.log('Message received from worker', e.data);\r\n        };\r\n      } else {\r\n        reject('error');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n  * function that makes a request to validate an identity assertion to the web worker running the idpProxy\r\n  *\r\n  * @param  {params}  parameters received in the message. In this case contains the identity assertion and origin\r\n  * @return {Promise} returns a promise with the identity assertion validation result, received by the idpProxy\r\n  */\r\n  validate(params) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve,reject) {\r\n      if (window.Worker) { //check if the browser supports the worker API\r\n\r\n        _this.myWorker.postMessage(['validate',params]);\r\n\r\n        _this.myWorker.onmessage = function(e) {\r\n          resolve(e.data);\r\n          console.log('Message received from worker', e.data);\r\n        };\r\n      } else {\r\n        reject('error');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n  * function that makes a request for a user identity to the web worker running the idpProxy\r\n  *\r\n  * @param  {params}  parameters received in the message. In this case contains the login scope\r\n  * @return {Promise} returns a promise an URL so the Identity Module can use to obtain an identity\r\n  */\r\n  login(params) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve,reject) {\r\n      if (window.Worker) { //check if the browser supports the worker API\r\n\r\n        _this.myWorker.postMessage(['login', params]);\r\n\r\n        _this.myWorker.onmessage = function(e) {\r\n          resolve(e.data);\r\n          console.log('Message received from worker', e.data);\r\n        };\r\n      } else {\r\n        reject('error');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n  * This function receives a message and a value. It replies the value to the sender of the message received\r\n  *\r\n  * @param  {message}   message received\r\n  * @param  {value}     value to include in the new message to send\r\n  */\r\n  replyMessage(msg, value) {\r\n    let _this = this;\r\n\r\n    let message = {id: msg.id, type: 'response', to: msg.from, from: msg.to,\r\n                   body: {code: 200, value: value}};\r\n\r\n    _this.messageBus.postMessage(message);\r\n  }\r\n}\r\n\r\nexport default IdpProxyStub;\r\n",
    "static": true,
    "longname": "src/protostub/IdpProxyStub.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 417,
    "kind": "class",
    "name": "IdpProxyStub",
    "memberof": "src/protostub/IdpProxyStub.js",
    "static": true,
    "longname": "src/protostub/IdpProxyStub.js~IdpProxyStub",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/protostub/IdpProxyStub.js",
    "importStyle": "IdpProxyStub",
    "description": "Identity Provider Proxy Protocol Stub",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 418,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/protostub/IdpProxyStub.js~IdpProxyStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/IdpProxyStub.js~IdpProxyStub#constructor",
    "access": null,
    "description": "Constructor of the IdpProxy Stub\nThe constructor add a listener in the messageBus received and start a web worker with the idpProxy received",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "messageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "Domain",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "idpProxy"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "Provider Proxy javascript file"
      }
    ]
  },
  {
    "__docId__": 419,
    "kind": "method",
    "name": "requestToIdp",
    "memberof": "src/protostub/IdpProxyStub.js~IdpProxyStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/IdpProxyStub.js~IdpProxyStub#requestToIdp",
    "access": null,
    "description": "Function that see the intended method in the message received and call the respective function",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "message"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "received in the messageBus"
      }
    ]
  },
  {
    "__docId__": 420,
    "kind": "method",
    "name": "start",
    "memberof": "src/protostub/IdpProxyStub.js~IdpProxyStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/IdpProxyStub.js~IdpProxyStub#start",
    "access": null,
    "description": "Starts a web worker with the idpProxy javascipt file",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "idpProxy"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "Provider Proxy javascript file"
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 421,
    "kind": "method",
    "name": "generate",
    "memberof": "src/protostub/IdpProxyStub.js~IdpProxyStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/IdpProxyStub.js~IdpProxyStub#generate",
    "access": null,
    "description": "function that makes a request for an identity assertion to the web worker running the idpProxy",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "params"
        ],
        "spread": false,
        "optional": false,
        "name": "parameters",
        "description": "received in the message. In this case contains the content, origin and usernamehint"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "returns a promise with an identity assertion generate by the idpProxy"
    }
  },
  {
    "__docId__": 422,
    "kind": "method",
    "name": "validate",
    "memberof": "src/protostub/IdpProxyStub.js~IdpProxyStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/IdpProxyStub.js~IdpProxyStub#validate",
    "access": null,
    "description": "function that makes a request to validate an identity assertion to the web worker running the idpProxy",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "params"
        ],
        "spread": false,
        "optional": false,
        "name": "parameters",
        "description": "received in the message. In this case contains the identity assertion and origin"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "returns a promise with the identity assertion validation result, received by the idpProxy"
    }
  },
  {
    "__docId__": 423,
    "kind": "method",
    "name": "login",
    "memberof": "src/protostub/IdpProxyStub.js~IdpProxyStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/IdpProxyStub.js~IdpProxyStub#login",
    "access": null,
    "description": "function that makes a request for a user identity to the web worker running the idpProxy",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "params"
        ],
        "spread": false,
        "optional": false,
        "name": "parameters",
        "description": "received in the message. In this case contains the login scope"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "returns a promise an URL so the Identity Module can use to obtain an identity"
    }
  },
  {
    "__docId__": 424,
    "kind": "method",
    "name": "replyMessage",
    "memberof": "src/protostub/IdpProxyStub.js~IdpProxyStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/IdpProxyStub.js~IdpProxyStub#replyMessage",
    "access": null,
    "description": "This function receives a message and a value. It replies the value to the sender of the message received",
    "lineNumber": 147,
    "params": [
      {
        "nullable": null,
        "types": [
          "message"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "received"
      },
      {
        "nullable": null,
        "types": [
          "value"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "to include in the new message to send"
      }
    ]
  },
  {
    "__docId__": 425,
    "kind": "file",
    "name": "src/protostub/ProtoStub.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n/**\r\n * ProtoStub Interface\r\n */\r\nclass ProtoStub {\r\n\r\n  /**\r\n   * To initialise the protocol stub including as input parameters its allocated component runtime url, the runtime BUS postMessage function to be invoked on messages received by the protocol stub and required configuration retrieved from protocolStub descriptor.\r\n   * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n   * @param  {Message.Message}                           busPostMessage     configuration\r\n   * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n   */\r\n  constructor(runtimeProtoStubURL, bus, config) {\r\n    this._runtimeProtoStubURL = runtimeProtoStubURL;\r\n    this._bus = bus;\r\n    this._config = config;\r\n  }\r\n\r\n  /**\r\n   * To connect the protocol stub to the back-end server\r\n   * @param  {IDToken} identity identity\r\n   */\r\n  connect(identity) {\r\n    // Body...\r\n  }\r\n\r\n  /**\r\n   * To disconnect the protocol stub.\r\n   */\r\n  disconnect() {\r\n    // Body...\r\n  }\r\n\r\n  /**\r\n   * To post messages to be dispatched by the protocol stub to connected back-end server\r\n   * @param  {Message.Message}  message       message\r\n   */\r\n  postMessage(message) {\r\n\r\n  }\r\n\r\n  /**\r\n   * Filter method that should be used for every messages in direction: Protostub -> MessageNode\r\n   * @param  {Message} msg Original message from the MessageBus\r\n   * @return {boolean} true if it's to be deliver in the MessageNode\r\n   */\r\n  _filter(msg) {\r\n    if (msg.body && msg.body.via === this._runtimeProtoStubURL)\r\n      return false;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Method that should be used to deliver the message in direction: Protostub -> MessageBus (core)\r\n   * @param  {Message} msg Original message from the MessageNode\r\n   */\r\n  _deliver(msg) {\r\n    if (!msg.body) msg.body = {};\r\n\r\n    msg.body.via = this._runtimeProtoStubURL;\r\n    this._bus.postMessage(msg);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * To activate this protocol stub, using the same method for all protostub.\r\n * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n * @param  {Message.Message}                           busPostMessage     configuration\r\n * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n * @return {Object} Object with name and instance of ProtoStub\r\n */\r\nexport default function activate(url, bus, config) {\r\n  return {\r\n    name: 'ProtoStub',\r\n    instance: new ProtoStub(url, bus, config)\r\n  };\r\n}\r\n",
    "static": true,
    "longname": "src/protostub/ProtoStub.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 426,
    "kind": "class",
    "name": "ProtoStub",
    "memberof": "src/protostub/ProtoStub.js",
    "static": true,
    "longname": "src/protostub/ProtoStub.js~ProtoStub",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/protostub/ProtoStub.js",
    "importStyle": null,
    "description": "ProtoStub Interface",
    "lineNumber": 26,
    "interface": false
  },
  {
    "__docId__": 427,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/protostub/ProtoStub.js~ProtoStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/ProtoStub.js~ProtoStub#constructor",
    "access": null,
    "description": "To initialise the protocol stub including as input parameters its allocated component runtime url, the runtime BUS postMessage function to be invoked on messages received by the protocol stub and required configuration retrieved from protocolStub descriptor.",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.RuntimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeProtoStubURL",
        "description": "runtimeProtoSubURL"
      },
      {
        "nullable": null,
        "types": [
          "Message.Message"
        ],
        "spread": false,
        "optional": false,
        "name": "busPostMessage",
        "description": "configuration"
      },
      {
        "nullable": null,
        "types": [
          "ProtoStubDescriptor.ConfigurationDataList"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "configuration"
      }
    ]
  },
  {
    "__docId__": 428,
    "kind": "member",
    "name": "_runtimeProtoStubURL",
    "memberof": "src/protostub/ProtoStub.js~ProtoStub",
    "static": false,
    "longname": "src/protostub/ProtoStub.js~ProtoStub#_runtimeProtoStubURL",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 429,
    "kind": "member",
    "name": "_bus",
    "memberof": "src/protostub/ProtoStub.js~ProtoStub",
    "static": false,
    "longname": "src/protostub/ProtoStub.js~ProtoStub#_bus",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 430,
    "kind": "member",
    "name": "_config",
    "memberof": "src/protostub/ProtoStub.js~ProtoStub",
    "static": false,
    "longname": "src/protostub/ProtoStub.js~ProtoStub#_config",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 431,
    "kind": "method",
    "name": "connect",
    "memberof": "src/protostub/ProtoStub.js~ProtoStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/ProtoStub.js~ProtoStub#connect",
    "access": null,
    "description": "To connect the protocol stub to the back-end server",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "IDToken"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "identity"
      }
    ]
  },
  {
    "__docId__": 432,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/protostub/ProtoStub.js~ProtoStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/ProtoStub.js~ProtoStub#disconnect",
    "access": null,
    "description": "To disconnect the protocol stub.",
    "lineNumber": 51,
    "params": []
  },
  {
    "__docId__": 433,
    "kind": "method",
    "name": "postMessage",
    "memberof": "src/protostub/ProtoStub.js~ProtoStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/ProtoStub.js~ProtoStub#postMessage",
    "access": null,
    "description": "To post messages to be dispatched by the protocol stub to connected back-end server",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message.Message"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "message"
      }
    ]
  },
  {
    "__docId__": 434,
    "kind": "method",
    "name": "_filter",
    "memberof": "src/protostub/ProtoStub.js~ProtoStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/ProtoStub.js~ProtoStub#_filter",
    "access": null,
    "description": "Filter method that should be used for every messages in direction: Protostub -> MessageNode",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Original message from the MessageBus"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it's to be deliver in the MessageNode"
    }
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "_deliver",
    "memberof": "src/protostub/ProtoStub.js~ProtoStub",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/protostub/ProtoStub.js~ProtoStub#_deliver",
    "access": null,
    "description": "Method that should be used to deliver the message in direction: Protostub -> MessageBus (core)",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Original message from the MessageNode"
      }
    ]
  },
  {
    "__docId__": 436,
    "kind": "function",
    "name": "activate",
    "memberof": "src/protostub/ProtoStub.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/protostub/ProtoStub.js~activate",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/protostub/ProtoStub.js",
    "importStyle": "activate",
    "description": "To activate this protocol stub, using the same method for all protostub.",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.RuntimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeProtoStubURL",
        "description": "runtimeProtoSubURL"
      },
      {
        "nullable": null,
        "types": [
          "Message.Message"
        ],
        "spread": false,
        "optional": false,
        "name": "busPostMessage",
        "description": "configuration"
      },
      {
        "nullable": null,
        "types": [
          "ProtoStubDescriptor.ConfigurationDataList"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "configuration"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Object with name and instance of ProtoStub"
    }
  },
  {
    "__docId__": 437,
    "kind": "file",
    "name": "src/qos-ua/QoSUA.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n/**\r\n * QoS User Agent Interface\r\n */\r\nclass QoSUA {\r\n\r\n  /**\r\n   * Get Connectivity Statistics data\r\n   */\r\n  getCurrentConnectivityStatistics()  {\r\n    // Body...\r\n  }\r\n\r\n  /**\r\n   * Sends Connectivity Statistics data to QoS Broker\r\n   */\r\n  sendConnectivityStatisticsToBroker() {\r\n    // Body\r\n  }\r\n\r\n}\r\n",
    "static": true,
    "longname": "src/qos-ua/QoSUA.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 438,
    "kind": "class",
    "name": "QoSUA",
    "memberof": "src/qos-ua/QoSUA.js",
    "static": true,
    "longname": "src/qos-ua/QoSUA.js~QoSUA",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/qos-ua/QoSUA.js",
    "importStyle": null,
    "description": "QoS User Agent Interface",
    "lineNumber": 26,
    "interface": false
  },
  {
    "__docId__": 439,
    "kind": "method",
    "name": "getCurrentConnectivityStatistics",
    "memberof": "src/qos-ua/QoSUA.js~QoSUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/qos-ua/QoSUA.js~QoSUA#getCurrentConnectivityStatistics",
    "access": null,
    "description": "Get Connectivity Statistics data",
    "lineNumber": 31,
    "params": []
  },
  {
    "__docId__": 440,
    "kind": "method",
    "name": "sendConnectivityStatisticsToBroker",
    "memberof": "src/qos-ua/QoSUA.js~QoSUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/qos-ua/QoSUA.js~QoSUA#sendConnectivityStatisticsToBroker",
    "access": null,
    "description": "Sends Connectivity Statistics data to QoS Broker",
    "lineNumber": 38,
    "params": []
  },
  {
    "__docId__": 441,
    "kind": "file",
    "name": "src/registry/Discovery.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\nimport {divideURL, convertToUserURL} from '../utils/utils';\r\n\r\n/**\r\n* Core Discovery interface\r\n* Class to allow applications to search for hyperties and DataObjects using the message bus\r\n*/\r\nclass Discovery {\r\n\r\n  /**\r\n  * To initialise the HypertyDiscover, which will provide the support for hyperties to\r\n  * query users registered in outside the internal core.\r\n  * @param  {MessageBus}          msgbus                msgbus\r\n  * @param  {RuntimeURL}          runtimeURL            runtimeURL\r\n  */\r\n  constructor(runtimeURL, msgBus) {\r\n    let _this = this;\r\n    _this.messageBus = msgBus;\r\n\r\n    _this.domain = divideURL(runtimeURL).domain;\r\n    _this.discoveryURL = runtimeURL;\r\n    _this.registryURL = runtimeURL + '/registry/';\r\n\r\n  }\r\n\r\n  /**\r\n  * function to request about an dataObject registered in domain registry with a given name, and\r\n  * return the dataObject information, if found.\r\n  * @param  {String}              name  dataObject URL\r\n  * @param  {String}            domain (Optional)\r\n  * @return {Promise}          Promise\r\n  */\r\n  discoverDataObjectPerName(name, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    activeDomain = (!domain) ? _this.domain : domain;\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: name}\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let dataObject = reply.body.value;\r\n\r\n        if (dataObject) {\r\n          resolve(dataObject);\r\n        } else {\r\n          reject('DataObject not found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * function to request about dataObject registered in domain registry, and\r\n  * return the dataObject information, if found.\r\n  * @param  {String}              url  dataObject URL\r\n  * @param  {String}            domain (Optional)\r\n  * @return {Promise}          Promise\r\n  */\r\n  discoverDataObjectPerURL(url, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: url}\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let dataObject = reply.body.value;\r\n\r\n        if (dataObject) {\r\n          resolve(dataObject);\r\n        } else {\r\n          reject('DataObject not found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  *  function to delete an Data Object registered in the Domain Registry\r\n  *  @param   {String}           url              dataObject url\r\n  *  @param   {domain}           domain         (Optional)\r\n  *  @return  {Promise}          Promise          result\r\n  */\r\n  deleteDataObject(url, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'delete', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/',  body: { value: {name: url}}};\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let response = reply.body.code;\r\n\r\n        if (response === 200) {\r\n          resolve(response);\r\n        } else {\r\n          reject('Error on deleting dataObject');\r\n        }\r\n      });\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * function to request about specific reporter dataObject registered in domain registry, and\r\n  * return the dataObjects from that reporter.\r\n  * @param  {String}           reporter     dataObject reporter\r\n  * @param  {String}           domain       (Optional)\r\n  * @return {Array}           Promise       DataObjects\r\n  */\r\n  discoverDataObjectPerReporter(reporter, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: reporter}\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let dataObjects = reply.body.value;\r\n\r\n        if (dataObjects) {\r\n          resolve(dataObjects);\r\n        } else {\r\n          reject('No dataObject was found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /** Advanced Search for dataObjects registered in domain registry\r\n  * @param  {String}           user                  user identifier, either in url or email format\r\n  * @param  {Array<string>}    schema (Optional)     types of dataObject schemas\r\n  * @param  {Array<string>}    resources (Optional)  types of dataObject resources\r\n  * @param  {String}           domain (Optional)     domain of the registry to search\r\n  */\r\n  discoverDataObject(name, schema, resources, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n    //let userIdentifier = convertToUserURL(user);\r\n\r\n    activeDomain = (!domain) ? _this.domain : domain;\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: name,\r\n      criteria: {resources: resources, dataSchemes: schema}\r\n      }\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let hyperties = reply.body.value;\r\n\r\n        if (hyperties) {\r\n          resolve(hyperties);\r\n        } else {\r\n          reject('No DataObject was found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /** Advanced Search for Hyperties registered in domain registry\r\n  * @param  {String}           user                  user identifier, either in url or email format\r\n  * @param  {Array<string>}    schema (Optional)     types of hyperties schemas\r\n  * @param  {Array<string>}    resources (Optional)  types of hyperties resources\r\n  * @param  {String}           domain (Optional)     domain of the registry to search\r\n  */\r\n  discoverHyperty(user, schema, resources, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n    let userIdentifier = convertToUserURL(user);\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: userIdentifier,\r\n      criteria: {resources: resources, dataSchemes: schema}\r\n      }\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let hyperties = reply.body.value;\r\n\r\n        if (hyperties) {\r\n          resolve(hyperties);\r\n        } else {\r\n          reject('No Hyperty was found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * function to request about users registered in domain registry, and\r\n  * return the last hyperty instance registered by the user.\r\n  * @param  {email}              email\r\n  * @param  {domain}            domain (Optional)\r\n  * @return {Promise}          Promise\r\n  */\r\n  discoverHypertyPerUser(email, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\r\n\r\n    // message to query domain registry, asking for a user hyperty.\r\n    let message = {\r\n      type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: identityURL}\r\n    };\r\n\r\n    console.log('Message: ', message, activeDomain, identityURL);\r\n\r\n    //console.log('message READ', message);\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(message, (reply) => {\r\n        console.log('message reply', reply);\r\n\r\n        let hyperty;\r\n        let mostRecent;\r\n        let lastHyperty;\r\n        let value = reply.body.value;\r\n\r\n        for (hyperty in value) {\r\n          if (value[hyperty].lastModified !== undefined) {\r\n            if (mostRecent === undefined) {\r\n              mostRecent = new Date(value[hyperty].lastModified);\r\n              lastHyperty = hyperty;\r\n            } else {\r\n              let hypertyDate = new Date(value[hyperty].lastModified);\r\n              if (mostRecent.getTime() < hypertyDate.getTime()) {\r\n                mostRecent = hypertyDate;\r\n                lastHyperty = hyperty;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        console.log('Last Hyperty: ', lastHyperty, mostRecent);\r\n\r\n        let hypertyURL = lastHyperty;\r\n\r\n        if (hypertyURL === undefined) {\r\n          return reject('User Hyperty not found');\r\n        }\r\n\r\n        let idPackage = {\r\n          id: email,\r\n          descriptor: value[hypertyURL].descriptor,\r\n          hypertyURL: hypertyURL\r\n        };\r\n\r\n        console.log('===> hypertyDiscovery messageBundle: ', idPackage);\r\n        resolve(idPackage);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * function to request about users registered in domain registry, and\r\n  * return the all the hyperties registered by the user\r\n  * @param  {email}              email\r\n  * @param  {domain}            domain (Optional)\r\n  * @return {Promise}          Promise\r\n  */\r\n  discoverHypertiesPerUser(email, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\r\n\r\n    // message to query domain registry, asking for a user hyperty.\r\n    let message = {\r\n      type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: identityURL}\r\n    };\r\n\r\n    console.log('Message discoverHypertiesPerUser: ', message, activeDomain, identityURL);\r\n\r\n    //console.log('message READ', message);\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(message, (reply) => {\r\n        console.log('discoverHypertiesPerUser reply', reply);\r\n\r\n        let value = reply.body.value;\r\n\r\n        if (!value) {\r\n          return reject('User Hyperty not found');\r\n        }\r\n\r\n        resolve(value);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  *  function to delete an hypertyInstance in the Domain Registry\r\n  *  @param   {String}           user              user url\r\n  *  @param   {String}           hypertyInstance   HypertyInsntance url\r\n  *  @param   {domain}           domain (Optional)\r\n  *  @return  {Promise}          Promise          result\r\n  */\r\n  deleteHyperty(user, hypertyInstance, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'delete', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/',   body: { value: {user: user, url: hypertyInstance }}};\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let response = reply.body.code;\r\n\r\n        if (response) {\r\n          resolve('Hyperty successfully deleted');\r\n        } else {\r\n          reject('Error on deleting hyperty');\r\n        }\r\n      });\r\n    });\r\n\r\n  }\r\n\r\n}\r\n\r\nexport default Discovery;\r\n",
    "static": true,
    "longname": "src/registry/Discovery.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 442,
    "kind": "class",
    "name": "Discovery",
    "memberof": "src/registry/Discovery.js",
    "static": true,
    "longname": "src/registry/Discovery.js~Discovery",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/registry/Discovery.js",
    "importStyle": "Discovery",
    "description": "Core Discovery interface\nClass to allow applications to search for hyperties and DataObjects using the message bus",
    "lineNumber": 30,
    "interface": false
  },
  {
    "__docId__": 443,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#constructor",
    "access": null,
    "description": "To initialise the HypertyDiscover, which will provide the support for hyperties to\nquery users registered in outside the internal core.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "msgbus",
        "description": "msgbus"
      },
      {
        "nullable": null,
        "types": [
          "RuntimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeURL",
        "description": "runtimeURL"
      }
    ]
  },
  {
    "__docId__": 444,
    "kind": "method",
    "name": "discoverDataObjectPerName",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#discoverDataObjectPerName",
    "access": null,
    "description": "function to request about an dataObject registered in domain registry with a given name, and\nreturn the dataObject information, if found.",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "dataObject URL"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise"
    }
  },
  {
    "__docId__": 445,
    "kind": "method",
    "name": "discoverDataObjectPerURL",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#discoverDataObjectPerURL",
    "access": null,
    "description": "function to request about dataObject registered in domain registry, and\nreturn the dataObject information, if found.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "dataObject URL"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise"
    }
  },
  {
    "__docId__": 446,
    "kind": "method",
    "name": "deleteDataObject",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#deleteDataObject",
    "access": null,
    "description": " function to delete an Data Object registered in the Domain Registry",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "dataObject url"
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise          result"
    }
  },
  {
    "__docId__": 447,
    "kind": "method",
    "name": "discoverDataObjectPerReporter",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#discoverDataObjectPerReporter",
    "access": null,
    "description": "function to request about specific reporter dataObject registered in domain registry, and\nreturn the dataObjects from that reporter.",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "reporter",
        "description": "dataObject reporter"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "Promise       DataObjects"
    }
  },
  {
    "__docId__": 448,
    "kind": "method",
    "name": "discoverDataObject",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#discoverDataObject",
    "access": null,
    "description": "Advanced Search for dataObjects registered in domain registry",
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user identifier, either in url or email format"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of dataObject schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of dataObject resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)     domain of the registry to search"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 449,
    "kind": "method",
    "name": "discoverHyperty",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#discoverHyperty",
    "access": null,
    "description": "Advanced Search for Hyperties registered in domain registry",
    "lineNumber": 227,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user identifier, either in url or email format"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of hyperties schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of hyperties resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)     domain of the registry to search"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 450,
    "kind": "method",
    "name": "discoverHypertyPerUser",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#discoverHypertyPerUser",
    "access": null,
    "description": "function to request about users registered in domain registry, and\nreturn the last hyperty instance registered by the user.",
    "lineNumber": 266,
    "params": [
      {
        "nullable": null,
        "types": [
          "email"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise"
    }
  },
  {
    "__docId__": 451,
    "kind": "method",
    "name": "discoverHypertiesPerUser",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#discoverHypertiesPerUser",
    "access": null,
    "description": "function to request about users registered in domain registry, and\nreturn the all the hyperties registered by the user",
    "lineNumber": 338,
    "params": [
      {
        "nullable": null,
        "types": [
          "email"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise"
    }
  },
  {
    "__docId__": 452,
    "kind": "method",
    "name": "deleteHyperty",
    "memberof": "src/registry/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Discovery.js~Discovery#deleteHyperty",
    "access": null,
    "description": " function to delete an hypertyInstance in the Domain Registry",
    "lineNumber": 381,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user url"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hypertyInstance",
        "description": "HypertyInsntance url"
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise          result"
    }
  },
  {
    "__docId__": 453,
    "kind": "file",
    "name": "src/registry/DiscoveryServiceFramework.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\nimport {divideURL, convertToUserURL} from '../utils/utils';\r\n\r\n/**\r\n* Core Discovery interface\r\n* Class to allow applications to search for hyperties and DataObjects using the message bus\r\n*/\r\nclass DiscoveryServiceFramework {\r\n\r\n  /**\r\n  * To initialise the HypertyDiscover, which will provide the support for hyperties to\r\n  * query users registered in outside the internal core.\r\n  * @param  {MessageBus}          msgbus                msgbus\r\n  * @param  {RuntimeURL}          runtimeURL            runtimeURL\r\n  */\r\n  constructor(hypertyURL, runtimeURL, msgBus) {\r\n    let _this = this;\r\n    _this.messageBus = msgBus;\r\n\r\n    _this.domain = divideURL(runtimeURL).domain;\r\n    _this.discoveryURL = hypertyURL + '/discovery';\r\n    _this.registryURL = runtimeURL + '/registry/';\r\n\r\n  }\r\n\r\n  /**\r\n  * function to request about an dataObject registered in domain registry with a given name, and\r\n  * return the dataObject information, if found.\r\n  * @param  {String}              name  dataObject URL\r\n  * @param  {String}            domain (Optional)\r\n  * @return {Promise}          Promise\r\n  */\r\n  discoverDataObjectPerName(name, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    activeDomain = (!domain) ? _this.domain : domain;\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: _this.registryURL, body: { resource: name}\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let dataObject = reply.body.value;\r\n\r\n        if (dataObject) {\r\n          resolve(dataObject);\r\n        } else {\r\n          reject('DataObject not found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * function to request about dataObject registered in domain registry, and\r\n  * return the dataObject information, if found.\r\n  * @param  {String}              url  dataObject URL\r\n  * @param  {String}            domain (Optional)\r\n  * @return {Promise}          Promise\r\n  */\r\n  discoverDataObjectPerURL(url, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: _this.registryURL, body: { resource: url}\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let dataObject = reply.body.value;\r\n\r\n        if (dataObject) {\r\n          resolve(dataObject);\r\n        } else {\r\n          reject('DataObject not found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  *  function to delete an Data Object registered in the Domain Registry\r\n  *  @param   {String}           url              dataObject url\r\n  *  @param   {domain}           domain         (Optional)\r\n  *  @return  {Promise}          Promise          result\r\n  */\r\n  deleteDataObject(url, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'delete', from: _this.discoveryURL, to: _this.registryURL,  body: { value: {name: url}}};\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let response = reply.body.code;\r\n\r\n        if (response === 200) {\r\n          resolve(response);\r\n        } else {\r\n          reject('Error on deleting dataObject');\r\n        }\r\n      });\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * function to request about specific reporter dataObject registered in domain registry, and\r\n  * return the dataObjects from that reporter.\r\n  * @param  {String}           reporter     dataObject reporter\r\n  * @param  {String}           domain       (Optional)\r\n  * @return {Array}           Promise       DataObjects\r\n  */\r\n  discoverDataObjectPerReporter(reporter, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: _this.registryURL, body: { resource: reporter}\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let dataObjects = reply.body.value;\r\n\r\n        if (dataObjects) {\r\n          resolve(dataObjects);\r\n        } else {\r\n          reject('No dataObject was found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /** Advanced Search for dataObjects registered in domain registry\r\n  * @param  {String}           user                  user identifier, either in url or email format\r\n  * @param  {Array<string>}    schema (Optional)     types of dataObject schemas\r\n  * @param  {Array<string>}    resources (Optional)  types of dataObject resources\r\n  * @param  {String}           domain (Optional)     domain of the registry to search\r\n  */\r\n  discoverDataObject(name, schema, resources, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n    //let userIdentifier = convertToUserURL(user);\r\n\r\n    activeDomain = (!domain) ? _this.domain : domain;\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: _this.registryURL, body: { resource: name,\r\n      criteria: {resources: resources, dataSchemes: schema}\r\n      }\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let hyperties = reply.body.value;\r\n\r\n        if (hyperties) {\r\n          resolve(hyperties);\r\n        } else {\r\n          reject('No DataObject was found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /** Advanced Search for Hyperties registered in domain registry\r\n  * @param  {String}           user                  user identifier, either in url or email format\r\n  * @param  {Array<string>}    schema (Optional)     types of hyperties schemas\r\n  * @param  {Array<string>}    resources (Optional)  types of hyperties resources\r\n  * @param  {String}           domain (Optional)     domain of the registry to search\r\n  */\r\n  discoverHyperty(user, schema, resources, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n    let userIdentifier = convertToUserURL(user);\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'read', from: _this.discoveryURL, to: _this.registryURL, body: { resource: userIdentifier,\r\n      criteria: {resources: resources, dataSchemes: schema}\r\n      }\r\n    };\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let hyperties = reply.body.value;\r\n\r\n        if (hyperties) {\r\n          resolve(hyperties);\r\n        } else {\r\n          reject('No Hyperty was found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * function to request about users registered in domain registry, and\r\n  * return the last hyperty instance registered by the user.\r\n  * @param  {email}              email\r\n  * @param  {domain}            domain (Optional)\r\n  * @return {Promise}          Promise\r\n  */\r\n  discoverHypertyPerUser(email, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\r\n\r\n    // message to query domain registry, asking for a user hyperty.\r\n    let message = {\r\n      type: 'read', from: _this.discoveryURL, to: _this.registryURL, body: { resource: identityURL}\r\n    };\r\n\r\n    console.log('Message: ', message, activeDomain, identityURL);\r\n\r\n    //console.log('message READ', message);\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(message, (reply) => {\r\n        console.log('message reply', reply);\r\n\r\n        let hyperty;\r\n        let mostRecent;\r\n        let lastHyperty;\r\n        let value = reply.body.value;\r\n\r\n        for (hyperty in value) {\r\n          if (value[hyperty].lastModified !== undefined) {\r\n            if (mostRecent === undefined) {\r\n              mostRecent = new Date(value[hyperty].lastModified);\r\n              lastHyperty = hyperty;\r\n            } else {\r\n              let hypertyDate = new Date(value[hyperty].lastModified);\r\n              if (mostRecent.getTime() < hypertyDate.getTime()) {\r\n                mostRecent = hypertyDate;\r\n                lastHyperty = hyperty;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        console.log('Last Hyperty: ', lastHyperty, mostRecent);\r\n\r\n        let hypertyURL = lastHyperty;\r\n\r\n        if (hypertyURL === undefined) {\r\n          return reject('User Hyperty not found');\r\n        }\r\n\r\n        let idPackage = {\r\n          id: email,\r\n          descriptor: value[hypertyURL].descriptor,\r\n          hypertyURL: hypertyURL\r\n        };\r\n\r\n        console.log('===> hypertyDiscovery messageBundle: ', idPackage);\r\n        resolve(idPackage);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * function to request about users registered in domain registry, and\r\n  * return the all the hyperties registered by the user\r\n  * @param  {email}              email\r\n  * @param  {domain}            domain (Optional)\r\n  * @return {Promise}          Promise\r\n  */\r\n  discoverHypertiesPerUser(email, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\r\n\r\n    // message to query domain registry, asking for a user hyperty.\r\n    let message = {\r\n      type: 'read', from: _this.discoveryURL, to: _this.registryURL, body: { resource: identityURL}\r\n    };\r\n\r\n    console.log('Message discoverHypertiesPerUser: ', message, activeDomain, identityURL);\r\n\r\n    //console.log('message READ', message);\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(message, (reply) => {\r\n        console.log('discoverHypertiesPerUser reply', reply);\r\n\r\n        let value = reply.body.value;\r\n\r\n        if (!value) {\r\n          return reject('User Hyperty not found');\r\n        }\r\n\r\n        resolve(value);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  *  function to delete an hypertyInstance in the Domain Registry\r\n  *  @param   {String}           user              user url\r\n  *  @param   {String}           hypertyInstance   HypertyInsntance url\r\n  *  @param   {domain}           domain (Optional)\r\n  *  @return  {Promise}          Promise          result\r\n  */\r\n  deleteHyperty(user, hypertyInstance, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this.domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let msg = {\r\n      type: 'delete', from: _this.discoveryURL, to: _this.registryURL,   body: { value: {user: user, url: hypertyInstance }}};\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.messageBus.postMessage(msg, (reply) => {\r\n\r\n        let response = reply.body.code;\r\n\r\n        if (response) {\r\n          resolve('Hyperty successfully deleted');\r\n        } else {\r\n          reject('Error on deleting hyperty');\r\n        }\r\n      });\r\n    });\r\n\r\n  }\r\n\r\n}\r\n\r\nexport default DiscoveryServiceFramework;\r\n",
    "static": true,
    "longname": "src/registry/DiscoveryServiceFramework.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 454,
    "kind": "class",
    "name": "DiscoveryServiceFramework",
    "memberof": "src/registry/DiscoveryServiceFramework.js",
    "static": true,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/registry/DiscoveryServiceFramework.js",
    "importStyle": "DiscoveryServiceFramework",
    "description": "Core Discovery interface\nClass to allow applications to search for hyperties and DataObjects using the message bus",
    "lineNumber": 30,
    "interface": false
  },
  {
    "__docId__": 455,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#constructor",
    "access": null,
    "description": "To initialise the HypertyDiscover, which will provide the support for hyperties to\nquery users registered in outside the internal core.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "msgbus",
        "description": "msgbus"
      },
      {
        "nullable": null,
        "types": [
          "RuntimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeURL",
        "description": "runtimeURL"
      }
    ]
  },
  {
    "__docId__": 456,
    "kind": "method",
    "name": "discoverDataObjectPerName",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#discoverDataObjectPerName",
    "access": null,
    "description": "function to request about an dataObject registered in domain registry with a given name, and\nreturn the dataObject information, if found.",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "dataObject URL"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise"
    }
  },
  {
    "__docId__": 457,
    "kind": "method",
    "name": "discoverDataObjectPerURL",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#discoverDataObjectPerURL",
    "access": null,
    "description": "function to request about dataObject registered in domain registry, and\nreturn the dataObject information, if found.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "dataObject URL"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise"
    }
  },
  {
    "__docId__": 458,
    "kind": "method",
    "name": "deleteDataObject",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#deleteDataObject",
    "access": null,
    "description": " function to delete an Data Object registered in the Domain Registry",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "dataObject url"
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise          result"
    }
  },
  {
    "__docId__": 459,
    "kind": "method",
    "name": "discoverDataObjectPerReporter",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#discoverDataObjectPerReporter",
    "access": null,
    "description": "function to request about specific reporter dataObject registered in domain registry, and\nreturn the dataObjects from that reporter.",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "reporter",
        "description": "dataObject reporter"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "Promise       DataObjects"
    }
  },
  {
    "__docId__": 460,
    "kind": "method",
    "name": "discoverDataObject",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#discoverDataObject",
    "access": null,
    "description": "Advanced Search for dataObjects registered in domain registry",
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user identifier, either in url or email format"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of dataObject schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of dataObject resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)     domain of the registry to search"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 461,
    "kind": "method",
    "name": "discoverHyperty",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#discoverHyperty",
    "access": null,
    "description": "Advanced Search for Hyperties registered in domain registry",
    "lineNumber": 227,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user identifier, either in url or email format"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of hyperties schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of hyperties resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)     domain of the registry to search"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 462,
    "kind": "method",
    "name": "discoverHypertyPerUser",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#discoverHypertyPerUser",
    "access": null,
    "description": "function to request about users registered in domain registry, and\nreturn the last hyperty instance registered by the user.",
    "lineNumber": 266,
    "params": [
      {
        "nullable": null,
        "types": [
          "email"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise"
    }
  },
  {
    "__docId__": 463,
    "kind": "method",
    "name": "discoverHypertiesPerUser",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#discoverHypertiesPerUser",
    "access": null,
    "description": "function to request about users registered in domain registry, and\nreturn the all the hyperties registered by the user",
    "lineNumber": 338,
    "params": [
      {
        "nullable": null,
        "types": [
          "email"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise"
    }
  },
  {
    "__docId__": 464,
    "kind": "method",
    "name": "deleteHyperty",
    "memberof": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/DiscoveryServiceFramework.js~DiscoveryServiceFramework#deleteHyperty",
    "access": null,
    "description": " function to delete an hypertyInstance in the Domain Registry",
    "lineNumber": 381,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user url"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hypertyInstance",
        "description": "HypertyInsntance url"
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise          result"
    }
  },
  {
    "__docId__": 465,
    "kind": "file",
    "name": "src/registry/HypertyInstance.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\nimport RegistryDataModel from './RegistryDataModel';\r\n\r\n/**\r\n*   @author: Gil Dias (gil.dias@tecnico.ulisboa.pt)\r\n*   HypertyInstance Data Model used to model instances of Hyperties running in devices and servers.\r\n*/\r\nclass HypertyInstance extends RegistryDataModel {\r\n\r\n  constructor(id, url, descriptorURL, descriptor, hypertyURL, user, guid, runtime, context, p2pHandler, p2pRequester, dataSchemes, resources, startingTime, lastModified) {\r\n    super(id, url, descriptorURL, p2pRequester, startingTime, lastModified);\r\n    let _this = this;\r\n    _this._descriptor = descriptor;\r\n    _this._hypertyURL = hypertyURL;\r\n    _this._user = user;\r\n    _this._guid = guid;\r\n    _this._runtime = runtime;\r\n    _this._context = context;\r\n    _this._p2pHandler = p2pHandler;\r\n    _this._dataSchemes = dataSchemes;\r\n    _this._resources = resources;\r\n  }\r\n\r\n  set user(identity) {\r\n    let _this = this;\r\n    _this.user = identity;\r\n  }\r\n\r\n  get user() {\r\n    let _this = this;\r\n    return _this._user;\r\n  }\r\n\r\n  get hypertyURL() {\r\n    let _this = this;\r\n    return _this._hypertyURL;\r\n  }\r\n\r\n  get descriptor() {\r\n    let _this = this;\r\n    return _this._descriptor;\r\n  }\r\n\r\n  get objectName() {\r\n    let _this = this;\r\n    return _this._descriptor._objectName;\r\n  }\r\n\r\n  get p2pHandler() {\r\n    let _this = this;\r\n    return _this._p2pHandler;\r\n  }\r\n\r\n  get dataSchemes() {\r\n    let _this = this;\r\n    return _this._dataSchemes;\r\n  }\r\n\r\n  get resources() {\r\n    let _this = this;\r\n    return _this._resources;\r\n  }\r\n\r\n  get runtimeURL() {\r\n    let _this = this;\r\n    return _this._runtime;\r\n  }\r\n}\r\n\r\nexport default HypertyInstance;\r\n",
    "static": true,
    "longname": "src/registry/HypertyInstance.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 466,
    "kind": "class",
    "name": "HypertyInstance",
    "memberof": "src/registry/HypertyInstance.js",
    "static": true,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/registry/HypertyInstance.js",
    "importStyle": "HypertyInstance",
    "description": "  @author: Gil Dias (gil.dias@tecnico.ulisboa.pt)\n  HypertyInstance Data Model used to model instances of Hyperties running in devices and servers.",
    "lineNumber": 29,
    "interface": false,
    "extends": [
      "src/registry/RegistryDataModel.js~RegistryDataModel"
    ]
  },
  {
    "__docId__": 467,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#constructor",
    "access": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "id",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "descriptorURL",
        "types": [
          "*"
        ]
      },
      {
        "name": "descriptor",
        "types": [
          "*"
        ]
      },
      {
        "name": "hypertyURL",
        "types": [
          "*"
        ]
      },
      {
        "name": "user",
        "types": [
          "*"
        ]
      },
      {
        "name": "guid",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtime",
        "types": [
          "*"
        ]
      },
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2pHandler",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2pRequester",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataSchemes",
        "types": [
          "*"
        ]
      },
      {
        "name": "resources",
        "types": [
          "*"
        ]
      },
      {
        "name": "startingTime",
        "types": [
          "*"
        ]
      },
      {
        "name": "lastModified",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 468,
    "kind": "set",
    "name": "user",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#user",
    "access": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 469,
    "kind": "get",
    "name": "user",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#user",
    "access": null,
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 470,
    "kind": "get",
    "name": "hypertyURL",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#hypertyURL",
    "access": null,
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 471,
    "kind": "get",
    "name": "descriptor",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#descriptor",
    "access": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 472,
    "kind": "get",
    "name": "objectName",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#objectName",
    "access": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 473,
    "kind": "get",
    "name": "p2pHandler",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#p2pHandler",
    "access": null,
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 474,
    "kind": "get",
    "name": "dataSchemes",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#dataSchemes",
    "access": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 475,
    "kind": "get",
    "name": "resources",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#resources",
    "access": null,
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 476,
    "kind": "get",
    "name": "runtimeURL",
    "memberof": "src/registry/HypertyInstance.js~HypertyInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/HypertyInstance.js~HypertyInstance#runtimeURL",
    "access": null,
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 477,
    "kind": "file",
    "name": "src/registry/Registry.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\nimport { runtimeUtils } from '../runtime/runtimeUtils';\r\n\r\nimport AddressAllocation from '../allocation/AddressAllocation';\r\nimport HypertyInstance from './HypertyInstance';\r\n\r\nimport {MessageFactory} from 'service-framework/dist/MessageFactory';\r\nimport {divideURL, isHypertyURL, isURL, isUserURL, generateGUID, getUserIdentityDomain, isBackendServiceURL} from '../utils/utils.js';\r\n\r\nimport Discovery from './Discovery';\r\n\r\n// import DiscoveryServiceFramework from './DiscoveryServiceFramework';\r\n\r\nconst STATUS = { CREATED: 'created', LIVE: 'live', DEPLOYED: 'deployed', PROGRESS: 'in-progress', DISCONNECTED: 'disconnected', DEAD: 'dead' };\r\n\r\n/*import IdentityManager from './IdentityManager';\r\nimport Discovery from './Discovery';*/\r\n\r\n/**\r\n* Runtime Registry Interface\r\n*/\r\nclass Registry {\r\n\r\n  /**\r\n  * To initialise the Runtime Registry with the RuntimeURL that will be the basis to derive the internal runtime addresses when allocating addresses to internal runtime component. In addition, the Registry domain back-end to be used to remotely register Runtime components, is also passed as input parameter.\r\n  * @param  {MessageBus}          msgbus                msgbus\r\n  * @param  {HypertyRuntimeURL}   runtimeURL            runtimeURL\r\n  * @param  {AppSandbox}          appSandbox            appSandbox\r\n  * @param  {runtimeCatalogue}    runtimeCatalogue      runtimeCatalogue\r\n  * @param  {DomainURL}           remoteRegistry        remoteRegistry\r\n  * @param  {storageManager}      storageManager\r\n  */\r\n  constructor(runtimeURL, appSandbox, identityModule, runtimeCatalogue, runtimeCapabilities, storageManager, remoteRegistry) {\r\n\r\n    // how some functions receive the parameters for example:\r\n    // new Registry('hyperty-runtime://sp1/123', appSandbox, idModule, remoteRegistry);\r\n    // registry.registerStub(sandbox, 'sp1');\r\n    // registry.registerHyperty(sandBox, 'hyperty-runtime://sp1/123');\r\n    // registry.resolve('hyperty-runtime://sp1/123');\r\n\r\n    if (!runtimeURL) throw new Error('runtimeURL is missing.');\r\n    if (!storageManager) throw new Error('storageManager is missing.');\r\n\r\n    /*if (!remoteRegistry) throw new Error('remoteRegistry is missing');*/\r\n\r\n    let _this = this;\r\n\r\n    _this.registryURL = runtimeURL + '/registry/';\r\n    _this.appSandbox = appSandbox;\r\n    _this.runtimeURL = runtimeURL;\r\n    _this.runtimeCatalogue = runtimeCatalogue;\r\n    _this.remoteRegistry = remoteRegistry;\r\n    _this.idModule = identityModule;\r\n    _this.storageManager = storageManager;\r\n    _this.runtimeCapabilities = runtimeCapabilities;\r\n    _this.identifier = generateGUID();\r\n\r\n    // the expires in 3600, represents 1 hour\r\n    //the expires is in seconds, unit of measure received by the domain registry\r\n    _this.expiresTime = 3600;\r\n\r\n    _this.hypertiesListToRemove = {};\r\n    _this.hypertiesList = [];\r\n    _this.remoteHypertyList = [];\r\n    _this.idpLegacyProxyList = {};\r\n\r\n    _this.p2pHandlerStub = {};\r\n    _this.p2pRequesterStub = {};\r\n    _this.p2pConnectionList = {};\r\n    _this.p2pHandlerAssociation = {};\r\n\r\n    _this.protostubsList = {};\r\n    _this.idpProxyList = {};\r\n    _this.dataObjectList = {};\r\n    _this.subscribedDataObjectList = {};\r\n    _this.sandboxesList = {sandbox: {}, appSandbox: {} };\r\n    _this.pepList = {};\r\n    _this.registries = {};\r\n\r\n    _this._domain = divideURL(_this.registryURL).domain;\r\n    _this.sandboxesList.appSandbox[runtimeURL] = appSandbox;\r\n    let msgFactory = new MessageFactory('false', '{}');\r\n    _this.messageFactory = msgFactory;\r\n  }\r\n\r\n  set loader(loader) {\r\n    let _this = this;\r\n    _this._loader = loader;\r\n  }\r\n\r\n  get loader() {\r\n    let _this = this;\r\n    return _this._loader;\r\n  }\r\n\r\n  /**\r\n  * return the messageBus in this Registry\r\n  * @param {MessageBus}           messageBus\r\n  */\r\n  get messageBus() {\r\n    let _this = this;\r\n    return _this._messageBus;\r\n  }\r\n\r\n  /**\r\n  * Set the messageBus in this Registry\r\n  * @param {MessageBus}           messageBus\r\n  */\r\n  set messageBus(messageBus) {\r\n    let _this = this;\r\n    _this._messageBus = messageBus;\r\n\r\n    _this._messageBus.addListener(_this.registryURL, function(msg) {\r\n\r\n      console.log('[Registry listener] ', msg);\r\n\r\n      let isHyperty = isHypertyURL(msg.from);\r\n      let isDiscovery = msg.from.substring(msg.from.length - 10, msg.from.length) === '/discovery';\r\n\r\n      let hasCriteria = msg.body.hasOwnProperty('criteria');\r\n      let isURLResource;\r\n      let isUserResource;\r\n      let isHypertyResource;\r\n\r\n      if (msg.body.hasOwnProperty('resource') && msg.body.resource !== '.') {\r\n        isURLResource = isURL(msg.body.resource);\r\n        isUserResource = isUserURL(msg.body.resource);\r\n        isHypertyResource = isHypertyURL(msg.body.resource);\r\n      }\r\n      let isDelete = msg.type === 'delete';\r\n      let hasName;\r\n      let hasUser;\r\n\r\n      if (msg.body.hasOwnProperty('value')) {\r\n        hasName = msg.body.value.hasOwnProperty('name');\r\n        hasUser = msg.body.value.hasOwnProperty('user');\r\n      }\r\n\r\n      if (isHyperty && isDiscovery) {\r\n        console.log('[Registry] hypertyDiscovery');\r\n        if (isDelete && hasName) {\r\n          console.log('[Registry] deleteDataObject');\r\n        } else if (isDelete && hasUser) {\r\n          console.log('[Registry] deleteHyperty');\r\n        } else if (hasCriteria && isUserResource) {\r\n          console.log('discoverHyperty');\r\n          for (let i in _this.remoteHypertyList) {\r\n            let hyperty = _this.remoteHypertyList[i];\r\n            if (JSON.stringify(hyperty.resources) === JSON.stringify(msg.body.criteria.resources) &&\r\n              JSON.stringify(hyperty.dataSchemes) === JSON.stringify(msg.body.criteria.dataSchemes) &&\r\n              hyperty.user.userURL === msg.body.resource) {\r\n              let url = hyperty.url;\r\n              let valueJson = {};\r\n              valueJson[url] = hyperty.info;\r\n              let message = {\r\n                type: 'response',\r\n                to: msg.from,\r\n                from: msg.to,\r\n                body: {\r\n                  value: valueJson\r\n                }\r\n              };\r\n              return _this._messageBus.postMessage(message);\r\n            }\r\n          }\r\n\r\n          _this.discovery.discoverHyperty(msg.body.resource, msg.body.criteria.dataSchemes, msg.body.criteria.resources).then((value) => {\r\n            let mostRecentHyperty;\r\n            Object.keys(value).forEach(function(a) {\r\n              let hyperty = new HypertyInstance(undefined, undefined, value[a].descriptor, undefined, a, { userURL: value[a].userID },\r\n                'guid', _this.runtimeURL, 'ctx', value[a].p2pHandler, value[a].p2pRequester, value[a].dataSchemes, value[a].resources,\r\n                value[a].startingTime, value[a].lastModified);\r\n              hyperty.info = value;\r\n              if (!mostRecentHyperty) {\r\n                mostRecentHyperty = hyperty;\r\n              } else {\r\n                let hypertyDate = new Date(hyperty.lastModified);\r\n                let mostRecentHypertyDate = new Date(mostRecentHyperty.lastModified);\r\n\r\n                if (hypertyDate > mostRecentHypertyDate) {\r\n                  mostRecentHyperty = hyperty;\r\n                  console.log('update date');\r\n                }\r\n              }\r\n            });\r\n\r\n            if (mostRecentHyperty) {\r\n              console.log('push');\r\n              _this.remoteHypertyList.push(mostRecentHyperty);\r\n            }\r\n          });\r\n\r\n        } else if (hasCriteria && !isURLResource) {\r\n          console.log('[Registry] discoverDataObject');\r\n        } else if (isHypertyResource) {\r\n          console.log('[Registry] discoverDataObjectPerReporter');\r\n        } else if (isUserResource) {\r\n          console.log('[Registry] discoverHypertyPerUser');\r\n        } else if (isURLResource) {\r\n          console.log('[Registry] discoverDataObjectPerURL');\r\n        } else if (!isURLResource) {\r\n          console.log('[Registry] discoverDataObjectPerName');\r\n        }\r\n\r\n      } else {\r\n\r\n        //hack to skip responses to responses\r\n\r\n        if (msg.type === 'response') {\r\n          console.error('[Register listener] skipping ', msg);\r\n          return;\r\n        }\r\n\r\n        // msg sent by identity manager library\r\n        let userUrl = _this._getIdentityAssociated(msg.body.resource, msg.body.criteria);\r\n\r\n        let reply = {id: msg.id, type: 'response', to: msg.from, from: msg.to, body: {resource: userUrl}};\r\n        reply.body.code = (userUrl) ? 200 : 404;\r\n\r\n        _this._messageBus.postMessage(reply);\r\n      }\r\n    });\r\n\r\n    // also set up messageBus in the IdentityModule component\r\n    // TODO redefine a better way to add the messageBus in the IdModule\r\n    _this.idModule.messageBus = messageBus;\r\n\r\n    // Install AddressAllocation\r\n    let addressAllocation = AddressAllocation.instance;\r\n    _this.addressAllocation = addressAllocation;\r\n    console.log('[Registry - AddressAllocation] - ', addressAllocation);\r\n\r\n    let discovery = new Discovery(_this.runtimeURL, messageBus);\r\n    _this.discovery = discovery;\r\n\r\n    // TODO what is this? this should be removed;\r\n    /*let discoveryServiceFramework = new DiscoveryServiceFramework('hyperty://localhost/123', _this.runtimeURL, messageBus);\r\n    _this.discoveryServiceFramework = discoveryServiceFramework;*/\r\n\r\n  }\r\n\r\n  /**\r\n  * function to request about users registered in domain registry, and\r\n  * return the last hyperty instance registered by the user.\r\n  * @param  {email}              email\r\n  * @param  {domain}            domain (Optional)\r\n  * @return {Promise}          Promise\r\n  */\r\n\r\n  // TODO: implement a cache system\r\n  discoverHypertyPerUser(email, domain) {\r\n    let _this = this;\r\n    let activeDomain;\r\n\r\n    if (!domain) {\r\n      activeDomain = _this._domain;\r\n    } else {\r\n      activeDomain = domain;\r\n    }\r\n\r\n    let identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\r\n\r\n    // message to query domain registry, asking for a user hyperty.\r\n    let message = {\r\n      type: 'read', from: _this.registryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: identityURL}\r\n    };\r\n\r\n    console.log('[Registry] Message: ', message, activeDomain, identityURL);\r\n\r\n    //console.log('[Registry] message READ', message);\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this._messageBus.postMessage(message, (reply) => {\r\n        console.log('[Registry] message reply', reply);\r\n\r\n        let hyperty;\r\n        let mostRecent;\r\n        let lastHyperty;\r\n        let value = reply.body.value;\r\n\r\n        for (hyperty in value) {\r\n          if (value[hyperty].lastModified !== undefined) {\r\n            if (mostRecent === undefined) {\r\n              mostRecent = new Date(value[hyperty].lastModified);\r\n              lastHyperty = hyperty;\r\n            } else {\r\n              let hypertyDate = new Date(value[hyperty].lastModified);\r\n              if (mostRecent.getTime() < hypertyDate.getTime()) {\r\n                mostRecent = hypertyDate;\r\n                lastHyperty = hyperty;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        console.log('[Registry] Last Hyperty: ', lastHyperty, mostRecent);\r\n\r\n        let hypertyURL = lastHyperty;\r\n\r\n        if (hypertyURL === undefined) {\r\n          return reject('User Hyperty not found');\r\n        }\r\n\r\n        let idPackage = {\r\n          id: email,\r\n          descriptor: value[hypertyURL].descriptor,\r\n          hypertyURL: hypertyURL\r\n        };\r\n\r\n        console.log('[Registry] ===> hypertyDiscovery messageBundle: ', idPackage);\r\n        resolve(idPackage);\r\n      });\r\n    });\r\n  }\r\n\r\n  _getIdentityAssociated(type, hypertyURL) {\r\n    let _this = this;\r\n\r\n    for (let hyperty in _this.hypertiesList) {\r\n      let value = _this.hypertiesList[hyperty];\r\n      if (value._hypertyURL === hypertyURL) {\r\n        switch (type) {\r\n          case 'username':\r\n            return value._user.username;\r\n          case 'cn':\r\n            return value._user.cn;\r\n          case 'locale':\r\n            return value._user.locale;\r\n          case 'avatar':\r\n            return value._user.avatar;\r\n          case 'userURL':\r\n            return value._user.userURL;\r\n          case '.':\r\n            return value._user;\r\n          default:\r\n            return '';\r\n        }\r\n      }\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n  * query the domain registry for information from a dataObject URL\r\n  * @param  {String}   url            dataObject URL\r\n  * @return {JSON}     dataObject     data object\r\n  */\r\n  discoverDataObjectPerURL(url, domain) {\r\n\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let activeDomain;\r\n\r\n      if (!domain) {\r\n        activeDomain = _this._domain;\r\n      } else {\r\n        activeDomain = domain;\r\n      }\r\n\r\n      let msg = {\r\n        type: 'read', from: _this.registryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: url }\r\n      };\r\n\r\n      _this._messageBus.postMessage(msg, (reply) => {\r\n\r\n        let dataObject = reply.body.value;\r\n\r\n        if (dataObject) {\r\n          resolve(dataObject);\r\n        } else {\r\n          reject('DataObject not found');\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * This function is used to return the sandbox instance where the Application is executing. It is assumed there is just one App per Runtime instance.\r\n  */\r\n  getAppSandbox() {\r\n    let _this = this;\r\n    return _this.appSandbox;\r\n  }\r\n\r\n  /**\r\n  * This function returns the user associated to the hyperty URL\r\n  * @param    {String}    hypertyURL      hyperty URL\r\n  * @return   {String}    userURL         user URL\r\n  */\r\n  getHypertyOwner(hypertyURL) {\r\n\r\n    let _this = this;\r\n    let userURL;\r\n\r\n    for (let index in _this.hypertiesList) {\r\n      let hyperty = _this.hypertiesList[index];\r\n      if (hyperty.hypertyURL === hypertyURL) {\r\n        userURL = hyperty.user.userURL;\r\n      }\r\n    }\r\n    return userURL;\r\n  }\r\n\r\n  /**\r\n  * returns the hyperty Name from a given url. This url could be from a dataObject or hyperty\r\n  * @param    {String}    url      hyperty or dataObject URL\r\n  * @return   {String}    hypertyName     hyperty Name\r\n  */\r\n  getHypertyName(url) {\r\n    let _this = this;\r\n\r\n    let isHypertyURL = divideURL(url).type === 'hyperty';\r\n\r\n    //value to be returned in the end\r\n    let hypertyName;\r\n\r\n    //if is not an hyperty, check if is a dataObject and obtain his reporter\r\n    let hypertyURL = (isHypertyURL) ? hypertyURL = url : _this.getReporterURLSynchonous(url);\r\n\r\n    for (let index in _this.hypertiesList) {\r\n      let hyperty = _this.hypertiesList[index];\r\n      if (hyperty.hypertyURL === hypertyURL) {\r\n        hypertyName = hyperty.objectName;\r\n        break;\r\n      }\r\n    }\r\n    return hypertyName;\r\n  }\r\n\r\n  /**\r\n  * function to return the reporterURL associated with the dataobject URL\r\n  * @param    {String}     dataObjectURL    dataObjectURL\r\n  * @return   {String}     reporterURL      reporterURL\r\n  */\r\n  getReporterURL(dataObjectURL) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let dataObject = _this.dataObjectList[dataObjectURL];\r\n\r\n      if (dataObject) {\r\n        resolve(dataObject.reporter);\r\n      } else {\r\n        reject('No reporter was found');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n  * function to return the reporterURL associated with the dataobject URL. no promise returned\r\n  * @param    {String}     dataObjectURL    dataObjectURL\r\n  * @return   {String}     reporterURL      reporterURL\r\n  */\r\n  getReporterURLSynchonous(dataObjectURL) {\r\n    let _this = this;\r\n\r\n    let dataObject = _this.dataObjectList[dataObjectURL];\r\n\r\n    return (dataObject) ? dataObject.reporter : undefined;\r\n  }\r\n\r\n  /**\r\n  * returns the hyperty URL that subscribed the dataObject\r\n  * @param    {String}     url            url format\r\n  * @return   {String}    Hyperty URL subscribed to the URL\r\n  */\r\n  getDataObjectSubscriberHyperty(url) {\r\n    let _this = this;\r\n\r\n    return _this.subscribedDataObjectList[url];\r\n  }\r\n\r\n  /**\r\n  * register a desired dataObject to subscribe\r\n  * @param    {String}    dataObjectURL      dataObject URL\r\n  */\r\n  registerSubscribedDataObject(dataObjectURL, hypertyURL) {\r\n    let _this = this;\r\n    if (_this.subscribedDataObjectList[dataObjectURL] === undefined) {\r\n      _this.subscribedDataObjectList[dataObjectURL] = hypertyURL;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Function to return the list of pre authorised users received in the creation of a data object\r\n  * @param    {String}            dataObjectURL    dataObjectURL\r\n  * @return   {Array<String>}     preAuth         List of pre authorised users\r\n  */\r\n  getPreAuthSubscribers(dataObjectURL) {\r\n    let _this = this;\r\n    let dataObject = _this.dataObjectList[dataObjectURL];\r\n    let preAuth = [];\r\n\r\n    if (dataObject) {\r\n      preAuth = dataObject.preAuth;\r\n    }\r\n    return preAuth;\r\n  }\r\n\r\n  /**\r\n  * send requests to unregister all hyperties registered in domain registry\r\n  * @return   {Promise}     return a promise if the result of unregistration all hyperties\r\n  */\r\n  unregisterAllHyperties() {\r\n    let _this = this;\r\n\r\n    let unregisterResults = [];\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      for (let index in _this.hypertiesList) {\r\n        let hyperty = _this.hypertiesList[index];\r\n        let result = _this.unregisterHypertyInstance(hyperty.user.userURL, hyperty.hypertyURL);\r\n        unregisterResults.push(result);\r\n      }\r\n\r\n      Promise.all(unregisterResults).then(() => {\r\n\r\n        resolve('successfully unregistered all hyperties');\r\n      }, error => { reject(error); });\r\n    });\r\n  }\r\n\r\n  /**\r\n  *  function to unregister an hypertyInstance in the Domain Registry\r\n  *  @param   {String}      user        user url\r\n  *  @param   {String}      hypertyInstance   HypertyInsntance url\r\n  *\r\n  */\r\n  unregisterHypertyInstance(user, hypertyInstance) {\r\n    //TODO working but the user\r\n    let _this = this;\r\n\r\n    let message = { type: 'delete', from: _this.registryURL,\r\n      to: 'domain://registry.' + _this._domain + '/',\r\n      body: { value: {user: user, url: hypertyInstance }}};\r\n\r\n    _this._messageBus.postMessage(message, (reply) => {\r\n      console.log('[Registry] unregister hyperty Reply', reply);\r\n    });\r\n  }\r\n\r\n  /**\r\n  *  function to delete an dataObjectInstance in the Domain Registry\r\n  *  @param   {String}    name      DataObjectName\r\n  */\r\n  deleteDataObjectInstance(name) {\r\n    let _this = this;\r\n\r\n    let message = { type: 'delete', from: _this.registryURL,\r\n      to: 'domain://registry.' + _this._domain + '/',\r\n      body: { value: {name: name}}};\r\n\r\n    _this._messageBus.postMessage(message, (reply) => {\r\n      console.log('[Registry] unregister dataObject Reply', reply);\r\n    });\r\n  }\r\n\r\n  /**\r\n  * Function to update an Hyperty\r\n  */\r\n  updateHypertyInstance(resource, value) {\r\n    let _this = this;\r\n\r\n    let message = { type: 'UPDATE', from: _this.registryURL,\r\n      to: 'domain://registry.' + _this._domain + '/',\r\n      body: { resource: resource, value: value}};\r\n\r\n    _this._messageBus.post.postMessage(message, (reply) => {\r\n      console.log('[Registry] Updated hyperty reply', reply);\r\n    });\r\n  }\r\n\r\n  /**\r\n  * register a new subscriber in the dataObject registered\r\n  * @param  {String}   dataObjectURL    dataObject URL\r\n  * @param  {String}   subscriberURL    subscriber URL\r\n  */\r\n  registerSubscriber(dataObjectURL, subscriberURL) {\r\n    let _this = this;\r\n    let dataObject = _this.dataObjectList[dataObjectURL];\r\n\r\n    if (dataObject) {\r\n      dataObject.subscribers.push(subscriberURL);\r\n      _this.dataObjectList[dataObjectURL] = dataObject;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * get the subscribers registered within a dataObject\r\n  * @param  {String}          dataObjectURL    dataObject URL\r\n  * @param  {Array<String>}   Substribers List\r\n  */\r\n  getDataObjectSubscribers(dataObjectURL) {\r\n    let _this = this;\r\n    let dataObject = _this.dataObjectList[dataObjectURL];\r\n\r\n    if (dataObject) {\r\n      return dataObject.subscribers;\r\n    } else {\r\n      throw 'No dataObject was found';\r\n    }\r\n  }\r\n\r\n  /**\r\n  * To register a new Data Object in the runtime which returns the dataObjectURL allocated to the new Data Object.\r\n  * @param  {String}      identifier                  identifier\r\n  * @param  {String}      dataObjectschema            dataObjectschema\r\n  * @param  {String}      dataObjectUrl               dataObjectUrl\r\n  * @param {String}      dataObjectReporter           dataObjectReporter\r\n  * @param  {Array}     resources                     dataObject resources\r\n  * @param  {Array}     authorise                     list of pre authorised authorised IDs\r\n  */\r\n  registerDataObject(identifier, dataObjectschema, dataObjectUrl, dataObjectReporter, resources, addressURL, authorise) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let dataScheme = [];\r\n      let filteredDataScheme = dataObjectUrl.split(':');\r\n      dataScheme.push(filteredDataScheme[0]);\r\n\r\n      _this.storageManager.get('registry:DataObjectURLs').then((urlsList) => {\r\n\r\n        if (!urlsList) {\r\n          urlsList = {};\r\n        }\r\n\r\n        //update the list with the new elements\r\n        urlsList[identifier + dataObjectschema + resources + dataObjectReporter] = addressURL.address;\r\n\r\n        let p2pHandler;\r\n        let p2pRequester;\r\n\r\n        if (Object.keys(_this.p2pHandlerStub).length !== 0) {\r\n          p2pHandler = _this.p2pHandlerStub[_this.runtimeURL].url;\r\n          p2pRequester = runtimeUtils.runtimeDescriptor.p2pRequesterStub;\r\n        }\r\n\r\n        let runtime = _this.runtimeURL;\r\n        let status = 'live';\r\n\r\n        //message to register the new hyperty, within the domain registry\r\n        let messageValue = {\r\n          name: identifier,\r\n          resources: resources,\r\n          dataSchemes: dataScheme,\r\n          schema: dataObjectschema,\r\n          url: dataObjectUrl,\r\n          expires: _this.expiresTime,\r\n          reporter: dataObjectReporter,\r\n          preAuth: authorise,\r\n          subscribers: [],\r\n          runtime: runtime,\r\n          status: status\r\n        };\r\n\r\n        if (p2pHandler) {\r\n          messageValue.p2pHandler = p2pHandler;\r\n          messageValue.p2pRequester = p2pRequester;\r\n        }\r\n\r\n        if (_this.isInterworkingProtoStub(dataObjectReporter)) {\r\n          messageValue.interworking = true;\r\n        }\r\n\r\n        let message;\r\n\r\n        if (addressURL.newAddress) {\r\n\r\n          console.log('[Registry] registering new data object URL', dataObjectUrl);\r\n\r\n          message = {type: 'create', from: _this.registryURL, to: 'domain://registry.' + _this.registryDomain + '/', body: {value: messageValue, policy: 'policy'}};\r\n\r\n        } else {\r\n\r\n          console.log('[Registry] registering previously registered data object URL', dataObjectUrl);\r\n\r\n          /*messageValue = {name: identifier, resources: resources, dataSchemes: dataScheme, schema: dataObjectschema, url: dataObjectUrl, expires: _this.expiresTime, reporter: dataObjectReporter, preAuth: authorise, subscribers: []};\r\n\r\n          message = {type:'create', from: _this.registryURL, to: 'domain://registry.' + _this.registryDomain + '/', body: {value: messageValue, policy: 'policy'}};*/\r\n\r\n          message = {\r\n            type: 'update',\r\n            to: 'domain://registry.' + _this.registryDomain + '/',\r\n            from: _this.registryURL,\r\n            body: {resource: dataObjectUrl, value: {status: 'live'} }\r\n          };\r\n\r\n        }\r\n\r\n        _this.dataObjectList[dataObjectUrl] = messageValue;\r\n\r\n        // step to obtain the list of all URL registered to updated with the new one.\r\n        _this.storageManager.set('registry:DataObjectURLs', 0, urlsList).then(() => {\r\n\r\n          /*let message = _this.messageFactory.createCreateMessageRequest(\r\n            _this.registryURL,\r\n            'domain://registry.' + _this.registryDomain + '/',\r\n            messageValue,\r\n            'policy'\r\n          );*/\r\n\r\n          _this._messageBus.postMessage(message, (reply) => {\r\n            console.log('[Registry] ===> registerDataObject Reply: ', reply);\r\n            if (reply.body.code === 200) {\r\n              resolve('ok');\r\n            } else {\r\n              reject('error on register DataObject');\r\n            }\r\n          });\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  _getResourcesAndSchemes(descriptor) {\r\n    let _this = this;\r\n\r\n    return new Promise((resolve)=> {\r\n\r\n      let resources;\r\n\r\n      // check if the hyperty resources is a vector or a string\r\n      // TODO delete later when catalogue is fixed\r\n      if (typeof (descriptor.hypertyType) === 'string') {\r\n        resources = [];\r\n        resources.push(descriptor.hypertyType);\r\n      } else {\r\n        resources = descriptor.hypertyType;\r\n      }\r\n\r\n      let descriptorDataSchema = descriptor.dataObjects;\r\n      let dataSchemasArray = [];\r\n\r\n      //this will create a array with a Promise in each position\r\n      for (let index in descriptorDataSchema) {\r\n        dataSchemasArray.push(_this.runtimeCatalogue.getDataSchemaDescriptor(descriptorDataSchema[index]));\r\n      }\r\n\r\n      // as soon as the previous array is completed, this will wait for the resolve of all promises in the array\r\n      Promise.all(dataSchemasArray).then(function(dataSchemas) {\r\n\r\n        let filteredDataSchemas = [];\r\n        for (let index in dataSchemas) {\r\n          let dataSchema = dataSchemas[index];\r\n          filteredDataSchemas.push(dataSchema.sourcePackage.sourceCode.properties.scheme.constant);\r\n        }\r\n\r\n        console.log('[Registry] Hyperty Schemas', filteredDataSchemas);\r\n        console.log('[Registry] Hyperty resources', resources);\r\n\r\n        resolve({resources: resources, dataSchema: filteredDataSchemas});\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * method that returns previously registered Hyperty or DataObjects URLS, for given characteristics\r\n  * @param  {JSON}        info           object or hyperty charateristics info\r\n  * @return {addressURL}  addressURL     return the URL if there is any previousy registered URL, return undefined otherwise\r\n  */\r\n  checkRegisteredURLs(info, reuseURL) {\r\n    let _this = this;\r\n\r\n    return new Promise((resolve) => {\r\n\r\n      let objectType = (info.reporter) ? 'registry:DataObjectURLs' : 'registry:HypertyURLs';\r\n\r\n      if (typeof(reuseURL) === 'string') {\r\n        objectType = reuseURL && divideURL(reuseURL).type !== 'hyperty' ? 'registry:DataObjectURLs' : 'registry:HypertyURLs';\r\n      }\r\n\r\n      _this.storageManager.get(objectType).then((urlsList) => {\r\n\r\n        if (!urlsList) {\r\n          urlsList = {};\r\n        }\r\n\r\n        if (typeof(reuseURL) === 'string') {\r\n          console.info('[Registry - checkRegisteredURLs] - look for ' + reuseURL + ' on ', urlsList);\r\n\r\n          let searchResult = Object.keys(urlsList).map((key) => {\r\n            let indexOf = urlsList[key].indexOf(reuseURL);\r\n            return urlsList[key][indexOf];\r\n          });\r\n\r\n          console.info('[Registry - checkRegisteredURLs] - found ' + searchResult.length + ' results on ', searchResult);\r\n          if (searchResult.length === 1) {\r\n            return resolve(searchResult);\r\n          } else {\r\n            return resolve(undefined);\r\n          }\r\n        }\r\n\r\n        if (objectType === 'registry:HypertyURLs') {\r\n          _this._getResourcesAndSchemes(info).then((value) => {\r\n            if (urlsList[value.resources + value.dataSchema]) {\r\n              console.log('[Registry] reusage of hyperty URL');\r\n              return resolve(urlsList[value.resources + value.dataSchema]);\r\n            } else {\r\n              console.log('[Registry] no hyperty URL was previously registered ');\r\n              return resolve(undefined);\r\n            }\r\n          });\r\n        } else {\r\n\r\n          let characteristics = info.name + info.schema + info.resources + info.reporter;\r\n\r\n          if (urlsList[characteristics]) {\r\n            console.log('[Registry] reusage of dataObject URL');\r\n            return resolve(urlsList[characteristics]);\r\n          } else {\r\n            console.log('[Registry] no dataObject URL was previously registered');\r\n            return resolve(undefined);\r\n          }\r\n        }\r\n\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  checkHypertyP2PHandler(hypertyURL) {\r\n    let _this = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      let hyperty;\r\n\r\n      for (let i in _this.remoteHypertyList) {\r\n        hyperty = _this.remoteHypertyList[i];\r\n\r\n        console.log('[Registry - checkHypertyP2PHandler] - for each Hyperty: ', hyperty);\r\n\r\n        if (hyperty.hypertyURL === hypertyURL) {\r\n\r\n          if (hyperty.hasOwnProperty('p2pHandler')) {\r\n            resolve({\r\n              p2pHandler: hyperty.p2pHandler,\r\n              p2pRequester: hyperty.p2pRequester,\r\n              runtimeURL: hyperty.runtimeURL\r\n            });\r\n          } else {\r\n            reject('[Registry checkHypertyP2PHandler] Hyperty found does not support P2P', hyperty);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!hyperty) {\r\n        console.log('[Registry - checkHypertyP2PHandler] - Hyperty: ', hyperty);\r\n\r\n        let message = {\r\n          type: 'read',\r\n          from: _this.registryURL,\r\n          to: 'domain://registry.' + _this._domain + '/',\r\n          body: {\r\n            resource: hypertyURL\r\n          }\r\n        };\r\n\r\n        _this._messageBus.postMessage(message, (reply) => {\r\n          console.log('discover hyperty per url reply', reply);\r\n          if ('value' in reply.body) {\r\n\r\n            //todo: store retrieved hyperty\r\n            let resolvedHyperty = reply.body.value;\r\n\r\n            if (resolvedHyperty.hasOwnProperty('p2pHandler')) {\r\n              resolve({\r\n                p2pHandler: resolvedHyperty.p2pHandler,\r\n                p2pRequester: resolvedHyperty.p2pRequester,\r\n                runtimeURL: resolvedHyperty.runtime\r\n              });\r\n            } else {\r\n              reject('[Registry checkHypertyP2PHandler] Hyperty found does not support P2P', reply.body.value);\r\n            }\r\n\r\n          } else {\r\n            reject('Hyperty with P2PHandler not found', reply.body.code);\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n  * To register a new Hyperty in the runtime which returns the HypertyURL allocated to the new Hyperty.\r\n  * @param  {Sandbox}             sandbox               sandbox\r\n  * @param  {HypertyCatalogueURL} HypertyCatalogueURL   descriptor\r\n  * @return {HypertyURL}          HypertyURL\r\n  */\r\n  registerHyperty(sandbox, descriptorURL, descriptor, addressURL) {\r\n    let _this = this;\r\n\r\n    let hypertyCapabilities;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      //assuming descriptor come in this format, the service-provider-domain url is retrieved by a split instruction\r\n      //hyperty-catalogue://<service-provider-domain>/<catalogue-object-identifier>\r\n      let domainUrl = divideURL(descriptorURL).domain;\r\n\r\n      if (domainUrl.includes('catalogue')) {\r\n        domainUrl = domainUrl.replace('catalogue.', '');\r\n      }\r\n\r\n      _this.idModule.getIdentityAssertion().then(function(result) {\r\n\r\n        let userProfile = result.userProfile;\r\n\r\n        // hack while domain registry does not support discovery per email\r\n        let email = userProfile.userURL.split('://')[1].split('/')[1];\r\n        let emailURL = 'user://' + email.split('@')[1] + '/' + email.split('@')[0];\r\n\r\n        if (_this._messageBus === undefined) {\r\n          reject('MessageBus not found on registerStub');\r\n        } else {\r\n          //call check if the protostub exist: to be removed\r\n          /*  _this.resolve(domainUrl).then(function(a) {\r\n            console.log('[Registry registerHyperty] stub to domain registry- ', a);*/\r\n\r\n          _this.storageManager.get('registry:HypertyURLs').then((urlsList) => {\r\n\r\n            console.log('[Registry registerHyperty] storageManager] - ', urlsList);\r\n\r\n            _this._getResourcesAndSchemes(descriptor).then((value) => {\r\n\r\n              hypertyCapabilities = value;\r\n\r\n              if (!urlsList) {\r\n                urlsList = {};\r\n              }\r\n\r\n              urlsList[hypertyCapabilities.resources + hypertyCapabilities.dataSchema] = addressURL.address;\r\n              _this.storageManager.set('registry:HypertyURLs', 0, urlsList).then(() => {\r\n\r\n                _this.registryDomain = domainUrl;\r\n\r\n                //check whether the received sanbox e ApplicationSandbox or a normal sandbox\r\n                if (sandbox.type === 'app') {\r\n                  _this.sandboxesList.appSandbox[addressURL.address[0]] = sandbox;\r\n                } else if (sandbox.type === 'normal') {\r\n                  _this.sandboxesList.sandbox[addressURL.address[0]] = sandbox;\r\n                } else {\r\n                  reject('Wrong SandboxType');\r\n                }\r\n\r\n                let p2pHandler;\r\n                let p2pRequester;\r\n\r\n                if (Object.keys(_this.p2pHandlerStub).length !== 0) {\r\n                  p2pHandler = _this.p2pHandlerStub[_this.runtimeURL].url;\r\n                  p2pRequester = runtimeUtils.runtimeDescriptor.p2pRequesterStub;\r\n                }\r\n\r\n                let runtime = _this.runtimeURL;\r\n                let status = 'live';\r\n\r\n                let hyperty = new HypertyInstance(_this.identifier, _this.registryURL,\r\n                descriptorURL, descriptor, addressURL.address[0], userProfile, 'guid', _this.runtimeURL, 'ctx', p2pHandler, p2pRequester, hypertyCapabilities.dataSchema, hypertyCapabilities.resources);\r\n\r\n                _this.hypertiesList.push(hyperty);\r\n\r\n                //message to register the new hyperty, within the domain registry\r\n                let messageValue;\r\n                let message;\r\n\r\n                if (addressURL.newAddress) {\r\n                  console.log('[Registry registerHyperty] registering new Hyperty URL', addressURL.address[0]);\r\n\r\n                  messageValue = {\r\n                    user: emailURL,\r\n                    descriptor: descriptorURL,\r\n                    url: addressURL.address[0],\r\n                    expires: _this.expiresTime,\r\n                    resources: hypertyCapabilities.resources,\r\n                    dataSchemes: hypertyCapabilities.dataSchema,\r\n                    runtime: runtime,\r\n                    status: status\r\n                  };\r\n\r\n                  if (p2pHandler) {\r\n                    messageValue.p2pHandler = p2pHandler;\r\n                    messageValue.p2pRequester = p2pRequester;\r\n                  }\r\n\r\n                  console.log('[Registry registerHyperty] registering new Hyperty at domain registry ', messageValue);\r\n\r\n                  message = {type: 'create', from: _this.registryURL, to: 'domain://registry.' + _this.registryDomain + '/', body: {value: messageValue, policy: 'policy'}};\r\n\r\n                } else {\r\n                  console.log('[Registry registerHyperty] registering previously registered Hyperty URL', addressURL.address[0]);\r\n\r\n                  message = {\r\n                    type: 'update',\r\n                    to: 'domain://registry.' + _this.registryDomain + '/',\r\n                    from: _this.registryURL,\r\n                    body: {resource: addressURL.address[0], value: { status: 'live', user: emailURL }}\r\n                  };\r\n\r\n                  if (p2pHandler) {\r\n                    message.body.value.p2pHandler = p2pHandler;\r\n                  }\r\n                }\r\n\r\n                console.log('[Registry registerHyperty] updating Hyperty registration at domain registry  - ', message);\r\n\r\n                _this._messageBus.postMessage(message, (reply) => {\r\n                  console.log('[Registry registerHyperty] Hyperty registration update response: ', reply);\r\n\r\n                  if (reply.body.code === 200) {\r\n                    resolve(addressURL.address[0]);\r\n                  } else {\r\n                    reject('Failed to register an Hyperty');\r\n                  }\r\n                });\r\n\r\n                //timer to keep the registration alive\r\n                // the time is defined by a little less than half of the expires time defined\r\n                let keepAliveTimer = setInterval(function() {\r\n\r\n                  /*let message = _this.messageFactory.createCreateMessageRequest(\r\n                    _this.registryURL,\r\n                    'domain://registry.' + _this.registryDomain + '/',\r\n                    messageValue,\r\n                    'policy'\r\n                  );*/\r\n\r\n                  let message = {\r\n                    type: 'update',\r\n                    from: _this.registryURL,\r\n                    to: 'domain://registry.' + _this.registryDomain + '/',\r\n                    body: { resource: addressURL.address[0], value: {status: 'live'} }};\r\n\r\n                  _this._messageBus.postMessage(message, (reply) => {\r\n                    console.log('[Registry registerHyperty] KeepAlive Reply: ', reply);\r\n                  });\r\n                }, (((_this.expiresTime / 1.1) / 2) * 1000));\r\n\r\n              }).catch(function(reason) {\r\n                console.log('[Registry registerHyperty] Error: ', reason);\r\n                reject(reason);\r\n              });\r\n            });\r\n          });\r\n        }\r\n      }, function(err) {\r\n        reject('[Registry registerHyperty] Failed to obtain an identity', err);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * To unregister a previously registered Hyperty\r\n  * @param  {HypertyURL}          HypertyURL url        url\r\n  */\r\n  unregisterHyperty(url) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let found = false;\r\n      let index = 0;\r\n\r\n      for\t(index = 0; index < _this.hypertiesList.length; index++) {\r\n        let hyperty = _this.hypertiesList[index];\r\n        if (hyperty !== undefined) {\r\n          if (hyperty.hypertyURL === url) {\r\n            found = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (found === false) {\r\n        reject('Hyperty not found');\r\n      } else {\r\n        delete _this.hypertiesList[index];\r\n        resolve('Hyperty successfully deleted');\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * To discover protocol stubs available in the runtime for a certain domain. If available, it returns the runtime url for the protocol stub that connects to the requested domain. Required by the runtime BUS to route messages to remote servers or peers (do we need something similar for Hyperties?).\r\n  * @param  {DomainURL}           DomainURL            url\r\n  * @return {RuntimeURL}           RuntimeURL\r\n  */\r\n  discoverProtostub(url) {\r\n    if (!url) throw new Error('Parameter url needed');\r\n    let _this = this;\r\n\r\n    let dividedURL = divideURL(url);\r\n    let domainURL = dividedURL.domain;\r\n\r\n    if (_this.protostubsList.hasOwnProperty(domainURL) && _this.protostubsList[domainURL].status === STATUS.LIVE) {\r\n      return (_this.protostubsList[domainURL]);\r\n    } else {\r\n\r\n      _this.protostubsList[domainURL] = {\r\n        status: STATUS.CREATED\r\n      };\r\n\r\n      throw new Error('[Registry - discoverProtoStub ] Message Node Protostub Not Found. Creating one');\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n  * To discover protocol stubs available in the runtime for a certain domain. If available, it returns the runtime url for the protocol stub that connects to the requested domain. Required by the runtime BUS to route messages to remote servers or peers (do we need something similar for Hyperties?).\r\n  * @param  {RuntimeURL}           RuntimeURL            url\r\n  * @return {RuntimeURL}           RuntimeURL\r\n  */\r\n  discoverP2PStub(runtimeURL) {\r\n    let _this = this;\r\n\r\n    if (runtimeURL) {\r\n\r\n      if (_this.p2pRequesterStub.hasOwnProperty(runtimeURL) && _this.p2pRequesterStub[runtimeURL].status === STATUS.LIVE) {\r\n        return (_this.p2pRequesterStub[runtimeURL]);\r\n      } else {\r\n        _this.p2pRequesterStub[runtimeURL] = {\r\n          status: STATUS.CREATED\r\n        };\r\n\r\n        throw new Error('[Registry - discoverP2PStub ] P2P Requester Stub Not Found. Creating one');\r\n\r\n      }\r\n    } else {\r\n\r\n      if (_this.p2pHandlerStub.hasOwnProperty(_this.runtimeURL) && _this.p2pHandlerStub[_this.runtimeURL].status === STATUS.LIVE) {\r\n        return (_this.p2pHandlerStub[_this.runtimeURL]);\r\n      } else {\r\n        _this.p2pHandlerStub[_this.runtimeURL] = {\r\n          status: STATUS.CREATED\r\n        };\r\n\r\n        throw new Error('[Registry - discoverP2PStub ] P2P Handler Stub Not Found. Creating one');\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * To register a new Protocol Stub in the runtime including as input parameters the function to postMessage, the DomainURL that is connected with the stub, which returns the RuntimeURL allocated to the new ProtocolStub.\r\n   * @param  {Sandbox}       Sandbox\r\n   * @param  {stubID}        Domain or hyperty runtime to register the stub\r\n   * @param  {descriptorURL}     Catalogue URL of the Protostub descriptor\r\n   * @param  {descriptor}     Protostub descriptor\r\n   * @return {RuntimeProtoStubURL}\r\n   */\r\n  registerStub(sandbox, stubID, p2pConfig, descriptorURL, descriptor) {\r\n    let _this = this;\r\n\r\n    let _stubDescriptor = descriptor;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let runtimeProtoStubURL;\r\n\r\n      //check if messageBus is registered in registry or not\r\n      if (_this._messageBus === undefined) {\r\n        reject('MessageBus not found on registerStub');\r\n      }\r\n\r\n      console.info('[Registry - registerStub] - stubID ', stubID);\r\n\r\n  /*    if (!stubID.indexOf('msg-node.')) {\r\n        stubID = stubID.substring(stubID.indexOf('.') + 1);\r\n      }*/\r\n\r\n      let P2PRequesterStub;\r\n\r\n      if (p2pConfig) {\r\n\r\n        if (p2pConfig.hasOwnProperty('isHandlerStub') && p2pConfig.isHandlerStub) {\r\n          runtimeProtoStubURL = 'runtime://' + divideURL(stubID).domain + '/p2phandler/' + generateGUID();\r\n          console.info('[Registry - registerStub - isP2PHandler] - ', runtimeProtoStubURL);\r\n\r\n          _this.p2pHandlerStub[stubID] = {\r\n            url: runtimeProtoStubURL,\r\n            status: STATUS.CREATED\r\n          };\r\n\r\n          _this.p2pHandlerAssociation[_this.runtimeURL] = [];\r\n\r\n          _this.sandboxesList.sandbox[runtimeProtoStubURL] = sandbox;\r\n          resolve(_this.p2pHandlerStub[stubID]);\r\n        } else {\r\n          P2PRequesterStub = p2pConfig.p2pRequesterStub;\r\n          runtimeProtoStubURL = 'runtime://' + divideURL(p2pConfig.remoteRuntimeURL).domain + '/p2prequester/' + generateGUID();\r\n          console.info('[Registry - registerStub - P2PRequesterStub] - ', P2PRequesterStub, ' - ', runtimeProtoStubURL);\r\n\r\n          // to be clarified what is this p2pHandlerAssociation\r\n\r\n          _this.p2pHandlerAssociation[_this.runtimeURL].push(runtimeProtoStubURL);\r\n          _this.p2pRequesterStub[stubID] = {\r\n            url: runtimeProtoStubURL,\r\n            status: STATUS.CREATED\r\n          };\r\n\r\n          _this.sandboxesList.sandbox[runtimeProtoStubURL] = sandbox;\r\n          resolve(_this.p2pRequesterStub[stubID]);\r\n        }\r\n      } else {\r\n        runtimeProtoStubURL = 'runtime://' + stubID + '/protostub/' + generateGUID();\r\n\r\n        console.info('[Registry - registerStub - Normal Stub] - ', stubID);\r\n\r\n        // TODO: Optimize this\r\n        _this.protostubsList[stubID] = {\r\n          url: runtimeProtoStubURL,\r\n          status: STATUS.CREATED\r\n        };\r\n\r\n        if (descriptorURL) {\r\n          _this.protostubsList[stubID].descriptorURL = descriptorURL;\r\n        }\r\n\r\n        if (_stubDescriptor && (_stubDescriptor.interworking)) {\r\n          _this.protostubsList[stubID].interworking = _stubDescriptor.interworking;\r\n        }\r\n\r\n        _this.sandboxesList.sandbox[runtimeProtoStubURL] = sandbox;\r\n\r\n        resolve(_this.protostubsList[stubID]);\r\n      }\r\n\r\n      // resolve(runtimeProtoStubURL);\r\n\r\n      _this._messageBus.addListener(runtimeProtoStubURL + '/status', (msg) => {\r\n        _this._onProtostubStatusEvent(msg);\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * To Process status events fired by protostubs\r\n  * @param  {Message}   message     Event Message\r\n  */\r\n\r\n  _onProtostubStatusEvent(msg) {\r\n\r\n    let _this = this;\r\n\r\n    console.log('[Registry onProtostubStatusEvent]: ', msg);\r\n\r\n    let runtimeProtoStubURL = msg.from;\r\n\r\n    if (!msg.to.includes('/status')) {\r\n      console.error('[Registry onProtostubStatusEvent] Not Status Event: ', msg);\r\n      return;\r\n    }\r\n\r\n    // process status events from message node protostubs\r\n    // TODO: uncomment below when protostubs are updated with new status value \"live\"\r\n\r\n  /*  if (runtimeProtoStubURL.includes('/protostub/')) {\r\n\r\n      let filtered = Object.keys(_this.protostubsList).filter((key) => {\r\n          return _this.protostubsList[key].url === runtimeProtoStubURL;\r\n        }).map((key) => {\r\n          _this.protostubsList[key].status = msg.body.value;\r\n        });\r\n    }*/\r\n\r\n    // process status events from message P2P Handler protostubs\r\n    if (runtimeProtoStubURL.includes('/p2phandler/')) {\r\n\r\n      // process status events from p2p connections at message P2P Handler protostubs\r\n      if (msg.body.resource) {\r\n\r\n        let remoteRuntimeURL = msg.body.resource;\r\n\r\n        let p2pConnection = _this.p2pConnectionList[remoteRuntimeURL];\r\n\r\n        if (p2pConnection) {\r\n          _this.p2pConnectionList[remoteRuntimeURL].status =  msg.body.value;\r\n          _this.p2pConnectionList[remoteRuntimeURL].url =  runtimeProtoStubURL;\r\n        } else {\r\n\r\n          // process status events from P2P Handler protostub\r\n          p2pConnection = {\r\n            status: msg.body.value,\r\n            url: runtimeProtoStubURL\r\n          };\r\n\r\n          _this.p2pConnectionList[remoteRuntimeURL] =  p2pConnection;\r\n        }\r\n\r\n        console.error('[Registry - onProtostubStatusEvent] - P2PRequester Stub status: ', _this.p2pConnectionList[remoteRuntimeURL]);\r\n      } else {\r\n        _this.p2pHandlerStub[_this.runtimeURL].status = msg.body.value;\r\n        console.error('[Registry - onProtostubStatusEvent] - P2PRequester Stub status: ', _this.p2pHandlerStub[_this.runtimeURL]);\r\n      }\r\n\r\n    }\r\n\r\n    // process status events from message P2P Requester protostubs\r\n    if (runtimeProtoStubURL.includes('/p2prequester/')) {\r\n\r\n      let filtered = Object.keys(_this.p2pRequesterStub).filter((key) => {\r\n        return _this.p2pRequesterStub[key].url === runtimeProtoStubURL;\r\n      }).map((key) => {\r\n        _this.p2pRequesterStub[key].status = msg.body.value;\r\n      });\r\n\r\n      console.error('[Registry - onProtostubStatusEvent] - P2PRequester Stub status: ', filtered);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * To unregister a previously registered protocol stub\r\n  * @param  {HypertyRuntimeURL}   HypertyRuntimeURL     hypertyRuntimeURL\r\n  */\r\n  unregisterStub(hypertyRuntimeURL) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      if (_this.protostubsList.hasOwnProperty(hypertyRuntimeURL)) {\r\n        delete _this.protostubsList[hypertyRuntimeURL];\r\n        resolve('ProtostubURL removed');\r\n      } else {\r\n        reject('Error on unregisterStub: Hyperty not found');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * To register a new Identity Provider proxy in the runtime including as input parameters the function to postMessage, the DomainURL that is connected with the stub, which returns the RuntimeURL allocated to the new ProtocolStub.\r\n   * @param {Sandbox}        Sandbox\r\n   * @param  {DomainURL}     DomainURL service provider domain\r\n   * @return {RuntimeIdpProxyURL}\r\n   */\r\n  registerIdpProxy(sandbox, domainURL) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let idpProxyStubURL;\r\n\r\n      //check if messageBus is registered in registry or not\r\n      if (_this._messageBus === undefined) {\r\n        reject('MessageBus not found on registerStub');\r\n      }\r\n\r\n      idpProxyStubURL = 'domain-idp://' + domainURL + '/stub/' + generateGUID();\r\n\r\n      // TODO: Optimize this\r\n      _this.idpProxyList[domainURL] = {\r\n        url: idpProxyStubURL,\r\n        status: STATUS.PROGRESS\r\n      };\r\n\r\n      _this.sandboxesList.sandbox[idpProxyStubURL] = sandbox;\r\n\r\n      // sandbox.addListener('*', function(msg) {\r\n      //   _this._messageBus.postMessage(msg);\r\n      // });\r\n\r\n      resolve(idpProxyStubURL);\r\n\r\n      _this._messageBus.addListener(idpProxyStubURL + '/status', (msg) => {\r\n        if (msg.resource === msg.to + '/status') {\r\n          console.log('[Registry] idpProxyStubURL/status message: ', msg.body.value);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n  * To discover idpProxy stubs available in the runtime for a certain domain. If available, it returns the runtime url for the idpProxy stub that connects to the requested domain. Required by the runtime BUS to route messages to remote servers or peers\r\n  * @param  {DomainURL}           DomainURL            url\r\n  * @return {RuntimeURL}           RuntimeURL         idpProxyUrl\r\n  */\r\n  discoverIdpProxy(url) {\r\n    if (!url) throw new Error('Parameter url needed');\r\n    let _this = this;\r\n\r\n    let dividedURL = divideURL(url);\r\n    let domainURL = dividedURL.domain;\r\n\r\n    if (_this.idpProxyList.hasOwnProperty(domainURL) && _this.idpProxyList[domainURL].status === STATUS.LIVE) {\r\n      return (_this.idpProxyList[domainURL]);\r\n    } else {\r\n\r\n      _this.idpProxyList[domainURL] = {\r\n        status: STATUS.PROGRESS\r\n      };\r\n\r\n      throw new Error('[Registry - discoverIdpProxy ] Idp Proxy Not Found. Creating one');\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n  * To register a new Policy Enforcer in the runtime including as input parameters the function to postMessage, the HypertyURL associated with the PEP, which returns the RuntimeURL allocated to the new Policy Enforcer component.\r\n  * @param  {Message.Message} postMessage postMessage\r\n  * @param  {HypertyURL}          HypertyURL            hyperty\r\n  * @return {HypertyRuntimeURL}   HypertyRuntimeURL\r\n  */\r\n  registerPEP(postMessage, hyperty) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve) {\r\n      //TODO check what parameter in the postMessage the pep is.\r\n      _this.pepList[hyperty] = postMessage;\r\n      resolve('PEP registered with success');\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * To unregister a previously registered protocol stub\r\n  * @param  {HypertyRuntimeURL}   HypertyRuntimeURL     HypertyRuntimeURL\r\n  */\r\n  unregisterPEP(HypertyRuntimeURL) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let result = _this.pepList[HypertyRuntimeURL];\r\n\r\n      if (result === undefined) {\r\n        reject('Pep Not found.');\r\n      } else {\r\n        resolve('PEP successfully removed.');\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * To discover sandboxes available in the runtime for a certain domain. Required by the runtime UA to avoid more than one sandbox for the same domain.\r\n  * @param  {DomainURL} DomainURL url\r\n  * @return {RuntimeSandbox}           RuntimeSandbox\r\n  */\r\n  getSandbox(url) {\r\n    if (!url) throw new Error('Parameter url needed');\r\n    console.log('[Registry getSandbox] getSandbox: ', url);\r\n\r\n    let _this = this;\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let request;\r\n\r\n      //first try to find the url in the appSandbox list\r\n      request = _this.sandboxesList.appSandbox[url];\r\n\r\n      //if no appSandbox was found, try to search in the normal sandboxes list\r\n      if (!request) {\r\n        request = _this.sandboxesList.sandbox[url];\r\n\r\n        if (!request) {\r\n\r\n          let domain;\r\n\r\n          if (url.includes('://')) {\r\n            domain = divideURL(url).domain;\r\n          } else {\r\n            domain = url;\r\n          }\r\n\r\n          // search in the sandboxes list for a entry containing the domain given\r\n          for (let sandbox in _this.sandboxesList.sandbox) {\r\n            if (sandbox.includes(domain)) {\r\n              request = _this.sandboxesList.sandbox[sandbox];\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!request) {\r\n        reject('no sandbox found for: ' + url);\r\n      } else {\r\n        resolve(request);\r\n      }\r\n\r\n    });\r\n  }\r\n\r\n  resolveNormalStub(url) {\r\n    console.log('resolveNormalStub ' + url);\r\n    let _this = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      //split the url to find the domainURL. deals with the url for example as:\r\n      //\"hyperty-runtime://sp1/protostub/123\",\r\n      let dividedURL = divideURL(url);\r\n      let domainUrl = dividedURL.domain;\r\n      let type = dividedURL.type;\r\n\r\n      if (url.includes(_this.runtimeURL)) {\r\n        console.error('[Registry - resolve] URL to be resolved should have listeners ', url);\r\n        reject('[Registry - resolve] URL to be resolved should have listeners ', url);\r\n      }\r\n\r\n      // resolve the domain protostub in case of a message to global registry\r\n      if (url.includes('global://registry')) {\r\n        domainUrl = _this._domain;\r\n      } else {\r\n        if (!domainUrl.indexOf('msg-node.') || !domainUrl.indexOf('registry.')) {\r\n          domainUrl = domainUrl.substring(domainUrl.indexOf('.') + 1);\r\n        }\r\n      }\r\n\r\n      _this.isLegacy(url).then((isLegacy) => {\r\n\r\n        // if legacy it should resolve for <protocol>.<domain>\r\n        if (isLegacy && type !== 'domain-idp') {\r\n          domainUrl = type + '.' + getUserIdentityDomain(url);\r\n        }\r\n\r\n        console.info('[Registry.resolve] domainUrl:', domainUrl);\r\n\r\n        let registredComponent;\r\n\r\n        if (type === 'domain-idp') {\r\n          registredComponent  = _this.idpProxyList.hasOwnProperty(domainUrl) ? _this.idpProxyList[domainUrl] : false;\r\n        } else {\r\n          registredComponent  = _this.protostubsList.hasOwnProperty(domainUrl) ? _this.protostubsList[domainUrl] : false;\r\n        }\r\n\r\n        // TODO since the protostubs have other states this should be revised, because the status could change from DEPLOYED to LIVE\r\n        // TODO and this validation will trigger a new load of IDPProxy or Protostub;\r\n        if (registredComponent && registredComponent.hasOwnProperty('status') && (registredComponent.status === STATUS.DEPLOYED || registredComponent.status === STATUS.LIVE)) {\r\n          console.info('[Registry.resolve] Resolved: ', registredComponent.url, registredComponent.status);\r\n          resolve(registredComponent.url);\r\n        } else {\r\n          if (type === 'domain-idp') {\r\n\r\n            // this process will load the idp proxy, because is not yet registered;\r\n            console.info('[Registry.resolve] trigger new IDPProxy: ', domainUrl);\r\n            _this._loader.loadIdpProxy(domainUrl).then(() => {\r\n\r\n              registredComponent  = _this.idpProxyList[domainUrl];\r\n              _this.idpProxyList[domainUrl].status = STATUS.DEPLOYED;\r\n              console.info('[Registry.resolve] Resolved: ', registredComponent.url, registredComponent.status);\r\n              resolve(registredComponent.url);\r\n\r\n            }).catch((reason) => {\r\n              console.error('[Registry.resolve] Error resolving Load IDPProxy: ', reason);\r\n              reject(reason);\r\n            });\r\n\r\n          } else {\r\n\r\n            // this process will load the Protocols stub, because is not yet registered;\r\n            console.info('[Registry.resolve] trigger new ProtocolStub: ', domainUrl);\r\n            _this._loader.loadStub(domainUrl).then(() => {\r\n\r\n              registredComponent  = _this.protostubsList[domainUrl];\r\n              console.info('[Registry.resolve] Resolved: ', registredComponent.url, registredComponent.status);\r\n              _this.protostubsList[domainUrl].status = STATUS.DEPLOYED;\r\n\r\n              resolve(registredComponent.url);\r\n            }).catch((reason) => {\r\n              console.error('[Registry.resolve] Error resolving Load ProtocolStub: ', reason);\r\n              reject(reason);\r\n            });\r\n\r\n          }\r\n\r\n        }\r\n\r\n      }).catch((reason) => {\r\n        console.error('[Registry.resolve] Error resolving islegacy: ', reason);\r\n        reject(reason);\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * To verify if source is valid and to resolve target runtime url address if needed (eg protostub runtime url in case the message is to be dispatched to a remote endpoint).\r\n  * @param  {URL.URL}  url       url\r\n  * @return {Promise<URL.URL>}                 Promise <URL.URL>\r\n  */\r\n  resolve(url) {\r\n    console.log('[Registry - Resolve] -  ' + url);\r\n    let _this = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      // Skip p2p procedure when not supported by the Runtime or for backend services\r\n\r\n      if (!_this.p2pHandlerStub[_this.runtimeURL] || isBackendServiceURL(url) || url.includes(_this.runtimeURL) || url.includes('/p2phandler/') || url.includes('/p2prequester/')) {\r\n\r\n        _this.resolveNormalStub(url).then((returnURL) => {\r\n          resolve(returnURL);\r\n        });\r\n\r\n      } else {\r\n        _this.checkHypertyP2PHandler(url).then((hypertyInfo) => {\r\n\r\n          let p2pConnection = _this.p2pConnectionList[hypertyInfo.runtimeURL];\r\n\r\n          if (!p2pConnection) {\r\n            p2pConnection = {};\r\n          }\r\n\r\n          if (p2pConnection.status === STATUS.LIVE) {\r\n            resolve(p2pConnection.url);\r\n          } else {\r\n\r\n            if (p2pConnection.status === STATUS.CREATED) {\r\n              _this.resolveNormalStub(url).then((returnURL) => {\r\n                resolve(returnURL);\r\n              });\r\n            } else {\r\n              p2pConnection.status = STATUS.CREATED;\r\n              _this.p2pConnectionList[hypertyInfo.runtimeURL] = p2pConnection;\r\n\r\n              console.log('[Registry - resolve] loadStub with p2pRequester: ', hypertyInfo);\r\n\r\n              let p2pConfig = { remoteRuntimeURL: hypertyInfo.runtimeURL, p2pHandler: hypertyInfo.p2pHandler, p2pRequesterStub: true };\r\n\r\n              // TODO stub load\r\n              _this._loader.loadStub(hypertyInfo.p2pRequester, p2pConfig).then((protostubInfo) => {\r\n                p2pConnection.status = STATUS.CREATED;\r\n                _this.p2pConnectionList[hypertyInfo.runtimeURL] = p2pConnection;\r\n\r\n                resolve(protostubInfo.url);\r\n              }).catch((error) => {\r\n                reject(error);\r\n              });\r\n            }\r\n          }\r\n        }, (reason) => {\r\n          console.error('[Registry - Resolve] - Reason: ', reason);\r\n\r\n          _this.resolveNormalStub(url).then((returnURL) => {\r\n            resolve(returnURL);\r\n          });\r\n        });\r\n      }\r\n\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n  * To verify if url is from a legacy domain.\r\n  * @param  {URL.URL}  url      url\r\n  * @return {boolean}\r\n  */\r\n  isLegacy(url) {\r\n\r\n    let _this = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      if (url === _this._domain) {\r\n        return resolve(false);\r\n      }\r\n\r\n      console.log('[Registry] [Registry.Registry.isLegacy] ', url);\r\n\r\n      // TODO: to be defined in the runtime configuration\r\n      let nonLegacy = ['runtime', 'hyperty-runtime', 'domain', 'global', 'hyperty'];\r\n\r\n      let urlDivided = divideURL(url);\r\n\r\n      if (nonLegacy.indexOf(urlDivided.type) !== -1 || urlDivided.domain === _this._domain) {\r\n        return resolve(false);\r\n      }\r\n\r\n      let domain = urlDivided.domain;\r\n\r\n      console.log('[Registry] [Registry.Registry.isLegacy] domain: ', domain);\r\n      if (_this.idpLegacyProxyList.hasOwnProperty(domain)) {\r\n\r\n        let result = _this.idpLegacyProxyList[domain];\r\n\r\n        if (result.interworking) {\r\n          return resolve(result.interworking);\r\n        } else {\r\n          return resolve(false);\r\n        }\r\n      }\r\n\r\n      _this._loader.descriptors.getIdpProxyDescriptor(domain).then((result) => {\r\n\r\n        console.log('[Registry] [Registry.Registry.isLegacy] Legacy stub descriptor: ', result);\r\n        _this.idpLegacyProxyList[domain] = result;\r\n\r\n        if (result.interworking) {\r\n          resolve(result.interworking);\r\n        } else {\r\n          resolve(false);\r\n        }\r\n\r\n      }).catch((reason) => {\r\n        console.warn('problem loading idp proxy descriptor for domain:', domain, ' because ', reason);\r\n        reject(reason);\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  /**\r\n  * To verify if URL is locally registered or not.\r\n  * @param  {URL.URL}  url      url\r\n  * @return {boolean}\r\n  */\r\n\r\n  isLocal(url) {\r\n\r\n    let runtimeScheme = ['hyperty-runtime', 'runtime'];\r\n    let hypertyScheme = ['hyperty'];\r\n    let urlScheme = url.split('://')[0];\r\n\r\n    // Process Runtime Core URLs.\r\n    // Messages originated from protostubs should also not include the runtimeURL in its URL.\r\n\r\n    if (runtimeScheme.indexOf(urlScheme) !== -1) {\r\n      return url.includes(this.runtimeURL);\r\n    }\r\n\r\n    // Process Hyperty URLs\r\n    // Todo: hypertiesList should be an object not an array\r\n\r\n    if (hypertyScheme.indexOf(urlScheme) !== -1) {\r\n\r\n      for (let index in this.hypertiesList) {\r\n        let hyperty = this.hypertiesList[index];\r\n        if (hyperty.hypertyURL === url) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    // Process Data Object URLs\r\n\r\n    if (url.includes('/subscription')) {\r\n      url = url.substring(0, url.indexOf('/subscription'));\r\n    }\r\n\r\n    let dataObject = this.dataObjectList[url];\r\n\r\n    if (dataObject) {\r\n      if (dataObject.interworking) {\r\n        return !dataObject.interworking;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n  * To verify if protostub is to interwork with a legacy domain.\r\n  * @param  {URL.URL}  runtimeProtostubURL      The runtime URL of the Protostub\r\n  * @return {boolean}\r\n  */\r\n\r\n  isInterworkingProtoStub(runtimeProtostubURL) {\r\n\r\n    let _this = this;\r\n\r\n    if (!(runtimeProtostubURL.includes('/protostub/'))) {\r\n      return false;\r\n    }\r\n\r\n    let filtered = Object.keys(_this.protostubsList).filter((key) => {\r\n      return _this.protostubsList[key].url === runtimeProtostubURL;\r\n    }).map((key) => {\r\n\r\n      if (_this.protostubsList[key].hasOwnProperty('interworking')) {\r\n        return _this.protostubsList[key].interworking;\r\n      } else {\r\n        return false;\r\n      }\r\n    })[0];\r\n\r\n    return filtered;\r\n  }\r\n}\r\n\r\nexport default Registry;\r\n",
    "static": true,
    "longname": "src/registry/Registry.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 478,
    "kind": "variable",
    "name": "STATUS",
    "memberof": "src/registry/Registry.js",
    "static": true,
    "longname": "src/registry/Registry.js~STATUS",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/registry/Registry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"CREATED\": string, \"LIVE\": string, \"DEPLOYED\": string, \"PROGRESS\": string, \"DISCONNECTED\": string, \"DEAD\": string}"
      ]
    }
  },
  {
    "__docId__": 479,
    "kind": "class",
    "name": "Registry",
    "memberof": "src/registry/Registry.js",
    "static": true,
    "longname": "src/registry/Registry.js~Registry",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/registry/Registry.js",
    "importStyle": "Registry",
    "description": "Runtime Registry Interface",
    "lineNumber": 44,
    "interface": false
  },
  {
    "__docId__": 480,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#constructor",
    "access": null,
    "description": "To initialise the Runtime Registry with the RuntimeURL that will be the basis to derive the internal runtime addresses when allocating addresses to internal runtime component. In addition, the Registry domain back-end to be used to remotely register Runtime components, is also passed as input parameter.",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "msgbus",
        "description": "msgbus"
      },
      {
        "nullable": null,
        "types": [
          "HypertyRuntimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeURL",
        "description": "runtimeURL"
      },
      {
        "nullable": null,
        "types": [
          "AppSandbox"
        ],
        "spread": false,
        "optional": false,
        "name": "appSandbox",
        "description": "appSandbox"
      },
      {
        "nullable": null,
        "types": [
          "runtimeCatalogue"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeCatalogue",
        "description": "runtimeCatalogue"
      },
      {
        "nullable": null,
        "types": [
          "DomainURL"
        ],
        "spread": false,
        "optional": false,
        "name": "remoteRegistry",
        "description": "remoteRegistry"
      },
      {
        "nullable": null,
        "types": [
          "storageManager"
        ],
        "spread": false,
        "optional": false,
        "name": "storageManager",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 481,
    "kind": "set",
    "name": "loader",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#loader",
    "access": null,
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 482,
    "kind": "get",
    "name": "loader",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#loader",
    "access": null,
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 483,
    "kind": "get",
    "name": "messageBus",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#messageBus",
    "access": null,
    "description": "return the messageBus in this Registry",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 484,
    "kind": "set",
    "name": "messageBus",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#messageBus",
    "access": null,
    "description": "Set the messageBus in this Registry",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 485,
    "kind": "method",
    "name": "discoverHypertyPerUser",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#discoverHypertyPerUser",
    "access": null,
    "description": "function to request about users registered in domain registry, and\nreturn the last hyperty instance registered by the user.",
    "lineNumber": 273,
    "params": [
      {
        "nullable": null,
        "types": [
          "email"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise"
    }
  },
  {
    "__docId__": 486,
    "kind": "method",
    "name": "_getIdentityAssociated",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#_getIdentityAssociated",
    "access": null,
    "description": null,
    "lineNumber": 338,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "hypertyURL",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 487,
    "kind": "method",
    "name": "discoverDataObjectPerURL",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#discoverDataObjectPerURL",
    "access": null,
    "description": "query the domain registry for information from a dataObject URL",
    "lineNumber": 370,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "dataObject URL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "dataObject     data object"
    }
  },
  {
    "__docId__": 488,
    "kind": "method",
    "name": "getAppSandbox",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#getAppSandbox",
    "access": null,
    "description": "This function is used to return the sandbox instance where the Application is executing. It is assumed there is just one App per Runtime instance.",
    "lineNumber": 404,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 489,
    "kind": "method",
    "name": "getHypertyOwner",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#getHypertyOwner",
    "access": null,
    "description": "This function returns the user associated to the hyperty URL",
    "lineNumber": 414,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hypertyURL",
        "description": "hyperty URL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "userURL         user URL"
    }
  },
  {
    "__docId__": 490,
    "kind": "method",
    "name": "getHypertyName",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#getHypertyName",
    "access": null,
    "description": "returns the hyperty Name from a given url. This url could be from a dataObject or hyperty",
    "lineNumber": 433,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "hyperty or dataObject URL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "hypertyName     hyperty Name"
    }
  },
  {
    "__docId__": 491,
    "kind": "method",
    "name": "getReporterURL",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#getReporterURL",
    "access": null,
    "description": "function to return the reporterURL associated with the dataobject URL",
    "lineNumber": 459,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectURL",
        "description": "dataObjectURL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "reporterURL      reporterURL"
    }
  },
  {
    "__docId__": 492,
    "kind": "method",
    "name": "getReporterURLSynchonous",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#getReporterURLSynchonous",
    "access": null,
    "description": "function to return the reporterURL associated with the dataobject URL. no promise returned",
    "lineNumber": 479,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectURL",
        "description": "dataObjectURL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "reporterURL      reporterURL"
    }
  },
  {
    "__docId__": 493,
    "kind": "method",
    "name": "getDataObjectSubscriberHyperty",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#getDataObjectSubscriberHyperty",
    "access": null,
    "description": "returns the hyperty URL that subscribed the dataObject",
    "lineNumber": 492,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "url format"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "Hyperty URL subscribed to the URL"
    }
  },
  {
    "__docId__": 494,
    "kind": "method",
    "name": "registerSubscribedDataObject",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#registerSubscribedDataObject",
    "access": null,
    "description": "register a desired dataObject to subscribe",
    "lineNumber": 502,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectURL",
        "description": "dataObject URL"
      }
    ]
  },
  {
    "__docId__": 495,
    "kind": "method",
    "name": "getPreAuthSubscribers",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#getPreAuthSubscribers",
    "access": null,
    "description": "Function to return the list of pre authorised users received in the creation of a data object",
    "lineNumber": 514,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectURL",
        "description": "dataObjectURL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<String>"
      ],
      "spread": false,
      "description": "preAuth         List of pre authorised users"
    }
  },
  {
    "__docId__": 496,
    "kind": "method",
    "name": "unregisterAllHyperties",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#unregisterAllHyperties",
    "access": null,
    "description": "send requests to unregister all hyperties registered in domain registry",
    "lineNumber": 529,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "return a promise if the result of unregistration all hyperties"
    }
  },
  {
    "__docId__": 497,
    "kind": "method",
    "name": "unregisterHypertyInstance",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#unregisterHypertyInstance",
    "access": null,
    "description": " function to unregister an hypertyInstance in the Domain Registry",
    "lineNumber": 555,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user url"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hypertyInstance",
        "description": "HypertyInsntance url"
      }
    ]
  },
  {
    "__docId__": 498,
    "kind": "method",
    "name": "deleteDataObjectInstance",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#deleteDataObjectInstance",
    "access": null,
    "description": " function to delete an dataObjectInstance in the Domain Registry",
    "lineNumber": 572,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "DataObjectName"
      }
    ]
  },
  {
    "__docId__": 499,
    "kind": "method",
    "name": "updateHypertyInstance",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#updateHypertyInstance",
    "access": null,
    "description": "Function to update an Hyperty",
    "lineNumber": 587,
    "params": [
      {
        "name": "resource",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 500,
    "kind": "method",
    "name": "registerSubscriber",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#registerSubscriber",
    "access": null,
    "description": "register a new subscriber in the dataObject registered",
    "lineNumber": 604,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectURL",
        "description": "dataObject URL"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "subscriberURL",
        "description": "subscriber URL"
      }
    ]
  },
  {
    "__docId__": 501,
    "kind": "method",
    "name": "getDataObjectSubscribers",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#getDataObjectSubscribers",
    "access": null,
    "description": "get the subscribers registered within a dataObject",
    "lineNumber": 619,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectURL",
        "description": "dataObject URL"
      },
      {
        "nullable": null,
        "types": [
          "Array<String>"
        ],
        "spread": false,
        "optional": false,
        "name": "Substribers",
        "description": "List"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 502,
    "kind": "method",
    "name": "registerDataObject",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#registerDataObject",
    "access": null,
    "description": "To register a new Data Object in the runtime which returns the dataObjectURL allocated to the new Data Object.",
    "lineNumber": 639,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "identifier"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectschema",
        "description": "dataObjectschema"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectUrl",
        "description": "dataObjectUrl"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectReporter",
        "description": "dataObjectReporter"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "dataObject resources"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "authorise",
        "description": "list of pre authorised authorised IDs"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 503,
    "kind": "method",
    "name": "_getResourcesAndSchemes",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#_getResourcesAndSchemes",
    "access": null,
    "description": null,
    "lineNumber": 742,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "descriptor",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 504,
    "kind": "method",
    "name": "checkRegisteredURLs",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#checkRegisteredURLs",
    "access": null,
    "description": "method that returns previously registered Hyperty or DataObjects URLS, for given characteristics",
    "lineNumber": 788,
    "params": [
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "object or hyperty charateristics info"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "addressURL"
      ],
      "spread": false,
      "description": "addressURL     return the URL if there is any previousy registered URL, return undefined otherwise"
    }
  },
  {
    "__docId__": 505,
    "kind": "method",
    "name": "checkHypertyP2PHandler",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#checkHypertyP2PHandler",
    "access": null,
    "description": null,
    "lineNumber": 849,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "hypertyURL",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 506,
    "kind": "method",
    "name": "registerHyperty",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#registerHyperty",
    "access": null,
    "description": "To register a new Hyperty in the runtime which returns the HypertyURL allocated to the new Hyperty.",
    "lineNumber": 917,
    "params": [
      {
        "nullable": null,
        "types": [
          "Sandbox"
        ],
        "spread": false,
        "optional": false,
        "name": "sandbox",
        "description": "sandbox"
      },
      {
        "nullable": null,
        "types": [
          "HypertyCatalogueURL"
        ],
        "spread": false,
        "optional": false,
        "name": "HypertyCatalogueURL",
        "description": "descriptor"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "HypertyURL"
      ],
      "spread": false,
      "description": "HypertyURL"
    }
  },
  {
    "__docId__": 507,
    "kind": "method",
    "name": "unregisterHyperty",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#unregisterHyperty",
    "access": null,
    "description": "To unregister a previously registered Hyperty",
    "lineNumber": 1082,
    "params": [
      {
        "nullable": null,
        "types": [
          "HypertyURL"
        ],
        "spread": false,
        "optional": false,
        "name": "HypertyURL",
        "description": "url        url"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 508,
    "kind": "method",
    "name": "discoverProtostub",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#discoverProtostub",
    "access": null,
    "description": "To discover protocol stubs available in the runtime for a certain domain. If available, it returns the runtime url for the protocol stub that connects to the requested domain. Required by the runtime BUS to route messages to remote servers or peers (do we need something similar for Hyperties?).",
    "lineNumber": 1115,
    "params": [
      {
        "nullable": null,
        "types": [
          "DomainURL"
        ],
        "spread": false,
        "optional": false,
        "name": "DomainURL",
        "description": "url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RuntimeURL"
      ],
      "spread": false,
      "description": "RuntimeURL"
    }
  },
  {
    "__docId__": 509,
    "kind": "method",
    "name": "discoverP2PStub",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#discoverP2PStub",
    "access": null,
    "description": "To discover protocol stubs available in the runtime for a certain domain. If available, it returns the runtime url for the protocol stub that connects to the requested domain. Required by the runtime BUS to route messages to remote servers or peers (do we need something similar for Hyperties?).",
    "lineNumber": 1141,
    "params": [
      {
        "nullable": null,
        "types": [
          "RuntimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "RuntimeURL",
        "description": "url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RuntimeURL"
      ],
      "spread": false,
      "description": "RuntimeURL"
    }
  },
  {
    "__docId__": 510,
    "kind": "method",
    "name": "registerStub",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#registerStub",
    "access": null,
    "description": "To register a new Protocol Stub in the runtime including as input parameters the function to postMessage, the DomainURL that is connected with the stub, which returns the RuntimeURL allocated to the new ProtocolStub.",
    "lineNumber": 1180,
    "params": [
      {
        "nullable": null,
        "types": [
          "Sandbox"
        ],
        "spread": false,
        "optional": false,
        "name": "Sandbox",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "stubID"
        ],
        "spread": false,
        "optional": false,
        "name": "Domain",
        "description": "or hyperty runtime to register the stub"
      },
      {
        "nullable": null,
        "types": [
          "descriptorURL"
        ],
        "spread": false,
        "optional": false,
        "name": "Catalogue",
        "description": "URL of the Protostub descriptor"
      },
      {
        "nullable": null,
        "types": [
          "descriptor"
        ],
        "spread": false,
        "optional": false,
        "name": "Protostub",
        "description": "descriptor"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RuntimeProtoStubURL"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 511,
    "kind": "method",
    "name": "_onProtostubStatusEvent",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#_onProtostubStatusEvent",
    "access": null,
    "description": "To Process status events fired by protostubs",
    "lineNumber": 1272,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "Event Message"
      }
    ]
  },
  {
    "__docId__": 512,
    "kind": "method",
    "name": "unregisterStub",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#unregisterStub",
    "access": null,
    "description": "To unregister a previously registered protocol stub",
    "lineNumber": 1346,
    "params": [
      {
        "nullable": null,
        "types": [
          "HypertyRuntimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "HypertyRuntimeURL",
        "description": "hypertyRuntimeURL"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "registerIdpProxy",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#registerIdpProxy",
    "access": null,
    "description": "To register a new Identity Provider proxy in the runtime including as input parameters the function to postMessage, the DomainURL that is connected with the stub, which returns the RuntimeURL allocated to the new ProtocolStub.",
    "lineNumber": 1366,
    "params": [
      {
        "nullable": null,
        "types": [
          "Sandbox"
        ],
        "spread": false,
        "optional": false,
        "name": "Sandbox",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "DomainURL"
        ],
        "spread": false,
        "optional": false,
        "name": "DomainURL",
        "description": "service provider domain"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RuntimeIdpProxyURL"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 514,
    "kind": "method",
    "name": "discoverIdpProxy",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#discoverIdpProxy",
    "access": null,
    "description": "To discover idpProxy stubs available in the runtime for a certain domain. If available, it returns the runtime url for the idpProxy stub that connects to the requested domain. Required by the runtime BUS to route messages to remote servers or peers",
    "lineNumber": 1407,
    "params": [
      {
        "nullable": null,
        "types": [
          "DomainURL"
        ],
        "spread": false,
        "optional": false,
        "name": "DomainURL",
        "description": "url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RuntimeURL"
      ],
      "spread": false,
      "description": "RuntimeURL         idpProxyUrl"
    }
  },
  {
    "__docId__": 515,
    "kind": "method",
    "name": "registerPEP",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#registerPEP",
    "access": null,
    "description": "To register a new Policy Enforcer in the runtime including as input parameters the function to postMessage, the HypertyURL associated with the PEP, which returns the RuntimeURL allocated to the new Policy Enforcer component.",
    "lineNumber": 1434,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message.Message"
        ],
        "spread": false,
        "optional": false,
        "name": "postMessage",
        "description": "postMessage"
      },
      {
        "nullable": null,
        "types": [
          "HypertyURL"
        ],
        "spread": false,
        "optional": false,
        "name": "HypertyURL",
        "description": "hyperty"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "HypertyRuntimeURL"
      ],
      "spread": false,
      "description": "HypertyRuntimeURL"
    }
  },
  {
    "__docId__": 516,
    "kind": "method",
    "name": "unregisterPEP",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#unregisterPEP",
    "access": null,
    "description": "To unregister a previously registered protocol stub",
    "lineNumber": 1449,
    "params": [
      {
        "nullable": null,
        "types": [
          "HypertyRuntimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "HypertyRuntimeURL",
        "description": "HypertyRuntimeURL"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 517,
    "kind": "method",
    "name": "getSandbox",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#getSandbox",
    "access": null,
    "description": "To discover sandboxes available in the runtime for a certain domain. Required by the runtime UA to avoid more than one sandbox for the same domain.",
    "lineNumber": 1470,
    "params": [
      {
        "nullable": null,
        "types": [
          "DomainURL"
        ],
        "spread": false,
        "optional": false,
        "name": "DomainURL",
        "description": "url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RuntimeSandbox"
      ],
      "spread": false,
      "description": "RuntimeSandbox"
    }
  },
  {
    "__docId__": 518,
    "kind": "method",
    "name": "resolveNormalStub",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#resolveNormalStub",
    "access": null,
    "description": null,
    "lineNumber": 1515,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 519,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#resolve",
    "access": null,
    "description": "To verify if source is valid and to resolve target runtime url address if needed (eg protostub runtime url in case the message is to be dispatched to a remote endpoint).",
    "lineNumber": 1614,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<URL.URL>"
      ],
      "spread": false,
      "description": "Promise <URL.URL>"
    }
  },
  {
    "__docId__": 520,
    "kind": "method",
    "name": "isLegacy",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#isLegacy",
    "access": null,
    "description": "To verify if url is from a legacy domain.",
    "lineNumber": 1682,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 521,
    "kind": "method",
    "name": "isLocal",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#isLocal",
    "access": null,
    "description": "To verify if URL is locally registered or not.",
    "lineNumber": 1742,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 522,
    "kind": "method",
    "name": "isInterworkingProtoStub",
    "memberof": "src/registry/Registry.js~Registry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/Registry.js~Registry#isInterworkingProtoStub",
    "access": null,
    "description": "To verify if protostub is to interwork with a legacy domain.",
    "lineNumber": 1794,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeProtostubURL",
        "description": "The runtime URL of the Protostub"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 523,
    "kind": "file",
    "name": "src/registry/RegistryDataModel.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n/**\r\n*   @author: Gil Dias (gil.dias@tecnico.ulisboa.pt)\r\n*   Registry Data Model includes all Objects to be handled by the Registry functionality including\r\n*/\r\nclass RegistryDataModel {\r\n\r\n  constructor(id, url, descriptorURL, p2pRequester, startingTime, lastModified, status, stubs, stubsConfiguration) {\r\n    let _this = this;\r\n\r\n    _this._id = id;\r\n    _this._url = url;\r\n    _this._descriptorURL = descriptorURL;\r\n    _this._startingTime = startingTime;\r\n    _this._lastModified = lastModified;\r\n    _this._status = status;\r\n    _this._stubs = stubs;\r\n    _this._stubsConfiguration = stubsConfiguration;\r\n    _this._p2pRequester = p2pRequester;\r\n  }\r\n\r\n  get id() {\r\n    let _this = this;\r\n    return _this._id;\r\n  }\r\n\r\n  get url() {\r\n    let _this = this;\r\n    return _this._url;\r\n  }\r\n\r\n  get descriptor() {\r\n    let _this = this;\r\n    return _this._descriptorURL;\r\n  }\r\n\r\n  get p2pRequester() {\r\n    let _this = this;\r\n    return _this._p2pRequester;\r\n  }\r\n\r\n  get lastModified() {\r\n    let _this = this;\r\n    return _this._lastModified;\r\n  }\r\n\r\n}\r\n\r\nexport default RegistryDataModel;\r\n",
    "static": true,
    "longname": "src/registry/RegistryDataModel.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 524,
    "kind": "class",
    "name": "RegistryDataModel",
    "memberof": "src/registry/RegistryDataModel.js",
    "static": true,
    "longname": "src/registry/RegistryDataModel.js~RegistryDataModel",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/registry/RegistryDataModel.js",
    "importStyle": "RegistryDataModel",
    "description": "  @author: Gil Dias (gil.dias@tecnico.ulisboa.pt)\n  Registry Data Model includes all Objects to be handled by the Registry functionality including",
    "lineNumber": 27,
    "interface": false
  },
  {
    "__docId__": 525,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/registry/RegistryDataModel.js~RegistryDataModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/RegistryDataModel.js~RegistryDataModel#constructor",
    "access": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "id",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "descriptorURL",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2pRequester",
        "types": [
          "*"
        ]
      },
      {
        "name": "startingTime",
        "types": [
          "*"
        ]
      },
      {
        "name": "lastModified",
        "types": [
          "*"
        ]
      },
      {
        "name": "status",
        "types": [
          "*"
        ]
      },
      {
        "name": "stubs",
        "types": [
          "*"
        ]
      },
      {
        "name": "stubsConfiguration",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 526,
    "kind": "get",
    "name": "id",
    "memberof": "src/registry/RegistryDataModel.js~RegistryDataModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/RegistryDataModel.js~RegistryDataModel#id",
    "access": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 527,
    "kind": "get",
    "name": "url",
    "memberof": "src/registry/RegistryDataModel.js~RegistryDataModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/RegistryDataModel.js~RegistryDataModel#url",
    "access": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 528,
    "kind": "get",
    "name": "descriptor",
    "memberof": "src/registry/RegistryDataModel.js~RegistryDataModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/RegistryDataModel.js~RegistryDataModel#descriptor",
    "access": null,
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 529,
    "kind": "get",
    "name": "p2pRequester",
    "memberof": "src/registry/RegistryDataModel.js~RegistryDataModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/RegistryDataModel.js~RegistryDataModel#p2pRequester",
    "access": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 530,
    "kind": "get",
    "name": "lastModified",
    "memberof": "src/registry/RegistryDataModel.js~RegistryDataModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/registry/RegistryDataModel.js~RegistryDataModel#lastModified",
    "access": null,
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 531,
    "kind": "file",
    "name": "src/runtime/Descriptors.js",
    "content": "import {divideURL, getConfigurationResources, buildURL} from '../utils/utils';\r\n\r\nclass Descriptors {\r\n\r\n  constructor(runtimeURL, catalogue, runtimeConfiguration) {\r\n    if (!runtimeURL) throw Error('The descriptor need to know the runtime url to be used');\r\n    if (!catalogue) throw Error('The descriptor needs the catalogue instance');\r\n    if (!runtimeConfiguration) throw Error('The descriptor needs the runtime configuration');\r\n\r\n    this.runtimeConfiguration = runtimeConfiguration;\r\n    this.runtimeURL = runtimeURL;\r\n    this.catalogue = catalogue;\r\n  }\r\n\r\n  getHypertyDescriptor(hypertyURL) {\r\n    return this.catalogue.getHypertyDescriptor(hypertyURL);\r\n  }\r\n\r\n  getStubDescriptor(stubURL) {\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let domain;\r\n      let protostub;\r\n      let protoStubURL;\r\n\r\n      let originDividedURL = divideURL(this.runtimeURL);\r\n      let originDomain = originDividedURL.domain;\r\n\r\n      if (stubURL.includes('://')) {\r\n        let dividedURL = divideURL(stubURL);\r\n        domain = dividedURL.domain;\r\n        let path = dividedURL.identity;\r\n        if (path)\r\n          protostub = path.substring(path.lastIndexOf('/') + 1);\r\n        else {\r\n            protostub = 'default';\r\n          }\r\n      } else {\r\n        protostub = 'default';\r\n        domain = stubURL;\r\n      }\r\n\r\n  /*    if (!domain) {\r\n        domain = stubURL;\r\n      }\r\n\r\n      if (!protostub) {\r\n        protostub = 'default';\r\n      } else {\r\n        protostub = protostub.substring(protostub.lastIndexOf('/') + 1);\r\n      }*/\r\n\r\n      protoStubURL = buildURL(this.runtimeConfiguration, 'catalogueURLs', 'protocolstub', protostub);\r\n      if (domain !== this.runtimeConfiguration.domain) {\r\n        if (!stubURL.indexOf('https') || !stubURL.indexOf('hyperty-catalogue')) {\r\n          protoStubURL = stubURL;\r\n        } else {\r\n\r\n          // TODO: check how to load form different configuration domain\r\n          let resource = getConfigurationResources(this.runtimeConfiguration, 'catalogueURLs', 'protocolstub');\r\n          protoStubURL = resource.prefix + domain + resource.suffix + protostub;\r\n        }\r\n      }\r\n\r\n      console.log('Load ProtocolStub for domain, ' + domain + ' : ', protoStubURL);\r\n      return this.catalogue.getStubDescriptor(protoStubURL).then((result) => {\r\n\r\n        resolve(result);\r\n\r\n      }).catch((error) => {\r\n\r\n        console.log('Error: ', error);\r\n\r\n        protostub = domain;\r\n        domain = originDomain;\r\n\r\n        let resource = getConfigurationResources(this.runtimeConfiguration, 'catalogueURLs', 'protocolstub');\r\n        protoStubURL = resource.prefix + domain + resource.suffix + protostub;\r\n\r\n        console.log('Fallback -> Load Protocolstub for domain, ' + domain + ' : ', protostub);\r\n        return this.catalogue.getStubDescriptor(protoStubURL);\r\n      }).then((result) => {\r\n        resolve(result);\r\n      }).catch((reason) => {\r\n        reject(reason);\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  getIdpProxyDescriptor(idpProxyURL) {\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let domain;\r\n      let idpproxy;\r\n      let protoStubURL;\r\n\r\n      let originDividedURL = divideURL(this.runtimeURL);\r\n      let originDomain = originDividedURL.domain;\r\n\r\n      if (idpProxyURL.includes('://')) {\r\n        let dividedURL = divideURL(idpProxyURL);\r\n        domain = dividedURL.domain;\r\n        let path = dividedURL.identity;\r\n        if (path)\r\n          idpproxy = path.substring(path.lastIndexOf('/') + 1);\r\n        else {\r\n            idpproxy = 'default';\r\n          }\r\n      } else {\r\n        idpproxy = 'default';\r\n        domain = idpProxyURL;\r\n      }\r\n\r\n\r\n      let resource = getConfigurationResources(this.runtimeConfiguration, 'catalogueURLs', 'idpProxy');\r\n\r\n      idpProxyURL = resource.prefix + domain + resource.suffix + idpproxy;\r\n      console.log('Load Idp Proxy for domain, ' + domain + ' : ', idpProxyURL);\r\n      return this.catalogue.getIdpProxyDescriptor(idpProxyURL).then((result) => {\r\n\r\n        resolve(result);\r\n\r\n      }).catch(() => {\r\n\r\n        idpproxy = domain;\r\n        domain = originDomain;\r\n\r\n        idpProxyURL = buildURL(this.runtimeConfiguration, 'catalogueURLs', 'idpProxy', idpproxy);\r\n\r\n        console.log('Load Idp Proxy for domain, ' + domain + ' : ', idpProxyURL);\r\n        return this.catalogue.getIdpProxyDescriptor(idpProxyURL);\r\n      }).then((result) => {\r\n        resolve(result);\r\n      }).catch((reason) => {\r\n        reject(reason);\r\n      });\r\n\r\n    });\r\n  }\r\n}\r\n\r\nexport default Descriptors;\r\n",
    "static": true,
    "longname": "src/runtime/Descriptors.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 532,
    "kind": "class",
    "name": "Descriptors",
    "memberof": "src/runtime/Descriptors.js",
    "static": true,
    "longname": "src/runtime/Descriptors.js~Descriptors",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/runtime/Descriptors.js",
    "importStyle": "Descriptors",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 533,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/runtime/Descriptors.js~Descriptors",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Descriptors.js~Descriptors#constructor",
    "access": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "runtimeURL",
        "types": [
          "*"
        ]
      },
      {
        "name": "catalogue",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtimeConfiguration",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 534,
    "kind": "member",
    "name": "runtimeConfiguration",
    "memberof": "src/runtime/Descriptors.js~Descriptors",
    "static": false,
    "longname": "src/runtime/Descriptors.js~Descriptors#runtimeConfiguration",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 535,
    "kind": "member",
    "name": "runtimeURL",
    "memberof": "src/runtime/Descriptors.js~Descriptors",
    "static": false,
    "longname": "src/runtime/Descriptors.js~Descriptors#runtimeURL",
    "access": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 536,
    "kind": "member",
    "name": "catalogue",
    "memberof": "src/runtime/Descriptors.js~Descriptors",
    "static": false,
    "longname": "src/runtime/Descriptors.js~Descriptors#catalogue",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 537,
    "kind": "method",
    "name": "getHypertyDescriptor",
    "memberof": "src/runtime/Descriptors.js~Descriptors",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Descriptors.js~Descriptors#getHypertyDescriptor",
    "access": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "hypertyURL",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 538,
    "kind": "method",
    "name": "getStubDescriptor",
    "memberof": "src/runtime/Descriptors.js~Descriptors",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Descriptors.js~Descriptors#getStubDescriptor",
    "access": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "stubURL",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 539,
    "kind": "method",
    "name": "getIdpProxyDescriptor",
    "memberof": "src/runtime/Descriptors.js~Descriptors",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Descriptors.js~Descriptors#getIdpProxyDescriptor",
    "access": null,
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "idpProxyURL",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 540,
    "kind": "file",
    "name": "src/runtime/Loader - Copy.js",
    "content": "import {divideURL, emptyObject} from '../utils/utils';\r\nimport AddressAllocation from '../allocation/AddressAllocation';\r\n\r\nclass Loader {\r\n\r\n  constructor(runtimeURL, runtimeConfiguration, runtimeDescriptorsInstance) {\r\n    if (!runtimeConfiguration) throw   Error('[Runtime.Loader] The descriptor need to know the runtime configuration');\r\n    if (!runtimeDescriptorsInstance) throw   Error('[Runtime.Loader] The descriptor need to know the runtime Descriptor instance');\r\n\r\n    this.runtimeConfiguration = runtimeConfiguration;\r\n    this.descriptors = runtimeDescriptorsInstance;\r\n  }\r\n\r\n  /**\r\n   * Set runtime url\r\n   * @param  {string} value runtimeURL\r\n   */\r\n  set runtimeURL(value) {\r\n    this._runtimeURL = value;\r\n  }\r\n\r\n  /**\r\n   * Get runtime url\r\n   * @return {string} value runtimeURL\r\n   */\r\n  get runtimeURL() {\r\n    return this._runtimeURL;\r\n  }\r\n\r\n  /**\r\n   * Set Registry component\r\n   * @param  {Registry} value Registry Component\r\n   */\r\n  set registry(value) {\r\n    this._registry = value;\r\n\r\n    // Install AddressAllocation\r\n    let addressAllocation = new AddressAllocation(this._runtimeURL, this._messagesBus, this._registry);\r\n    this._addressAllocation = addressAllocation;\r\n  }\r\n\r\n  /**\r\n   * Get Registry component\r\n   * @return {Registry} Registry component\r\n   */\r\n  get registry() {\r\n    return this._registry;\r\n  }\r\n\r\n  /**\r\n   * Set Message Bus component\r\n   * @param  {MessageBus} value Message bus component\r\n   */\r\n  set messageBus(value) {\r\n    this._messagesBus = value;\r\n  }\r\n\r\n  /**\r\n   * Get Message Bus component\r\n   * @return {MessageBus} Message Bus component\r\n   */\r\n  get messageBus() {\r\n    return this._messagesBus;\r\n  }\r\n\r\n  /**\r\n   * Set Runtime Factory component\r\n   * @param  {runtimeFactory} value Factory includes the specific implementations for each environment\r\n   */\r\n  set runtimeFactory(value) {\r\n    this._runtimeFactory = value;\r\n  }\r\n\r\n  /**\r\n   * Get Runtime Factory component\r\n   * @return {runtimeFactory} Runtime Factory component\r\n   */\r\n  get runtimeFactory() {\r\n    return this._runtimeFactory;\r\n  }\r\n\r\n  /**\r\n  * Deploy Hyperty from Catalogue URL\r\n  * @param  {URL.HypertyCatalogueURL}    hyperty hypertyDescriptor url;\r\n  */\r\n  loadHyperty(hypertyDescriptorURL) {\r\n\r\n    if (!this._readyToUse()) return false;\r\n    if (!hypertyDescriptorURL) throw new   Error('[Runtime.Loader] Hyperty descriptor url parameter is needed');\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let _hypertyURL;\r\n      let _hypertySandbox;\r\n      let _hypertyDescriptor;\r\n      let _hypertySourcePackage;\r\n      let haveError = false;\r\n\r\n      let errorReason = (reason) => {\r\n        console.  Error('[Runtime.Loader] Something failed on the deploy hyperty: ', reason);\r\n        reject(reason);\r\n      };\r\n\r\n      let handleError = (reason) => {\r\n        haveError = true;\r\n        reject(reason);\r\n      };\r\n\r\n      // Get Hyperty descriptor\r\n      // TODO: the request Module should be changed,\r\n      // because at this moment it is incompatible with nodejs;\r\n      // Probably we need to pass a factory like we do for sandboxes;\r\n      console.info('[Runtime.Loader] ------------------ Hyperty ------------------------');\r\n      console.info('[Runtime.Loader] Get hyperty descriptor for :', hypertyDescriptorURL);\r\n      return this.descriptors.getHypertyDescriptor(hypertyDescriptorURL)\r\n      .then((hypertyDescriptor) => {\r\n        // at this point, we have completed \"step 2 and 3\" as shown in https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md\r\n        console.info('[Runtime.Loader] 1: return hyperty descriptor');\r\n\r\n        // hyperty contains the full path of the catalogue URL, e.g.\r\n        // catalogue.rethink.eu/.well-known/..........\r\n        _hypertyDescriptor = hypertyDescriptor;\r\n\r\n        let sourcePackageURL = hypertyDescriptor.sourcePackageURL;\r\n\r\n        if (sourcePackageURL === '/sourcePackage') {\r\n          return hypertyDescriptor.sourcePackage;\r\n        }\r\n\r\n        // Get the hyperty source code\r\n        return this.runtimeCatalogue.getSourcePackageFromURL(sourcePackageURL);\r\n      }, handleError)\r\n      .then((sourcePackage) => {\r\n        if (haveError) return false;\r\n\r\n        console.info('[Runtime.Loader] 2: return hyperty source code');\r\n\r\n        // at this point, we have completed \"step 4 and 5\" as shown in https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md\r\n\r\n        _hypertySourcePackage = sourcePackage;\r\n\r\n        //\r\n        // steps 6 -- 9 are skipped.\r\n        // TODO: on release of core 0.2;\r\n        // TODO: Promise to check the policy engine\r\n\r\n        // mock-up code;\r\n        // temporary code, only\r\n        let policy = true;\r\n\r\n        return policy;\r\n      }, handleError)\r\n      .then((policyResult) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 3: return policy engine result' + policyResult);\r\n\r\n        // we have completed step 6 to 9 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n        //\r\n        // Steps 6 -- 9\r\n        // As a result of the sipped steps, we know at this point if we execute\r\n        // inSameSandbox or not.\r\n        //\r\n\r\n        // For testing, just assume we execute in same Sandbox.\r\n        let inSameSandbox = true;\r\n        let sandbox;\r\n\r\n        if (inSameSandbox) {\r\n\r\n          // this don't need be a Promise;\r\n          sandbox = this.registry.getAppSandbox();\r\n\r\n          // we have completed step 11 here.\r\n        } else {\r\n\r\n          let domain = divideURL(hypertyDescriptorURL).domain;\r\n\r\n          // getSandbox, this will return a promise;\r\n          sandbox = this.registry.getSandbox(domain);\r\n        }\r\n\r\n        // this will return the sandbox or one promise to getSandbox;\r\n        return sandbox;\r\n      }, handleError)\r\n      .then((sandbox) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 4: return the sandbox', sandbox);\r\n\r\n        // Return the sandbox indepentely if it running in the same sandbox or not\r\n        // we have completed step 14 here.\r\n        return sandbox;\r\n      }, (reason) => {\r\n        if (haveError) return false;\r\n        console.  Error('[Runtime.Loader] 4.1: Try to register a new sandbox');\r\n\r\n        // check if the sandbox is registed for this hyperty descriptor url;\r\n        // Make Steps xxx --- xxx\r\n        // Instantiate the Sandbox\r\n\r\n        let hypertyCapabilities = {};\r\n        if (_hypertyDescriptor && _hypertyDescriptor.hasOwnProperty('capabilities')) {\r\n          hypertyCapabilities = _hypertyDescriptor.stubCapabilities;\r\n        }\r\n\r\n        return this._runtimeFactory.createSandbox(hypertyCapabilities).then((sandbox) => {\r\n\r\n          sandbox.addListener('*', (msg) => {\r\n            this.messageBus.postMessage(msg);\r\n          });\r\n\r\n          return sandbox;\r\n        });\r\n      }, handleError)\r\n      .then((sandbox) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 5: return sandbox and register');\r\n\r\n        _hypertySandbox = sandbox;\r\n\r\n        let numberOfAddresses = 1;\r\n        return this._addressAllocation.create(this._registry._domain, numberOfAddresses, _hypertyDescriptor, 'hyperty');\r\n      }, handleError)\r\n      .then((addresses) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 6: return the addresses for the hyperty');\r\n\r\n        // Register hyperty\r\n        return this.registry.registerHyperty(_hypertySandbox, hypertyDescriptorURL, _hypertyDescriptor, addresses);\r\n      }, handleError)\r\n      .then((hypertyURL) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 7: Hyperty url, after register hyperty', hypertyURL);\r\n\r\n        // we have completed step 16 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n        _hypertyURL = hypertyURL;\r\n\r\n        // Extend original hyperty configuration;\r\n        let configuration = {};\r\n        if (!emptyObject(_hypertyDescriptor.configuration)) {\r\n          try {\r\n            configuration = Object.assign({}, JSON.parse(_hypertyDescriptor.configuration));\r\n          } catch (e) {\r\n            configuration = _hypertyDescriptor.configuration;\r\n          }\r\n        }\r\n        configuration.runtimeURL = this._runtimeURL;\r\n\r\n        // We will deploy the component - step 17 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n\r\n        try {\r\n          return _hypertySandbox.deployComponent(_hypertySourcePackage.sourceCode, _hypertyURL, configuration);\r\n        } catch (e) {\r\n          console.  Error('[Runtime.Loader] Error on deploy component:', e);\r\n          reject(e);\r\n        }\r\n      }, handleError)\r\n      .then((deployComponentStatus) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 8: Deploy component status for hyperty: ', deployComponentStatus);\r\n\r\n        // we have completed step 19 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n\r\n        // Add the message bus listener to the appSandbox or hypertSandbox;\r\n        this.messageBus.addListener(_hypertyURL, (msg) => {\r\n          _hypertySandbox.postMessage(msg);\r\n        });\r\n\r\n        // we have completed step 20 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n        let hyperty = {\r\n          runtimeHypertyURL: _hypertyURL,\r\n          status: deployComponentStatus\r\n        };\r\n\r\n        resolve(hyperty);\r\n\r\n        // we have completed step 21 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n        console.info('[Runtime.Loader] ------------------ END ------------------------');\r\n      }, handleError)\r\n      .catch(errorReason);\r\n    });\r\n  }\r\n\r\n  /**\r\n  * Deploy Stub from Catalogue URL or domain url\r\n  * @param  {URL.URL}     domain          domain\r\n  * @param  {Object}      p2pConfig       configuration of p2p\r\n  */\r\n  loadStub(protostubURL, p2pConfig) {\r\n\r\n    if (!this._readyToUse()) return false;\r\n    if (!protostubURL) throw new   Error('[Runtime.Loader.loadStub]ProtoStub descriptor url parameter is needed');\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      // to analyse if domain for p2pHandlers should be something else and not the default domain itself\r\n\r\n      let domain;\r\n\r\n      if (protostubURL.includes('://') ) {\r\n          domain = divideURL(protostubURL).domain;\r\n      } else {\r\n        domain = protostubURL;\r\n        }\r\n\r\n\r\n      let _stubSandbox;\r\n      let _stubDescriptor;\r\n      let _runtimeProtoStubURL;\r\n      let _stubSourcePackage;\r\n      let haveError = false;\r\n\r\n      let errorReason = (reason) => {\r\n        console.  Error('[Runtime.Loader.loadStub]Something failed on the deploy of protocolstub: ', reason);\r\n        reject(reason);\r\n      };\r\n\r\n      let handleError = (reason) => {\r\n        haveError = true;\r\n        reject(reason);\r\n      };\r\n\r\n      // Discover Protocol Stub\r\n      let discoverStub;\r\n      let isP2PHandler = false;\r\n      let isP2PRequester = false;\r\n\r\n      console.info('[Runtime.Loader.loadStub]------------------- ProtoStub ---------------------------\\n');\r\n      console.info('[Runtime.Loader.loadStub]Discover or Create a new ProtoStub for domain: ', domain);\r\n\r\n      // step 2 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n      if (p2pConfig) {\r\n\r\n        if (p2pConfig.hasOwnProperty('isHandlerStub') && p2pConfig.isHandlerStub) {\r\n          // step 6 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          discoverStub = this.registry.discoverP2PStub();\r\n          isP2PHandler = true;\r\n        } else {\r\n          isP2PRequester = true;\r\n\r\n          // step 4 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          let p2pHandlerRuntimeURL = p2pConfig.p2pHandlerStub;\r\n\r\n          // step 5 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          discoverStub = this.registry.discoverP2PStub(p2pHandlerRuntimeURL);\r\n        }\r\n\r\n      } else {\r\n        // step 3 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n        discoverStub = this.registry.discoverProtostub(domain);\r\n      }\r\n\r\n      discoverStub.then((runtimeProtoStub) => {\r\n        // Is registed?\r\n        console.info('[Runtime.Loader.loadStub]1. Proto Stub Discovered for ', domain, ': ', runtimeProtoStub);\r\n        if (isP2PHandler) console.info(runtimeProtoStub + ' is a P2PHandlerStub');\r\n        if (isP2PRequester) console.info(runtimeProtoStub + ' is a P2PRequesterStub');\r\n        if (!isP2PHandler && !isP2PRequester) console.info(runtimeProtoStub + ' is a regular msg node protostub');\r\n\r\n        // step 23 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n        resolve(runtimeProtoStub);\r\n        console.info(' [Runtime.Loader]------------------- END ---------------------------\\n');\r\n      })\r\n      .catch((reason) => {\r\n\r\n        // is not registed?\r\n        console.info('[Runtime.Loader.loadStub]1. Proto Stub not found ' + reason);\r\n\r\n        // step 8 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n        this.descriptors.getStubDescriptor(protostubURL)\r\n        .then((stubDescriptor) => {\r\n\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader.loadStub]2. return the ProtoStub descriptor');\r\n\r\n          // step 9 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          _stubDescriptor = stubDescriptor;\r\n\r\n          let sourcePackageURL = stubDescriptor.sourcePackageURL;\r\n\r\n          if (sourcePackageURL === '/sourcePackage') {\r\n            return stubDescriptor.sourcePackage;\r\n          }\r\n\r\n          // step 10 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.runtimeCatalogue.getSourcePackageFromURL(sourcePackageURL);\r\n        }, handleError)\r\n        .catch(errorReason)\r\n        .then((stubSourcePackage) => {\r\n          if (haveError) return false;\r\n\r\n          // step 11 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub]3. return the ProtoStub Source Code');\r\n          _stubSourcePackage = stubSourcePackage;\r\n\r\n          // this will return the sandbox or one promise to getSandbox;\r\n          // step 12 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.registry.getSandbox(domain);\r\n        })\r\n        .then((stubSandbox) => {\r\n          if (haveError) return false;\r\n\r\n          // step 15 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub]4. if the sandbox is registered then return the sandbox ', stubSandbox);\r\n\r\n          _stubSandbox = stubSandbox;\r\n          return stubSandbox;\r\n        })\r\n        .catch((reason) => {\r\n          if (haveError) return false;\r\n\r\n          // step 13 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub]5. Sandbox was not found, creating a new one ', reason);\r\n\r\n          // check if the sandbox is registed for this stub descriptor url;\r\n\r\n          // According to debug, it seems RuntimeCatalogue does not support yet constraints. It appears empty!!!!\r\n\r\n          let stubCapabilities = {};\r\n          if (_stubDescriptor && _stubDescriptor.hasOwnProperty('constraints')) {\r\n            stubCapabilities = _stubDescriptor.constraints;\r\n          }\r\n\r\n          // step 14 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this._runtimeFactory.createSandbox(stubCapabilities).then((sandbox) => {\r\n\r\n            sandbox.addListener('*', (msg) => {\r\n              this.messageBus.postMessage(msg);\r\n            });\r\n\r\n            return sandbox;\r\n          });\r\n\r\n        })\r\n        .then((sandbox) => {\r\n          if (haveError) return false;\r\n\r\n          // step 16 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub]6. return the sandbox instance and register', sandbox, 'to domain ', domain);\r\n\r\n          _stubSandbox = sandbox;\r\n\r\n          // step 17 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.registry.registerStub(_stubSandbox, domain, p2pConfig);\r\n        }, handleError)\r\n        .then((runtimeProtoStub) => {\r\n          if (haveError) return false;\r\n\r\n          // step 23 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub] 7. return the runtime protostub url: ', runtimeProtoStub);\r\n\r\n          _runtimeProtoStubURL = runtimeProtoStub.url;\r\n\r\n          // Extend original hyperty configuration;\r\n          let configuration = {};\r\n          if (!emptyObject(_stubDescriptor.configuration)) {\r\n            try {\r\n              configuration = Object.assign({}, JSON.parse(_stubDescriptor.configuration));\r\n            } catch (e) {\r\n              configuration = _stubDescriptor.configuration;\r\n            }\r\n          }\r\n\r\n          if (p2pConfig) {\r\n            try {\r\n              configuration = Object.assign(configuration, JSON.parse(p2pConfig));\r\n            } catch (e) {\r\n              configuration = Object.assign(configuration, p2pConfig);\r\n            }\r\n          }\r\n\r\n          configuration.runtimeURL = this._runtimeURL;\r\n\r\n          // step 24 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          try {\r\n            return _stubSandbox.deployComponent(_stubSourcePackage.sourceCode, _runtimeProtoStubURL, configuration);\r\n          } catch (e) {\r\n            console.    Error('[Runtime.Loader.loadStub] Error on deploy component:', e);\r\n            reject(e);\r\n          }\r\n        }, handleError)\r\n        .then((deployComponentStatus) => {\r\n          if (haveError) return false;\r\n\r\n          // step 26 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub] 8: return deploy component for sandbox status: ', deployComponentStatus);\r\n\r\n          // step 27 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          // Add the message bus listener\r\n          this.messageBus.addListener(_runtimeProtoStubURL, (msg) => {\r\n            _stubSandbox.postMessage(msg);\r\n          });\r\n\r\n          // step 28 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          let stub;\r\n          if (p2pConfig) {\r\n            console.log('[Runtime.Loader.loadStub] p2pConfig: ', p2pConfig);\r\n\r\n            if (p2pConfig.hasOwnProperty('isHandlerStub')) stub = this.registry.p2pHandlerStub[this._runtimeURL];\r\n            if (p2pConfig.hasOwnProperty('p2pRequesterStub')) stub = this.registry.p2pRequesterStub[this._runtimeURL];\r\n          } else {\r\n            stub = this.registry.protostubsList[domain];\r\n          }\r\n\r\n          console.log('[Runtime.Loader.loadStub] Stub: ', stub);\r\n          resolve(stub.url);\r\n          console.info('[Runtime.Loader.loadStub]------------------- END ---------------------------\\n');\r\n        }, handleError)\r\n        .catch(errorReason);\r\n\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * Deploy idpProxy from Catalogue URL or domain url\r\n  * @param  {URL.URL}     domain          domain\r\n  */\r\n  loadIdpProxy(idpProxyURL) {\r\n\r\n    if (!this._readyToUse()) return false;\r\n    if (!idpProxyURL) throw new   Error('[Runtime.Loader] IdpProxy descriptor url parameter is needed');\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let domain = divideURL(idpProxyURL).domain;\r\n\r\n      if (!domain) {\r\n        domain = idpProxyURL;\r\n      }\r\n\r\n      let _proxySandbox;\r\n      let _proxyDescriptor;\r\n      let _runtimeIdpProxyURL;\r\n      let _proxySourcePackage;\r\n      let haveError = false;\r\n\r\n      let errorReason = (reason) => {\r\n        console.  Error('[Runtime.Loader] Something failed on the deploy of IdpProxy: ', reason);\r\n        reject(reason);\r\n      };\r\n\r\n      let handleError = (reason) => {\r\n        haveError = true;\r\n        reject(reason);\r\n      };\r\n\r\n      // Discover IDPProxy\r\n      console.info('[Runtime.Loader] ------------------- IDP Proxy Deploy ---------------------------\\n');\r\n      console.info('[Runtime.Loader] Discover or Create a new IdpProxy for domain/URL: ', domain);\r\n      return this.registry.discoverIdpProxy(domain)\r\n      .then((runtimeIdpProxyURL) => {\r\n        // Is registed?\r\n        console.info('[Runtime.Loader] 1. IDPProxy Discovered: ', runtimeIdpProxyURL);\r\n\r\n        // we have completed step 2 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n        let idpProxy = this.registry.idpProxyList[domain];\r\n        console.log('Deployed: ', idpProxy);\r\n\r\n        resolve(idpProxy);\r\n        console.info('[Runtime.Loader] ------------------- END ---------------------------\\n');\r\n      })\r\n      .catch((reason) => {\r\n\r\n        // is not registed?\r\n        console.info('[Runtime.Loader] 1. IdpProxy not found:', reason);\r\n\r\n        // we have completed step 3 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n        // we need to get ProtoStub descriptor step 4 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n        this.descriptors.getIdpProxyDescriptor(idpProxyURL)\r\n        .then((proxyDescriptor) => {\r\n\r\n          console.info('[Runtime.Loader] 2. Return the IDPProxy descriptor');\r\n\r\n          // we have completed step 5 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          _proxyDescriptor = proxyDescriptor;\r\n\r\n          let sourcePackageURL = proxyDescriptor.sourcePackageURL;\r\n\r\n          if (sourcePackageURL === '/sourcePackage') {\r\n            return proxyDescriptor.sourcePackage;\r\n          }\r\n\r\n          // we need to get ProtoStub Source code from descriptor - step 6 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.runtimeCatalogue.getSourcePackageFromURL(sourcePackageURL);\r\n        }, handleError)\r\n        .then((sourcePackage) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 3. return the IDPProxy source package');\r\n\r\n          // we have completed step 7 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n          _proxySourcePackage = sourcePackage;\r\n\r\n          // TODO: Check on PEP (policy Engine) if we need the sandbox and check if the Sandbox Factory have the context sandbox;\r\n          let policy = true;\r\n          return policy;\r\n        }, handleError)\r\n        .then((policy) => {\r\n          if (haveError) return false;\r\n\r\n          // this will return the sandbox or one promise to getSandbox;\r\n          return this.registry.getSandbox(domain);\r\n        })\r\n        .then((proxySandbox) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 4. if the sandbox is registered then return the sandbox', proxySandbox);\r\n\r\n          _proxySandbox = proxySandbox;\r\n          return proxySandbox;\r\n        })\r\n        .catch((reason) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 5. Sandbox was not found, creating a new one', reason);\r\n\r\n          let proxyCapabilities = {};\r\n          if (_proxyDescriptor && _proxyDescriptor.hasOwnProperty('capabilities')) {\r\n            _proxyDescriptor = _proxyDescriptor.stubCapabilities;\r\n          }\r\n\r\n          return this._runtimeFactory.createSandbox(proxyCapabilities).then((sandbox) => {\r\n\r\n            sandbox.addListener('*', (msg) => {\r\n              this.messageBus.postMessage(msg);\r\n            });\r\n\r\n            return sandbox;\r\n          });\r\n        })\r\n        .then((sandbox) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 6. return the sandbox instance and register', sandbox, 'to domain ', domain);\r\n\r\n          _proxySandbox = sandbox;\r\n\r\n          // we need register stub on registry - step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.registry.registerIdpProxy(sandbox, domain);\r\n        }, handleError)\r\n        .then((runtimeIdpProxyURL) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 7. Return the runtime Idp Proxy URL: ', runtimeIdpProxyURL);\r\n\r\n          // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n          _runtimeIdpProxyURL = runtimeIdpProxyURL;\r\n\r\n          // Extend original hyperty configuration;\r\n          let configuration = {};\r\n          if (!emptyObject(_proxyDescriptor.configuration)) {\r\n            try {\r\n              configuration = Object.assign({}, JSON.parse(_proxyDescriptor.configuration));\r\n            } catch (e) {\r\n              configuration = _proxyDescriptor.configuration;\r\n            }\r\n          }\r\n          configuration.runtimeURL = this._runtimeURL;\r\n\r\n          // Deploy Component step xxx\r\n          try {\r\n            return _proxySandbox.deployComponent(_proxySourcePackage.sourceCode, runtimeIdpProxyURL, configuration);\r\n          } catch (e) {\r\n            console.  Error('[Runtime.Loader] Error on deploy component:', e);\r\n            reject(e);\r\n          }\r\n        }, handleError)\r\n        .then((deployComponentStatus) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 8: return deploy component for sandbox status: ', deployComponentStatus);\r\n\r\n          // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n          // Add the message bus listener\r\n          this.messageBus.addListener(_runtimeIdpProxyURL, (msg) => {\r\n            _proxySandbox.postMessage(msg);\r\n          });\r\n\r\n          // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n          // Load Stub function resolved with success;\r\n          // let idpProxy = {\r\n          //   runtimeIdpProxyURL: _runtimeIdpProxyURL,\r\n          //   status: deployComponentStatus\r\n          // };\r\n\r\n          this.registry.idpProxyList[domain].status = 'deployed';\r\n          let idpProxy = this.registry.idpProxyList[domain];\r\n\r\n          console.log('Deployed: ', idpProxy);\r\n\r\n          resolve(idpProxy);\r\n          console.info('[Runtime.Loader] ------------------- END ---------------------------\\n');\r\n\r\n        }, handleError)\r\n        .catch(errorReason);\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  // Check if the loader is ready to load all components\r\n  _readyToUse() {\r\n\r\n    let status = false;\r\n\r\n    if (!this._runtimeURL) throw new   Error('[Runtime.Loader] The loader need the runtime url address');\r\n    if (!this._messagesBus) throw new   Error('[Runtime.Loader] The loader need the messageBus component');\r\n    if (!this._registry) throw new   Error('[Runtime.Loader] The loader need the registry component');\r\n    if (!this._runtimeFactory) throw new   Error('[Runtime.Loader] The loader need the runtime factory component');\r\n\r\n    status = true;\r\n    return status;\r\n  }\r\n\r\n}\r\n\r\nexport default Loader;\r\n",
    "static": true,
    "longname": "src/runtime/Loader - Copy.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 541,
    "kind": "class",
    "name": "Loader",
    "memberof": "src/runtime/Loader - Copy.js",
    "static": true,
    "longname": "src/runtime/Loader - Copy.js~Loader",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/runtime/Loader - Copy.js",
    "importStyle": "Loader",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 542,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#constructor",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "runtimeURL",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtimeConfiguration",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtimeDescriptorsInstance",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 543,
    "kind": "member",
    "name": "runtimeConfiguration",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#runtimeConfiguration",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 544,
    "kind": "member",
    "name": "descriptors",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#descriptors",
    "access": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 545,
    "kind": "set",
    "name": "runtimeURL",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#runtimeURL",
    "access": null,
    "description": "Set runtime url",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "runtimeURL"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 546,
    "kind": "member",
    "name": "_runtimeURL",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#_runtimeURL",
    "access": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 547,
    "kind": "get",
    "name": "runtimeURL",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#runtimeURL",
    "access": null,
    "description": "Get runtime url",
    "lineNumber": 26,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "value runtimeURL"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 548,
    "kind": "set",
    "name": "registry",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#registry",
    "access": null,
    "description": "Set Registry component",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "Registry"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Registry Component"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 549,
    "kind": "member",
    "name": "_registry",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#_registry",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 550,
    "kind": "member",
    "name": "_addressAllocation",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#_addressAllocation",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 551,
    "kind": "get",
    "name": "registry",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#registry",
    "access": null,
    "description": "Get Registry component",
    "lineNumber": 46,
    "return": {
      "nullable": null,
      "types": [
        "Registry"
      ],
      "spread": false,
      "description": "Registry component"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 552,
    "kind": "set",
    "name": "messageBus",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#messageBus",
    "access": null,
    "description": "Set Message Bus component",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Message bus component"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 553,
    "kind": "member",
    "name": "_messagesBus",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#_messagesBus",
    "access": null,
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 554,
    "kind": "get",
    "name": "messageBus",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#messageBus",
    "access": null,
    "description": "Get Message Bus component",
    "lineNumber": 62,
    "return": {
      "nullable": null,
      "types": [
        "MessageBus"
      ],
      "spread": false,
      "description": "Message Bus component"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 555,
    "kind": "set",
    "name": "runtimeFactory",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#runtimeFactory",
    "access": null,
    "description": "Set Runtime Factory component",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "runtimeFactory"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Factory includes the specific implementations for each environment"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 556,
    "kind": "member",
    "name": "_runtimeFactory",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#_runtimeFactory",
    "access": null,
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 557,
    "kind": "get",
    "name": "runtimeFactory",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#runtimeFactory",
    "access": null,
    "description": "Get Runtime Factory component",
    "lineNumber": 78,
    "return": {
      "nullable": null,
      "types": [
        "runtimeFactory"
      ],
      "spread": false,
      "description": "Runtime Factory component"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 558,
    "kind": "method",
    "name": "loadHyperty",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#loadHyperty",
    "access": null,
    "description": "Deploy Hyperty from Catalogue URL",
    "lineNumber": 86,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.HypertyCatalogueURL"
        ],
        "spread": false,
        "optional": false,
        "name": "hyperty",
        "description": "hypertyDescriptor url;"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 559,
    "kind": "method",
    "name": "loadStub",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#loadStub",
    "access": null,
    "description": "Deploy Stub from Catalogue URL or domain url",
    "lineNumber": 288,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "domain"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "p2pConfig",
        "description": "configuration of p2p"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 560,
    "kind": "method",
    "name": "loadIdpProxy",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#loadIdpProxy",
    "access": null,
    "description": "Deploy idpProxy from Catalogue URL or domain url",
    "lineNumber": 520,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "domain"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 561,
    "kind": "method",
    "name": "_readyToUse",
    "memberof": "src/runtime/Loader - Copy.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader - Copy.js~Loader#_readyToUse",
    "access": null,
    "description": null,
    "lineNumber": 704,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 562,
    "kind": "file",
    "name": "src/runtime/Loader.js",
    "content": "import {divideURL, emptyObject} from '../utils/utils';\r\nimport AddressAllocation from '../allocation/AddressAllocation';\r\n\r\nclass Loader {\r\n\r\n  constructor(runtimeURL, runtimeConfiguration, runtimeDescriptorsInstance) {\r\n    if (!runtimeConfiguration) throw   Error('[Runtime.Loader] The descriptor need to know the runtime configuration');\r\n    if (!runtimeDescriptorsInstance) throw   Error('[Runtime.Loader] The descriptor need to know the runtime Descriptor instance');\r\n\r\n    this.runtimeConfiguration = runtimeConfiguration;\r\n    this.descriptors = runtimeDescriptorsInstance;\r\n  }\r\n\r\n  /**\r\n   * Set runtime url\r\n   * @param  {string} value runtimeURL\r\n   */\r\n  set runtimeURL(value) {\r\n    this._runtimeURL = value;\r\n  }\r\n\r\n  /**\r\n   * Get runtime url\r\n   * @return {string} value runtimeURL\r\n   */\r\n  get runtimeURL() {\r\n    return this._runtimeURL;\r\n  }\r\n\r\n  /**\r\n   * Set Registry component\r\n   * @param  {Registry} value Registry Component\r\n   */\r\n  set registry(value) {\r\n    this._registry = value;\r\n\r\n    // Install AddressAllocation\r\n    let addressAllocation = AddressAllocation.instance;\r\n    this._addressAllocation = addressAllocation;\r\n\r\n    console.log('[Loader - AddressAllocation] - ', addressAllocation);\r\n  }\r\n\r\n  /**\r\n   * Get Registry component\r\n   * @return {Registry} Registry component\r\n   */\r\n  get registry() {\r\n    return this._registry;\r\n  }\r\n\r\n  /**\r\n   * Set Message Bus component\r\n   * @param  {MessageBus} value Message bus component\r\n   */\r\n  set messageBus(value) {\r\n    this._messagesBus = value;\r\n  }\r\n\r\n  /**\r\n   * Get Message Bus component\r\n   * @return {MessageBus} Message Bus component\r\n   */\r\n  get messageBus() {\r\n    return this._messagesBus;\r\n  }\r\n\r\n  /**\r\n   * Set Runtime Factory component\r\n   * @param  {runtimeFactory} value Factory includes the specific implementations for each environment\r\n   */\r\n  set runtimeFactory(value) {\r\n    this._runtimeFactory = value;\r\n  }\r\n\r\n  /**\r\n   * Get Runtime Factory component\r\n   * @return {runtimeFactory} Runtime Factory component\r\n   */\r\n  get runtimeFactory() {\r\n    return this._runtimeFactory;\r\n  }\r\n\r\n\r\n  /**\r\n   * Deploy Hyperty from Catalogue URL\r\n   *\r\n   * @see https://github.com/reTHINK-project/specs/tree/master/datamodel/core/address\r\n   *\r\n   * @param {URL.HypertyCatalogueURL} hypertyCatalogueURL - The Catalogue URL used to identify descriptors in the Catalogue.\r\n   * @param {boolean|URL.HypertyURL} [reuseURL=false] reuseURL - reuseURL is used to reuse the hypertyURL previously registred, by default the reuse is disabled;\r\n   * @param {URL} appURL - the app url address; // TODO: improve this description;\r\n   * @returns {Promise<Boolean, Error>} this is Promise and returns true if all components are loaded with success or an error if someone fails.\r\n   *\r\n   * @memberOf Loader\r\n   */\r\n  loadHyperty(hypertyCatalogueURL, reuseURL = false, appURL) {\r\n\r\n    if (!this._readyToUse()) return false;\r\n    if (!hypertyCatalogueURL) throw new   Error('[Runtime.Loader] Hyperty descriptor url parameter is needed');\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let _hypertyURL;\r\n      let _hypertySandbox;\r\n      let _hypertyDescriptor;\r\n      let _hypertySourcePackage;\r\n      let haveError = false;\r\n\r\n      let errorReason = (reason) => {\r\n        console.  Error('[Runtime.Loader] Something failed on the deploy hyperty: ', reason);\r\n        reject(reason);\r\n      };\r\n\r\n      let handleError = (reason) => {\r\n        haveError = true;\r\n        reject(reason);\r\n      };\r\n\r\n      // Get Hyperty descriptor\r\n      // TODO: the request Module should be changed,\r\n      // because at this moment it is incompatible with nodejs;\r\n      // Probably we need to pass a factory like we do for sandboxes;\r\n      console.info('[Runtime.Loader] ------------------ Hyperty ------------------------');\r\n      console.info('[Runtime.Loader] Get hyperty descriptor for :', hypertyCatalogueURL);\r\n      return this.descriptors.getHypertyDescriptor(hypertyCatalogueURL)\r\n      .then((hypertyDescriptor) => {\r\n        // at this point, we have completed \"step 2 and 3\" as shown in https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md\r\n        console.info('[Runtime.Loader] 1: return hyperty descriptor');\r\n\r\n        // hyperty contains the full path of the catalogue URL, e.g.\r\n        // catalogue.rethink.eu/.well-known/..........\r\n        _hypertyDescriptor = hypertyDescriptor;\r\n\r\n        let sourcePackageURL = hypertyDescriptor.sourcePackageURL;\r\n\r\n        if (sourcePackageURL === '/sourcePackage') {\r\n          return hypertyDescriptor.sourcePackage;\r\n        }\r\n\r\n        // Get the hyperty source code\r\n        return this.runtimeCatalogue.getSourcePackageFromURL(sourcePackageURL);\r\n      }, handleError)\r\n      .then((sourcePackage) => {\r\n        if (haveError) return false;\r\n\r\n        console.info('[Runtime.Loader] 2: return hyperty source code');\r\n\r\n        // at this point, we have completed \"step 4 and 5\" as shown in https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md\r\n\r\n        _hypertySourcePackage = sourcePackage;\r\n\r\n        //\r\n        // steps 6 -- 9 are skipped.\r\n        // TODO: on release of core 0.2;\r\n        // TODO: Promise to check the policy engine\r\n\r\n        // mock-up code;\r\n        // temporary code, only\r\n        let policy = true;\r\n\r\n        return policy;\r\n      }, handleError)\r\n      .then((policyResult) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 3: return policy engine result' + policyResult);\r\n\r\n        // we have completed step 6 to 9 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n        //\r\n        // Steps 6 -- 9\r\n        // As a result of the sipped steps, we know at this point if we execute\r\n        // inSameSandbox or not.\r\n        //\r\n\r\n        // For testing, just assume we execute in same Sandbox.\r\n        let inSameSandbox = true;\r\n        let sandbox;\r\n\r\n        if (inSameSandbox) {\r\n\r\n          // this don't need be a Promise;\r\n          sandbox = this.registry.getAppSandbox();\r\n\r\n          // we have completed step 11 here.\r\n        } else {\r\n\r\n          let domain = divideURL(hypertyCatalogueURL).domain;\r\n\r\n          // getSandbox, this will return a promise;\r\n          sandbox = this.registry.getSandbox(domain);\r\n        }\r\n\r\n        // this will return the sandbox or one promise to getSandbox;\r\n        return sandbox;\r\n      }, handleError)\r\n      .then((sandbox) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 4: return the sandbox', sandbox);\r\n\r\n        // Return the sandbox indepentely if it running in the same sandbox or not\r\n        // we have completed step 14 here.\r\n        return sandbox;\r\n      }, (reason) => {\r\n        if (haveError) return false;\r\n        console.  Error('[Runtime.Loader] 4.1: Try to register a new sandbox');\r\n\r\n        // check if the sandbox is registed for this hyperty descriptor url;\r\n        // Make Steps xxx --- xxx\r\n        // Instantiate the Sandbox\r\n\r\n        let hypertyCapabilities = {};\r\n        if (_hypertyDescriptor && _hypertyDescriptor.hasOwnProperty('capabilities')) {\r\n          hypertyCapabilities = _hypertyDescriptor.stubCapabilities;\r\n        }\r\n\r\n        return this._runtimeFactory.createSandbox(hypertyCapabilities).then((sandbox) => {\r\n\r\n          sandbox.addListener('*', (msg) => {\r\n            this.messageBus.postMessage(msg);\r\n          });\r\n\r\n          return sandbox;\r\n        });\r\n      }, handleError)\r\n      .then((sandbox) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 5: return sandbox and register');\r\n\r\n        _hypertySandbox = sandbox;\r\n\r\n        let numberOfAddresses = 1;\r\n        return this._addressAllocation.create(this._registry._domain, numberOfAddresses, _hypertyDescriptor, 'hyperty', reuseURL);\r\n      }, handleError)\r\n      .then((addresses) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 6: return the addresses for the hyperty', addresses);\r\n\r\n        // Register hyperty\r\n        return this.registry.registerHyperty(_hypertySandbox, hypertyCatalogueURL, _hypertyDescriptor, addresses);\r\n      }, handleError)\r\n      .then((hypertyURL) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 7: Hyperty url, after register hyperty', hypertyURL);\r\n\r\n        // we have completed step 16 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n        _hypertyURL = hypertyURL;\r\n\r\n        // Extend original hyperty configuration;\r\n        let configuration = {};\r\n        if (!emptyObject(_hypertyDescriptor.configuration)) {\r\n          try {\r\n            configuration = Object.assign({}, JSON.parse(_hypertyDescriptor.configuration));\r\n          } catch (e) {\r\n            configuration = _hypertyDescriptor.configuration;\r\n          }\r\n        }\r\n        configuration.runtimeURL = this._runtimeURL;\r\n\r\n        // We will deploy the component - step 17 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n\r\n        try {\r\n          return _hypertySandbox.deployComponent(_hypertySourcePackage.sourceCode, _hypertyURL, configuration);\r\n        } catch (e) {\r\n          console.  Error('[Runtime.Loader] Error on deploy component:', e);\r\n          reject(e);\r\n        }\r\n      }, handleError)\r\n      .then((deployComponentStatus) => {\r\n        if (haveError) return false;\r\n        console.info('[Runtime.Loader] 8: Deploy component status for hyperty: ', deployComponentStatus);\r\n\r\n        // we have completed step 19 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n\r\n        // Add the message bus listener to the appSandbox or hypertSandbox;\r\n        this.messageBus.addListener(_hypertyURL, (msg) => {\r\n          _hypertySandbox.postMessage(msg);\r\n        });\r\n\r\n        // we have completed step 20 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n        let hyperty = {\r\n          runtimeHypertyURL: _hypertyURL,\r\n          status: deployComponentStatus\r\n        };\r\n\r\n        resolve(hyperty);\r\n\r\n        // we have completed step 21 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\r\n        console.info('[Runtime.Loader] ------------------ END ------------------------');\r\n      }, handleError)\r\n      .catch(errorReason);\r\n    });\r\n  }\r\n\r\n  /**\r\n  * Deploy Stub from Catalogue URL or domain url\r\n  * @param  {URL.URL}     domain          domain\r\n  * @param  {Object}      p2pConfig       configuration of p2p\r\n  */\r\n  loadStub(protostubURL, p2pConfig) {\r\n\r\n    if (!this._readyToUse()) return false;\r\n    if (!protostubURL) throw new   Error('[Runtime.Loader.loadStub]ProtoStub descriptor url parameter is needed');\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      // to analyse if domain for p2pHandlers should be something else and not the default domain itself\r\n\r\n      let domain = divideURL(protostubURL).domain;\r\n\r\n      if (!domain) {\r\n        domain = protostubURL;\r\n      }\r\n\r\n      let _stubSandbox;\r\n      let _stubDescriptor;\r\n      let _runtimeProtoStubURL;\r\n      let _stubSourcePackage;\r\n      let haveError = false;\r\n      let stubId;\r\n\r\n      let errorReason = (reason) => {\r\n        console.  Error('[Runtime.Loader.loadStub]Something failed on the deploy of protocolstub: ', reason);\r\n        reject(reason);\r\n      };\r\n\r\n      let handleError = (reason) => {\r\n        haveError = true;\r\n        reject(reason);\r\n      };\r\n\r\n      // Discover Protocol Stub\r\n      let discoverStub;\r\n      let isP2PHandler = false;\r\n      let isP2PRequester = false;\r\n\r\n      console.info('[Runtime.Loader.loadStub] starting loading for ', protostubURL, ' with p2pconfig ', p2pConfig);\r\n      console.info('[Runtime.Loader.loadStub]Discover or Create a new ProtoStub for domain: ', domain);\r\n\r\n      // step 2 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n      try {\r\n        if (p2pConfig) {\r\n\r\n          if (p2pConfig.hasOwnProperty('isHandlerStub') && p2pConfig.isHandlerStub) {\r\n            // step 6 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n            isP2PHandler = true;\r\n            stubId = this.runtimeURL;\r\n            discoverStub = this.registry.discoverP2PStub();\r\n          } else {\r\n            isP2PRequester = true;\r\n            let p2pHandlerRuntimeURL = p2pConfig.remoteRuntimeURL;\r\n            stubId = p2pHandlerRuntimeURL;\r\n\r\n            // step 4 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n            // step 5 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n            discoverStub = this.registry.discoverP2PStub(p2pHandlerRuntimeURL);\r\n          }\r\n\r\n        } else {\r\n          // step 3 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          stubId = domain;\r\n          discoverStub = this.registry.discoverProtostub(domain);\r\n        }\r\n\r\n        // Is registed?\r\n        console.info('[Runtime.Loader.loadStub]1. Proto Stub Discovered for ', protostubURL, ': ', discoverStub);\r\n\r\n        // step 23 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n        resolve(discoverStub);\r\n        console.info(' [Runtime.Loader]------------------- END ---------------------------\\n');\r\n\r\n      } catch (reason) {\r\n\r\n        // is not registed?\r\n        console.info('[Runtime.Loader.loadStub]1. Proto Stub not found ' + reason);\r\n\r\n        // step 8 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n        this.descriptors.getStubDescriptor(protostubURL)\r\n        .then((stubDescriptor) => {\r\n\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader.loadStub]2. return the ProtoStub descriptor');\r\n\r\n          // step 9 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          _stubDescriptor = stubDescriptor;\r\n\r\n          let sourcePackageURL = stubDescriptor.sourcePackageURL;\r\n\r\n          if (sourcePackageURL === '/sourcePackage') {\r\n            return stubDescriptor.sourcePackage;\r\n          }\r\n\r\n          // step 10 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.runtimeCatalogue.getSourcePackageFromURL(sourcePackageURL);\r\n        }, handleError)\r\n        .catch(errorReason)\r\n        .then((stubSourcePackage) => {\r\n          if (haveError) return false;\r\n\r\n          // step 11 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub]3. return the ProtoStub Source Code');\r\n          _stubSourcePackage = stubSourcePackage;\r\n\r\n          // this will return the sandbox or one promise to getSandbox;\r\n          // step 12 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.registry.getSandbox(domain);\r\n        })\r\n        .then((stubSandbox) => {\r\n          if (haveError) return false;\r\n\r\n          // step 15 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub]4. if the sandbox is registered then return the sandbox ', stubSandbox);\r\n\r\n          _stubSandbox = stubSandbox;\r\n          return stubSandbox;\r\n        })\r\n        .catch((reason) => {\r\n          if (haveError) return false;\r\n\r\n          // step 13 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub]5. Sandbox was not found, creating a new one ', reason);\r\n\r\n          // check if the sandbox is registed for this stub descriptor url;\r\n\r\n          // According to debug, it seems RuntimeCatalogue does not support yet constraints. It appears empty!!!!\r\n\r\n          let stubCapabilities = {};\r\n          if (_stubDescriptor && _stubDescriptor.hasOwnProperty('constraints')) {\r\n            stubCapabilities = _stubDescriptor.stubCapabilities;\r\n          }\r\n\r\n          // step 14 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this._runtimeFactory.createSandbox(stubCapabilities).then((sandbox) => {\r\n\r\n            sandbox.addListener('*', (msg) => {\r\n              this.messageBus.postMessage(msg);\r\n            });\r\n\r\n            return sandbox;\r\n          });\r\n\r\n        })\r\n        .then((sandbox) => {\r\n          if (haveError) return false;\r\n\r\n          // step 16 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub]6. return the sandbox instance and register', sandbox, 'to domain ', domain);\r\n\r\n          _stubSandbox = sandbox;\r\n\r\n          // we need register stub on registry - step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.registry.registerStub(_stubSandbox, stubId, p2pConfig, protostubURL, _stubDescriptor);\r\n        }, handleError)\r\n        .then((runtimeProtoStub) => {\r\n          if (haveError) return false;\r\n\r\n          // step 23 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub] 7. return the runtime protostub url: ', runtimeProtoStub);\r\n\r\n          _runtimeProtoStubURL = runtimeProtoStub.url;\r\n\r\n          // Extend original hyperty configuration;\r\n          let configuration = {};\r\n          if (!emptyObject(_stubDescriptor.configuration)) {\r\n            try {\r\n              configuration = Object.assign({}, JSON.parse(_stubDescriptor.configuration));\r\n            } catch (e) {\r\n              configuration = _stubDescriptor.configuration;\r\n            }\r\n          }\r\n\r\n          if (p2pConfig) {\r\n            try {\r\n              configuration = Object.assign(configuration, JSON.parse(p2pConfig));\r\n            } catch (e) {\r\n              configuration = Object.assign(configuration, p2pConfig);\r\n            }\r\n          }\r\n\r\n          // required for protostub session\r\n\r\n          configuration.runtimeURL = this._runtimeURL;\r\n\r\n          // step 24 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          try {\r\n            return _stubSandbox.deployComponent(_stubSourcePackage.sourceCode, _runtimeProtoStubURL, configuration);\r\n          } catch (e) {\r\n            console.    Error('[Runtime.Loader.loadStub] Error on deploy component:', e);\r\n            reject(e);\r\n          }\r\n        }, handleError)\r\n        .then((deployComponentStatus) => {\r\n          if (haveError) return false;\r\n\r\n          // step 26 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          console.info('[Runtime.Loader.loadStub] 8: return deploy component for sandbox status: ', deployComponentStatus);\r\n\r\n          // step 27 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          // Add the message bus listener\r\n          this.messageBus.addListener(_runtimeProtoStubURL, (msg) => {\r\n            _stubSandbox.postMessage(msg);\r\n          });\r\n\r\n          // step 28 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          let stub;\r\n          if (p2pConfig) {\r\n            console.log('[Runtime.Loader.loadStub] p2pConfig: ', p2pConfig);\r\n\r\n            if (p2pConfig.hasOwnProperty('isHandlerStub')) stub = this.registry.p2pHandlerStub[this._runtimeURL];\r\n            if (p2pConfig.hasOwnProperty('p2pRequesterStub')) stub = this.registry.p2pRequesterStub[p2pConfig.remoteRuntimeURL];\r\n          } else {\r\n            stub = this.registry.protostubsList[domain];\r\n          }\r\n\r\n          console.log('[Runtime.Loader.loadStub] Stub: ', stub);\r\n          resolve(stub.url);\r\n          console.info('[Runtime.Loader.loadStub]------------------- END ---------------------------\\n');\r\n        }, handleError)\r\n        .catch(errorReason);\r\n\r\n      }\r\n\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  * Deploy idpProxy from Catalogue URL or domain url\r\n  * @param  {URL.URL}     domain          domain\r\n  */\r\n\r\n  loadIdpProxy(idpProxyURL) {\r\n\r\n    if (!this._readyToUse()) return false;\r\n    if (!idpProxyURL) throw new   Error('[Runtime.Loader] IdpProxy descriptor url parameter is needed');\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let domain = divideURL(idpProxyURL).domain;\r\n\r\n      if (!domain) {\r\n        domain = idpProxyURL;\r\n      }\r\n\r\n      let _proxySandbox;\r\n      let _proxyDescriptor;\r\n      let _runtimeIdpProxyURL;\r\n      let _proxySourcePackage;\r\n      let haveError = false;\r\n\r\n      let errorReason = (reason) => {\r\n        console.  Error('[Runtime.Loader] Something failed on the deploy of IdpProxy: ', reason);\r\n        reject(reason);\r\n      };\r\n\r\n      let handleError = (reason) => {\r\n        haveError = true;\r\n        reject(reason);\r\n      };\r\n\r\n      // Discover IDPProxy\r\n      console.info('[Runtime.Loader] ------------------- IDP Proxy Deploy ---------------------------\\n');\r\n      console.info('[Runtime.Loader] Discover or Create a new IdpProxy for domain/URL: ', domain);\r\n\r\n      try {\r\n        let runtimeIdpProxyURL = this.registry.discoverIdpProxy(domain);\r\n\r\n        // Is registed?\r\n        console.info('[Runtime.Loader] 1. IDPProxy Discovered: ', runtimeIdpProxyURL);\r\n\r\n        // we have completed step 2 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n        let idpProxy = this.registry.idpProxyList[domain];\r\n        console.log('Deployed: ', idpProxy);\r\n\r\n        resolve(idpProxy);\r\n        console.info('[Runtime.Loader] ------------------- END ---------------------------\\n');\r\n      } catch (reason) {\r\n\r\n        // is not registed?\r\n        console.info('[Runtime.Loader] 1. IdpProxy not found:', reason);\r\n\r\n        // we have completed step 3 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n        // we need to get ProtoStub descriptor step 4 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n        this.descriptors.getIdpProxyDescriptor(idpProxyURL)\r\n        .then((proxyDescriptor) => {\r\n\r\n          console.info('[Runtime.Loader] 2. Return the IDPProxy descriptor');\r\n\r\n          // we have completed step 5 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          _proxyDescriptor = proxyDescriptor;\r\n\r\n          let sourcePackageURL = proxyDescriptor.sourcePackageURL;\r\n\r\n          if (sourcePackageURL === '/sourcePackage') {\r\n            return proxyDescriptor.sourcePackage;\r\n          }\r\n\r\n          // we need to get ProtoStub Source code from descriptor - step 6 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.runtimeCatalogue.getSourcePackageFromURL(sourcePackageURL);\r\n        }, handleError)\r\n        .then((sourcePackage) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 3. return the IDPProxy source package');\r\n\r\n          // we have completed step 7 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n          _proxySourcePackage = sourcePackage;\r\n\r\n          // TODO: Check on PEP (policy Engine) if we need the sandbox and check if the Sandbox Factory have the context sandbox;\r\n          let policy = true;\r\n          return policy;\r\n        }, handleError)\r\n        .then((policy) => {\r\n          if (haveError) return false;\r\n\r\n          // this will return the sandbox or one promise to getSandbox;\r\n          return this.registry.getSandbox(domain);\r\n        })\r\n        .then((proxySandbox) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 4. if the sandbox is registered then return the sandbox', proxySandbox);\r\n\r\n          _proxySandbox = proxySandbox;\r\n          return proxySandbox;\r\n        })\r\n        .catch((reason) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 5. Sandbox was not found, creating a new one', reason);\r\n\r\n          let proxyCapabilities = {};\r\n          if (_proxyDescriptor && _proxyDescriptor.hasOwnProperty('capabilities')) {\r\n            _proxyDescriptor = _proxyDescriptor.stubCapabilities;\r\n          }\r\n\r\n          return this._runtimeFactory.createSandbox(proxyCapabilities).then((sandbox) => {\r\n\r\n            sandbox.addListener('*', (msg) => {\r\n              this.messageBus.postMessage(msg);\r\n            });\r\n\r\n            return sandbox;\r\n          });\r\n        })\r\n        .then((sandbox) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 6. return the sandbox instance and register', sandbox, 'to domain ', domain);\r\n\r\n          _proxySandbox = sandbox;\r\n\r\n          // we need register stub on registry - step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n          return this.registry.registerIdpProxy(sandbox, domain);\r\n        }, handleError)\r\n        .then((runtimeIdpProxyURL) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 7. Return the runtime Idp Proxy URL: ', runtimeIdpProxyURL);\r\n\r\n          // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n          _runtimeIdpProxyURL = runtimeIdpProxyURL;\r\n\r\n          // Extend original hyperty configuration;\r\n          let configuration = {};\r\n          if (!emptyObject(_proxyDescriptor.configuration)) {\r\n            try {\r\n              configuration = Object.assign({}, JSON.parse(_proxyDescriptor.configuration));\r\n            } catch (e) {\r\n              configuration = _proxyDescriptor.configuration;\r\n            }\r\n          }\r\n          configuration.runtimeURL = this._runtimeURL;\r\n\r\n          // Deploy Component step xxx\r\n          try {\r\n            return _proxySandbox.deployComponent(_proxySourcePackage.sourceCode, runtimeIdpProxyURL, configuration);\r\n          } catch (e) {\r\n            console.  Error('[Runtime.Loader] Error on deploy component:', e);\r\n            reject(e);\r\n          }\r\n        }, handleError)\r\n        .then((deployComponentStatus) => {\r\n          if (haveError) return false;\r\n          console.info('[Runtime.Loader] 8: return deploy component for sandbox status: ', deployComponentStatus);\r\n\r\n          // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n          // Add the message bus listener\r\n          this.messageBus.addListener(_runtimeIdpProxyURL, (msg) => {\r\n            _proxySandbox.postMessage(msg);\r\n          });\r\n\r\n          // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\r\n\r\n          // Load Stub function resolved with success;\r\n          // let idpProxy = {\r\n          //   runtimeIdpProxyURL: _runtimeIdpProxyURL,\r\n          //   status: deployComponentStatus\r\n          // };\r\n\r\n          this.registry.idpProxyList[domain].status = 'deployed';\r\n          let idpProxy = this.registry.idpProxyList[domain];\r\n\r\n          console.log('Deployed: ', idpProxy);\r\n\r\n          resolve(idpProxy);\r\n          console.info('[Runtime.Loader] ------------------- END ---------------------------\\n');\r\n\r\n        }, handleError)\r\n        .catch(errorReason);\r\n      }\r\n\r\n    });\r\n  }\r\n\r\n  // Check if the loader is ready to load all components\r\n  _readyToUse() {\r\n\r\n    let status = false;\r\n\r\n    if (!this._runtimeURL) throw new   Error('[Runtime.Loader] The loader need the runtime url address');\r\n    if (!this._messagesBus) throw new   Error('[Runtime.Loader] The loader need the messageBus component');\r\n    if (!this._registry) throw new   Error('[Runtime.Loader] The loader need the registry component');\r\n    if (!this._runtimeFactory) throw new   Error('[Runtime.Loader] The loader need the runtime factory component');\r\n\r\n    status = true;\r\n    return status;\r\n  }\r\n\r\n}\r\n\r\nexport default Loader;\r\n",
    "static": true,
    "longname": "src/runtime/Loader.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 563,
    "kind": "class",
    "name": "Loader",
    "memberof": "src/runtime/Loader.js",
    "static": true,
    "longname": "src/runtime/Loader.js~Loader",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/runtime/Loader.js",
    "importStyle": "Loader",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 564,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#constructor",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "runtimeURL",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtimeConfiguration",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtimeDescriptorsInstance",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 565,
    "kind": "member",
    "name": "runtimeConfiguration",
    "memberof": "src/runtime/Loader.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#runtimeConfiguration",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 566,
    "kind": "member",
    "name": "descriptors",
    "memberof": "src/runtime/Loader.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#descriptors",
    "access": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 567,
    "kind": "set",
    "name": "runtimeURL",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#runtimeURL",
    "access": null,
    "description": "Set runtime url",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "runtimeURL"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 568,
    "kind": "member",
    "name": "_runtimeURL",
    "memberof": "src/runtime/Loader.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#_runtimeURL",
    "access": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 569,
    "kind": "get",
    "name": "runtimeURL",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#runtimeURL",
    "access": null,
    "description": "Get runtime url",
    "lineNumber": 26,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "value runtimeURL"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 570,
    "kind": "set",
    "name": "registry",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#registry",
    "access": null,
    "description": "Set Registry component",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "Registry"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Registry Component"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 571,
    "kind": "member",
    "name": "_registry",
    "memberof": "src/runtime/Loader.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#_registry",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 572,
    "kind": "member",
    "name": "_addressAllocation",
    "memberof": "src/runtime/Loader.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#_addressAllocation",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 573,
    "kind": "get",
    "name": "registry",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#registry",
    "access": null,
    "description": "Get Registry component",
    "lineNumber": 48,
    "return": {
      "nullable": null,
      "types": [
        "Registry"
      ],
      "spread": false,
      "description": "Registry component"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 574,
    "kind": "set",
    "name": "messageBus",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#messageBus",
    "access": null,
    "description": "Set Message Bus component",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Message bus component"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 575,
    "kind": "member",
    "name": "_messagesBus",
    "memberof": "src/runtime/Loader.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#_messagesBus",
    "access": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 576,
    "kind": "get",
    "name": "messageBus",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#messageBus",
    "access": null,
    "description": "Get Message Bus component",
    "lineNumber": 64,
    "return": {
      "nullable": null,
      "types": [
        "MessageBus"
      ],
      "spread": false,
      "description": "Message Bus component"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 577,
    "kind": "set",
    "name": "runtimeFactory",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#runtimeFactory",
    "access": null,
    "description": "Set Runtime Factory component",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "runtimeFactory"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Factory includes the specific implementations for each environment"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 578,
    "kind": "member",
    "name": "_runtimeFactory",
    "memberof": "src/runtime/Loader.js~Loader",
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#_runtimeFactory",
    "access": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 579,
    "kind": "get",
    "name": "runtimeFactory",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#runtimeFactory",
    "access": null,
    "description": "Get Runtime Factory component",
    "lineNumber": 80,
    "return": {
      "nullable": null,
      "types": [
        "runtimeFactory"
      ],
      "spread": false,
      "description": "Runtime Factory component"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 580,
    "kind": "method",
    "name": "loadHyperty",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#loadHyperty",
    "access": null,
    "description": "Deploy Hyperty from Catalogue URL",
    "see": [
      "https://github.com/reTHINK-project/specs/tree/master/datamodel/core/address"
    ],
    "lineNumber": 97,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Boolean, Error>} this is Promise and returns true if all components are loaded with success or an error if someone fails."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "Loader"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.HypertyCatalogueURL"
        ],
        "spread": false,
        "optional": false,
        "name": "hypertyCatalogueURL",
        "description": "The Catalogue URL used to identify descriptors in the Catalogue."
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "URL.HypertyURL"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "reuseURL",
        "description": "reuseURL - reuseURL is used to reuse the hypertyURL previously registred, by default the reuse is disabled;"
      },
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "appURL",
        "description": "the app url address; // TODO: improve this description;"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Boolean, Error>"
      ],
      "spread": false,
      "description": "this is Promise and returns true if all components are loaded with success or an error if someone fails."
    }
  },
  {
    "__docId__": 581,
    "kind": "method",
    "name": "loadStub",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#loadStub",
    "access": null,
    "description": "Deploy Stub from Catalogue URL or domain url",
    "lineNumber": 299,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "domain"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "p2pConfig",
        "description": "configuration of p2p"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 582,
    "kind": "method",
    "name": "loadIdpProxy",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#loadIdpProxy",
    "access": null,
    "description": "Deploy idpProxy from Catalogue URL or domain url",
    "lineNumber": 532,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "domain"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 583,
    "kind": "method",
    "name": "_readyToUse",
    "memberof": "src/runtime/Loader.js~Loader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/Loader.js~Loader#_readyToUse",
    "access": null,
    "description": null,
    "lineNumber": 717,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 584,
    "kind": "file",
    "name": "src/runtime/runtimeConfiguration.js",
    "content": "export const runtimeConfiguration = {\r\n\r\n  runtimeURLS: {\r\n    registry: {\r\n      prefix: 'hyperty-runtime://',\r\n      suffix: 'registry'\r\n    },\r\n    identityModule: {\r\n      prefix: 'hyperty-runtime://',\r\n      suffix: '/idm'\r\n    },\r\n    runtimeUA: {\r\n      prefix: 'hyperty-runtime://',\r\n      suffix: '/ua'\r\n    },\r\n    catalogue: {\r\n      prefix: 'hyperty-runtime://',\r\n      suffix: '/catalogue'\r\n    },\r\n    graphConnector: {\r\n      prefix: 'hyperty-runtime://',\r\n      suffix: '/graph'\r\n    },\r\n    syncManager: {\r\n      prefix: 'hyperty-runtime://',\r\n      suffix: '/sm'\r\n    }\r\n  },\r\n  catalogueURLs: {\r\n    protocolstub: {\r\n      prefix: 'hyperty-catalogue://catalogue.',\r\n      suffix: '/.well-known/protocolstub/',\r\n      fallback: 'hyperty-catalogue://catalogue.%domain%/.well-known/protocolstub/'\r\n    },\r\n    idpProxy: {\r\n      prefix: 'hyperty-catalogue://catalogue.',\r\n      suffix: '/.well-known/idp-proxy/',\r\n      fallback: 'hyperty-catalogue://catalogue.%domain%/.well-known/idp-proxy/'\r\n    }\r\n  },\r\n  msgNodeURL: {\r\n    prefix: 'domain://msg-node.',\r\n    suffix: '',\r\n    hypertyAddressAllocation: '/hyperty-address-allocation',\r\n    objectAddressAllocation: '/object-address-allocation',\r\n    subscriptionManagement: '/sm'\r\n  },\r\n  domainRegistryURL: {\r\n    prefix: 'domain://registry.',\r\n    suffix: ''\r\n  },\r\n  globalRegistryURL: 'global://registry.'\r\n};\r\n",
    "static": true,
    "longname": "src/runtime/runtimeConfiguration.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 585,
    "kind": "variable",
    "name": "runtimeConfiguration",
    "memberof": "src/runtime/runtimeConfiguration.js",
    "static": true,
    "longname": "src/runtime/runtimeConfiguration.js~runtimeConfiguration",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/runtime/runtimeConfiguration.js",
    "importStyle": "{runtimeConfiguration}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"runtimeURLS\": *, \"catalogueURLs\": *, \"msgNodeURL\": *, \"domainRegistryURL\": *, \"globalRegistryURL\": string}"
      ]
    }
  },
  {
    "__docId__": 586,
    "kind": "file",
    "name": "src/runtime/RuntimeUA.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\nimport 'babel-polyfill';\r\n\r\n//Main dependecies\r\nimport Registry from '../registry/Registry';\r\nimport IdentityModule from '../identity/IdentityModule';\r\nimport PEP from '../policy/PEP';\r\nimport MessageBus from '../bus/MessageBus';\r\nimport { generateGUID } from '../utils/utils';\r\nimport AddressAllocation from '../allocation/AddressAllocation';\r\n\r\nimport Loader from './Loader';\r\nimport Descriptors from './Descriptors';\r\n\r\nimport { runtimeConfiguration } from './runtimeConfiguration';\r\nimport { runtimeUtils } from './runtimeUtils';\r\n\r\n// import GraphConnector from '../graphconnector/GraphConnector';\r\n\r\nimport SyncherManager from '../syncher/SyncherManager';\r\nimport RuntimeCoreCtx from '../policy/context/RuntimeCoreCtx';\r\n\r\n/**\r\n * Runtime User Agent Interface will process all the dependecies of the core runtime;\r\n * @author Vitor Silva [vitor-t-silva@telecom.pt]\r\n * @version 0.4.0\r\n *\r\n * @property {runtimeFactory} runtimeFactory - Specific implementation for all environments;\r\n * @property {RuntimeCatalogue} runtimeCatalogue - Catalogue of components can be installed;\r\n * @property {runtimeURL} runtimeURL - This identify the core runtime, should be unique;\r\n * @property {IdentityModule} identityModule - Identity Module;\r\n * @property {PEP} policyEngine - Policy Engine Module;\r\n * @property {Registry} registry - Registry Module;\r\n * @property {MessageBus} messageBus - Message Bus is used like a router to redirect the messages from one component to other(s)\r\n * @property {GraphConnector} graphConnector - Graph Connector handling GUID and contacts\r\n */\r\nclass RuntimeUA {\r\n\r\n  /**\r\n   * Create a new instance of Runtime User Agent\r\n   * @param {descriptor} runtimeDescriptor - pass all the hyperty runtime descriptor\r\n   * @param {runtimeFactory} runtimeFactory - Specific implementation for the environment where the core runtime will run;\r\n   * @param {domain} domainURL - specify the domain base for the runtime;\r\n   */\r\n  constructor(runtimeDescriptor, runtimeFactory, domain) {\r\n    if (!runtimeDescriptor) throw new Error('The runtime descriptor is a needed parameter');\r\n    if (!runtimeFactory) throw new Error('The sandbox factory is a needed parameter');\r\n    if (!domain) throw new Error('You need the domain of runtime');\r\n\r\n    // Configuration object with information related with servers\r\n    this.runtimeConfiguration = Object.assign({domain: domain}, runtimeConfiguration);\r\n    this.runtimeFactory = runtimeFactory;\r\n    this.runtimeCatalogue = runtimeFactory.createRuntimeCatalogue();\r\n\r\n    if (runtimeDescriptor.p2pHandlerStub && typeof runtimeDescriptor.p2pHandlerStub  === 'string' && runtimeDescriptor.p2pHandlerStub.includes('://')) {\r\n      this.p2p = true;\r\n    } else {\r\n      this.p2p = false;\r\n    }\r\n\r\n    runtimeUtils.runtimeDescriptor = runtimeDescriptor;\r\n\r\n    if (typeof runtimeFactory.createRuntimeCatalogue === 'function') {\r\n      this.persistenceManager = runtimeFactory.createRuntimeCatalogue();\r\n    } else {\r\n      throw new Error('Check your Runtime Factory because it need the Runtime Catalogue implementation');\r\n    }\r\n\r\n    if (typeof runtimeFactory.persistenceManager === 'function') {\r\n      this.persistenceManager = runtimeFactory.persistenceManager();\r\n    } else {\r\n      throw new Error('Check your Runtime Factory because it need the Persistence Manager implementation');\r\n    }\r\n\r\n    if (typeof runtimeFactory.storageManager === 'function') {\r\n      this.storageManager = runtimeFactory.storageManager();\r\n    } else {\r\n      throw new Error('Check your Runtime Factory because it need the Storage Manager implementation');\r\n    }\r\n    if (typeof runtimeFactory.runtimeCapabilities === 'function') {\r\n      this.runtimeCapabilities = runtimeFactory.runtimeCapabilities(this.storageManager);\r\n    } else {\r\n      console.info('Check your RuntimeFactory because it need the Runtime Capabilities implementation');\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Intialize the installation of runtime\r\n   *\r\n   * @access public\r\n   * @return {Promise<Boolean, Error>} this is Promise and if the installation process happened without any problems returns true otherwise the error.\r\n   *\r\n   * @memberOf RuntimeUA\r\n   */\r\n  init() {\r\n    return new Promise((resolve, reject) => {\r\n\r\n      this.domain = this.runtimeConfiguration.domain;\r\n\r\n      try {\r\n        let getCapabilities = this.runtimeCapabilities.getRuntimeCapabilities();\r\n        let getRuntimeURL = this.storageManager.get('runtime:URL');\r\n\r\n        Promise.all([getRuntimeURL, getCapabilities]).then((results) => {\r\n\r\n          this.runtimeURL = results[0] ? results[0].runtimeURL : results[0];\r\n          if (!this.runtimeURL) {\r\n            this.runtimeURL = 'runtime://' + this.domain + '/' + generateGUID();\r\n            this.storageManager.set('runtime:URL', 1, {runtimeURL: this.runtimeURL});\r\n          }\r\n\r\n          this.capabilities = results[1];\r\n\r\n          return this._loadComponents();\r\n        }).then((status) => {\r\n\r\n          if (this.p2p) {\r\n            console.info('[RuntimeUA - init] load p2pHandler: ', status);\r\n            return this._loadP2PHandler();\r\n          } else {\r\n            console.info('[RuntimeUA - init] P2P not supported');\r\n            return ('P2P Not Supported');\r\n          }\r\n        })\r\n        .then((result) => {\r\n          console.info('[runtime ua - init] - status: ', result);\r\n          resolve(true);\r\n        }, (reason) => {\r\n          console.error('ERROR: ', reason);\r\n          resolve(true);\r\n        });\r\n\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n\r\n    });\r\n\r\n  }\r\n\r\n  _loadP2PHandler() {\r\n\r\n    return new Promise((resolve) => {\r\n\r\n      let runtimeDescriptor = runtimeUtils.runtimeDescriptor;\r\n      let p2pStubHandler = runtimeDescriptor.p2pHandlerStub;\r\n      console.log('[RuntimeUA loadP2PHandler] P2PStubHandler: ', p2pStubHandler);\r\n\r\n      let p2pConfig = {\r\n        isHandlerStub: true,\r\n        runtimeURL: this.runtimeURL\r\n      };\r\n\r\n      this.loadStub(p2pStubHandler, p2pConfig).then((result) => {\r\n\r\n        let runtimeUAURL = this.runtimeURL + '/ua';\r\n        let msg = {\r\n          type: 'subscribe',\r\n          from: runtimeUAURL,\r\n          to: 'domain://msg-node.' + this.domain + '/sm',\r\n          body: {\r\n            subscribe: [result],\r\n            source: this.runtimeURL\r\n          }\r\n        };\r\n\r\n        this.messageBus.addListener(runtimeUAURL, (msg) => {\r\n          console.log('[runtime ua - listener] - receive msg: ', msg);\r\n        });\r\n\r\n        this.messageBus.postMessage(msg, (reply) => {\r\n          console.log('[runtime ua - postMessage] - reply: ', reply);\r\n        });\r\n\r\n        console.info('[runtime ua - p2p installation] - success: ', result);\r\n        resolve(true);\r\n      }).catch((reason) => {\r\n        console.info('[runtime ua - p2p installation] - fail: ', reason);\r\n        resolve(false);\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @access private\r\n   * @return {Promise<Boolean, Error>} this is Promise and returns true if all components are loaded with success or an error if someone fails.\r\n   *\r\n   * @memberOf RuntimeUA\r\n   */\r\n  _loadComponents() {\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      try {\r\n\r\n        // Prepare the on instance to handle with the fallbacks and runtimeCatalogue;\r\n        this.descriptorInstance = new Descriptors(this.runtimeURL, this.runtimeCatalogue, this.runtimeConfiguration);\r\n\r\n        // Prepare the loader to load the hyperties, protostubs and idpproxy;\r\n        this.loader = new Loader(this.runtimeURL, this.runtimeConfiguration, this.descriptorInstance);\r\n\r\n        // Instantiate the identity Module\r\n        this.identityModule = new IdentityModule(this.runtimeURL, this.runtimeCapabilities, this.storageManager);\r\n\r\n        // Use the sandbox factory to create an AppSandbox;\r\n        // In the future can be decided by policyEngine if we need\r\n        // create a AppSandbox or not;\r\n        let appSandbox = this.runtimeFactory.createAppSandbox();\r\n\r\n        // Instantiate the Registry Module\r\n        this.registry = new Registry(this.runtimeURL, appSandbox, this.identityModule, this.runtimeCatalogue, this.runtimeCapabilities, this.storageManager);\r\n\r\n        // Set the loader to load Hyperties, Stubs and IdpProxies\r\n        this.registry.loader = this.loader;\r\n\r\n        // Instantiate the Message Bus\r\n        this.messageBus = new MessageBus(this.registry);\r\n\r\n        // Prepare the address allocation instance;\r\n        this.addressAllocation = new AddressAllocation(this.runtimeURL, this.messageBus, this.registry);\r\n\r\n        // Instantiate the Policy Engine\r\n        this.policyEngine = new PEP(new RuntimeCoreCtx(this.identityModule, this.registry, this.storageManager, this.runtimeCapabilities));\r\n\r\n        this.messageBus.pipeline.handlers = [\r\n\r\n          // Policy message authorise\r\n          (ctx) => {\r\n            this.policyEngine.authorise(ctx.msg).then((changedMgs) => {\r\n              ctx.msg = changedMgs;\r\n              ctx.next();\r\n            }).catch((reason) => {\r\n              console.error(reason);\r\n              ctx.fail(reason);\r\n            });\r\n          }\r\n        ];\r\n\r\n        // Add to App Sandbox the listener;\r\n        appSandbox.addListener('*', (msg) => {\r\n          this.messageBus.postMessage(msg);\r\n        });\r\n\r\n        // Register messageBus on Registry\r\n        this.registry.messageBus = this.messageBus;\r\n\r\n        // Register registry on IdentityModule\r\n        this.identityModule.registry = this.registry;\r\n\r\n        // Use sandbox factory to use specific methods\r\n        // and set the message bus to the factory\r\n        this.runtimeFactory.messageBus = this.messageBus;\r\n\r\n        // Instanciate the SyncherManager;\r\n        this.syncherManager = new SyncherManager(this.runtimeURL, this.messageBus, this.registry, this.runtimeCatalogue, this.storageManager);\r\n\r\n        // Set into loader the needed components;\r\n        this.loader.runtimeURL = this.runtimeURL;\r\n        this.loader.messageBus = this.messageBus;\r\n        this.loader.registry = this.registry;\r\n        this.loader.runtimeCatalogue = this.runtimeCatalogue;\r\n        this.loader.runtimeFactory = this.runtimeFactory;\r\n\r\n        // Instantiate the Graph Connector\r\n        // _this.graphConnector = new GraphConnector(_this.runtimeURL, _this.messageBus);\r\n        resolve(true);\r\n\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n   * Deploy Hyperty from Catalogue URL\r\n   *\r\n   * @see https://github.com/reTHINK-project/specs/tree/master/datamodel/core/address\r\n   *\r\n   * @param {URL.HypertyCatalogueURL} hypertyCatalogueURL - The Catalogue URL used to identify descriptors in the Catalogue.\r\n   * @param {boolean|URL.HypertyURL} [reuseURL=false] reuseURL - reuseURL is used to reuse the hypertyURL previously registred, by default the reuse is disabled;\r\n   * @param {URL} appURL - the app url address; // TODO: improve this description;\r\n   * @returns {Promise<Boolean, Error>} this is Promise and returns true if all components are loaded with success or an error if someone fails.\r\n   *\r\n   * @memberOf RuntimeUA\r\n   */\r\n  loadHyperty(hypertyCatalogueURL, reuseURL = false, appURL) {\r\n\r\n    if (!hypertyCatalogueURL) throw new Error('Hyperty descriptor url parameter is needed');\r\n    return this.loader.loadHyperty(hypertyCatalogueURL, reuseURL, appURL);\r\n\r\n  }\r\n\r\n  /**\r\n  * Deploy Stub from Catalogue URL or domain url\r\n  * @param  {URL.URL}     domain          domain\r\n  */\r\n  loadStub(protocolstubCatalogueURL) {\r\n\r\n    if (!protocolstubCatalogueURL) throw new Error('ProtoStub descriptor url parameter is needed');\r\n    return this.loader.loadStub(protocolstubCatalogueURL);\r\n\r\n  }\r\n\r\n  /**\r\n  * Deploy idpProxy from Catalogue URL or domain url\r\n  * @param  {URL.URL}     domain          domain\r\n  */\r\n  loadIdpProxy(ipdProxyCatalogueURL) {\r\n\r\n    if (!ipdProxyCatalogueURL) throw new Error('The IDP Proxy URL is a needed parameter, could be a DOMAIN or a URL');\r\n    return this.loader.loadIdpProxy(ipdProxyCatalogueURL);\r\n  }\r\n\r\n  /**\r\n   * Used to close all the runtime; Unregister all hyperties;\r\n   * @return {Promise<Boolean>} result of the close method, with true or false to the operation success;\r\n   */\r\n  close() {\r\n    let _this = this;\r\n\r\n    console.info('Unregister all hyperties');\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      _this.registry.unregisterAllHyperties().then(function(result) {\r\n        console.info('All the hyperties are unregisted with Success:', result);\r\n        resolve(true);\r\n      }).catch(function(reason) {\r\n        console.error('Failed to unregister the hyperties', reason);\r\n        reject(false);\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n}\r\n\r\nexport default RuntimeUA;\r\n",
    "static": true,
    "longname": "src/runtime/RuntimeUA.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 587,
    "kind": "class",
    "name": "RuntimeUA",
    "memberof": "src/runtime/RuntimeUA.js",
    "static": true,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/runtime/RuntimeUA.js",
    "importStyle": "RuntimeUA",
    "description": "Runtime User Agent Interface will process all the dependecies of the core runtime;",
    "lineNumber": 59,
    "version": "0.4.0",
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "Vitor Silva [vitor-t-silva@telecom.pt]"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "runtimeFactory"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeFactory",
        "description": "Specific implementation for all environments;"
      },
      {
        "nullable": null,
        "types": [
          "RuntimeCatalogue"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeCatalogue",
        "description": "Catalogue of components can be installed;"
      },
      {
        "nullable": null,
        "types": [
          "runtimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeURL",
        "description": "This identify the core runtime, should be unique;"
      },
      {
        "nullable": null,
        "types": [
          "IdentityModule"
        ],
        "spread": false,
        "optional": false,
        "name": "identityModule",
        "description": "Identity Module;"
      },
      {
        "nullable": null,
        "types": [
          "PEP"
        ],
        "spread": false,
        "optional": false,
        "name": "policyEngine",
        "description": "Policy Engine Module;"
      },
      {
        "nullable": null,
        "types": [
          "Registry"
        ],
        "spread": false,
        "optional": false,
        "name": "registry",
        "description": "Registry Module;"
      },
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": "Message Bus is used like a router to redirect the messages from one component to other(s)"
      },
      {
        "nullable": null,
        "types": [
          "GraphConnector"
        ],
        "spread": false,
        "optional": false,
        "name": "graphConnector",
        "description": "Graph Connector handling GUID and contacts"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 588,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#constructor",
    "access": null,
    "description": "Create a new instance of Runtime User Agent",
    "lineNumber": 67,
    "params": [
      {
        "nullable": null,
        "types": [
          "descriptor"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeDescriptor",
        "description": "pass all the hyperty runtime descriptor"
      },
      {
        "nullable": null,
        "types": [
          "runtimeFactory"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeFactory",
        "description": "Specific implementation for the environment where the core runtime will run;"
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domainURL",
        "description": "specify the domain base for the runtime;"
      }
    ]
  },
  {
    "__docId__": 589,
    "kind": "member",
    "name": "runtimeConfiguration",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#runtimeConfiguration",
    "access": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 590,
    "kind": "member",
    "name": "runtimeFactory",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#runtimeFactory",
    "access": null,
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 591,
    "kind": "member",
    "name": "runtimeCatalogue",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#runtimeCatalogue",
    "access": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 592,
    "kind": "member",
    "name": "p2p",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#p2p",
    "access": null,
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 593,
    "kind": "member",
    "name": "p2p",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#p2p",
    "access": null,
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 594,
    "kind": "member",
    "name": "persistenceManager",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#persistenceManager",
    "access": null,
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 595,
    "kind": "member",
    "name": "persistenceManager",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#persistenceManager",
    "access": null,
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 596,
    "kind": "member",
    "name": "storageManager",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#storageManager",
    "access": null,
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 597,
    "kind": "member",
    "name": "runtimeCapabilities",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#runtimeCapabilities",
    "access": null,
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 598,
    "kind": "method",
    "name": "init",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#init",
    "access": "public",
    "description": "Intialize the installation of runtime",
    "lineNumber": 118,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "RuntimeUA"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Boolean, Error>"
      ],
      "spread": false,
      "description": "this is Promise and if the installation process happened without any problems returns true otherwise the error."
    }
  },
  {
    "__docId__": 599,
    "kind": "member",
    "name": "domain",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#domain",
    "access": null,
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 600,
    "kind": "member",
    "name": "runtimeURL",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#runtimeURL",
    "access": null,
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 601,
    "kind": "member",
    "name": "runtimeURL",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#runtimeURL",
    "access": null,
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 602,
    "kind": "member",
    "name": "capabilities",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#capabilities",
    "access": null,
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 603,
    "kind": "method",
    "name": "_loadP2PHandler",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#_loadP2PHandler",
    "access": null,
    "description": null,
    "lineNumber": 164,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 604,
    "kind": "method",
    "name": "_loadComponents",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#_loadComponents",
    "access": "private",
    "description": "",
    "lineNumber": 216,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "RuntimeUA"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Boolean, Error>"
      ],
      "spread": false,
      "description": "this is Promise and returns true if all components are loaded with success or an error if someone fails."
    }
  },
  {
    "__docId__": 605,
    "kind": "member",
    "name": "descriptorInstance",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#descriptorInstance",
    "access": null,
    "description": null,
    "lineNumber": 223,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 606,
    "kind": "member",
    "name": "loader",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#loader",
    "access": null,
    "description": null,
    "lineNumber": 226,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 607,
    "kind": "member",
    "name": "identityModule",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#identityModule",
    "access": null,
    "description": null,
    "lineNumber": 229,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 608,
    "kind": "member",
    "name": "registry",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#registry",
    "access": null,
    "description": null,
    "lineNumber": 237,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 609,
    "kind": "member",
    "name": "messageBus",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#messageBus",
    "access": null,
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 610,
    "kind": "member",
    "name": "addressAllocation",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#addressAllocation",
    "access": null,
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 611,
    "kind": "member",
    "name": "policyEngine",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#policyEngine",
    "access": null,
    "description": null,
    "lineNumber": 249,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 612,
    "kind": "member",
    "name": "syncherManager",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#syncherManager",
    "access": null,
    "description": null,
    "lineNumber": 281,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 613,
    "kind": "method",
    "name": "loadHyperty",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#loadHyperty",
    "access": null,
    "description": "Deploy Hyperty from Catalogue URL",
    "see": [
      "https://github.com/reTHINK-project/specs/tree/master/datamodel/core/address"
    ],
    "lineNumber": 314,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Boolean, Error>} this is Promise and returns true if all components are loaded with success or an error if someone fails."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "RuntimeUA"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.HypertyCatalogueURL"
        ],
        "spread": false,
        "optional": false,
        "name": "hypertyCatalogueURL",
        "description": "The Catalogue URL used to identify descriptors in the Catalogue."
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "URL.HypertyURL"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "reuseURL",
        "description": "reuseURL - reuseURL is used to reuse the hypertyURL previously registred, by default the reuse is disabled;"
      },
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "appURL",
        "description": "the app url address; // TODO: improve this description;"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Boolean, Error>"
      ],
      "spread": false,
      "description": "this is Promise and returns true if all components are loaded with success or an error if someone fails."
    }
  },
  {
    "__docId__": 614,
    "kind": "method",
    "name": "loadStub",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#loadStub",
    "access": null,
    "description": "Deploy Stub from Catalogue URL or domain url",
    "lineNumber": 325,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "domain"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 615,
    "kind": "method",
    "name": "loadIdpProxy",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#loadIdpProxy",
    "access": null,
    "description": "Deploy idpProxy from Catalogue URL or domain url",
    "lineNumber": 336,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "domain"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 616,
    "kind": "method",
    "name": "close",
    "memberof": "src/runtime/RuntimeUA.js~RuntimeUA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/runtime/RuntimeUA.js~RuntimeUA#close",
    "access": null,
    "description": "Used to close all the runtime; Unregister all hyperties;",
    "lineNumber": 346,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Boolean>"
      ],
      "spread": false,
      "description": "result of the close method, with true or false to the operation success;"
    }
  },
  {
    "__docId__": 617,
    "kind": "file",
    "name": "src/runtime/runtimeUtils.js",
    "content": "export let runtimeUtils = {\r\n  runtimeDescriptor: {}\r\n};\r\n",
    "static": true,
    "longname": "src/runtime/runtimeUtils.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 618,
    "kind": "variable",
    "name": "runtimeUtils",
    "memberof": "src/runtime/runtimeUtils.js",
    "static": true,
    "longname": "src/runtime/runtimeUtils.js~runtimeUtils",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/runtime/runtimeUtils.js",
    "importStyle": "{runtimeUtils}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"runtimeDescriptor\": *}"
      ]
    }
  },
  {
    "__docId__": 619,
    "kind": "file",
    "name": "src/sandbox/Sandbox.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\nimport SandboxRegistry from '../sandbox/SandboxRegistry';\r\nimport MiniBus from '../bus/MiniBus';\r\n\r\n// import MessageFactory from '../../resources/MessageFactory';\r\n\r\nexport let SandboxType = {APP: 'app', NORMAL: 'normal', WINDOW: 'window'};\r\n\r\n/**\r\n * @author micaelpedrosa@gmail.com\r\n * Base class to implement external sandbox component\r\n */\r\nclass Sandbox extends MiniBus {\r\n\r\n  constructor() {\r\n\r\n    super();\r\n\r\n    let _this = this;\r\n\r\n    // Add Message Factory\r\n    // let messageFactory = new MessageFactory();\r\n    // _this.messageFactory = messageFactory;\r\n  }\r\n\r\n  /**\r\n   * Deploy an instance of the component into the sandbox.\r\n   * @param  {string} componentSourceCode Component source code (Hyperty, ProtoStub, etc)\r\n   * @param  {URL} componentURL Hyperty, ProtoStub, or any other component address.\r\n   * @param  {Config} configuration Config parameters of the component\r\n   * @return {Promise<string>} return deployed if successful, or any other string with an error\r\n   */\r\n  deployComponent(componentSourceCode, componentURL, configuration) {\r\n\r\n    let _this = this;\r\n\r\n    // let messageFactory = _this.messageFactory;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      //FLOW-OUT: deploy message for the internal SandboxRegistry -> _onDeploy\r\n      let deployMessage = {\r\n        type: 'create', from: SandboxRegistry.ExternalDeployAddress, to: SandboxRegistry.InternalDeployAddress,\r\n        body: { url: componentURL, sourceCode: componentSourceCode, config: configuration }\r\n      };\r\n\r\n      //send message into the sandbox internals and wait for reply\r\n      _this.postMessage(deployMessage, (reply) => {\r\n        if (reply.body.code === 200) {\r\n          //is this response complaint with the spec?\r\n          resolve('deployed');\r\n        } else {\r\n          reject(reply.body.desc);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove the instance of a previously deployed component.\r\n   * @param  {URL} componentURL Hyperty, ProtoStub, or any other component address.\r\n   * @return {Promise<string>} return undeployed if successful, or any other string with an error\r\n   */\r\n  removeComponent(componentURL) {\r\n    let _this = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      //FLOW-OUT: un-deploy message for the internal SandboxRegistry -> _onRemove\r\n      let removeMessage = {\r\n        type: 'delete', from: SandboxRegistry.ExternalDeployAddress, to: SandboxRegistry.InternalDeployAddress,\r\n        body: { url: componentURL }\r\n      };\r\n\r\n      //send message into the sandbox internals and wait for reply\r\n      _this.postMessage(removeMessage, (reply) => {\r\n        if (reply.body.code === 200) {\r\n          //is this response complaint with the spec?\r\n          resolve('undeployed');\r\n        } else {\r\n          reject(reply.body.desc);\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nexport default Sandbox;\r\n",
    "static": true,
    "longname": "src/sandbox/Sandbox.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 620,
    "kind": "variable",
    "name": "SandboxType",
    "memberof": "src/sandbox/Sandbox.js",
    "static": true,
    "longname": "src/sandbox/Sandbox.js~SandboxType",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/sandbox/Sandbox.js",
    "importStyle": "{SandboxType}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"APP\": string, \"NORMAL\": string, \"WINDOW\": string}"
      ]
    }
  },
  {
    "__docId__": 621,
    "kind": "class",
    "name": "Sandbox",
    "memberof": "src/sandbox/Sandbox.js",
    "static": true,
    "longname": "src/sandbox/Sandbox.js~Sandbox",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/sandbox/Sandbox.js",
    "importStyle": "Sandbox",
    "description": "",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nBase class to implement external sandbox component"
      }
    ],
    "interface": false,
    "extends": [
      "src/bus/MiniBus.js~MiniBus"
    ]
  },
  {
    "__docId__": 622,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/sandbox/Sandbox.js~Sandbox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/sandbox/Sandbox.js~Sandbox#constructor",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 623,
    "kind": "method",
    "name": "deployComponent",
    "memberof": "src/sandbox/Sandbox.js~Sandbox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/sandbox/Sandbox.js~Sandbox#deployComponent",
    "access": null,
    "description": "Deploy an instance of the component into the sandbox.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "componentSourceCode",
        "description": "Component source code (Hyperty, ProtoStub, etc)"
      },
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "componentURL",
        "description": "Hyperty, ProtoStub, or any other component address."
      },
      {
        "nullable": null,
        "types": [
          "Config"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "Config parameters of the component"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "return deployed if successful, or any other string with an error"
    }
  },
  {
    "__docId__": 624,
    "kind": "method",
    "name": "removeComponent",
    "memberof": "src/sandbox/Sandbox.js~Sandbox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/sandbox/Sandbox.js~Sandbox#removeComponent",
    "access": null,
    "description": "Remove the instance of a previously deployed component.",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "componentURL",
        "description": "Hyperty, ProtoStub, or any other component address."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "return undeployed if successful, or any other string with an error"
    }
  },
  {
    "__docId__": 625,
    "kind": "file",
    "name": "src/sandbox/SandboxRegistry.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n/**\r\n * @author micaelpedrosa@gmail.com\r\n * Base class to implement internal deploy manager of components.\r\n */\r\n\r\n// import MessageFactory from '../../resources/MessageFactory';\r\n\r\n/**\r\n * @author micaelpedrosa@gmail.com\r\n * Internal component registry of all sandboxes.\r\n * Process internal request's for component deploy.\r\n */\r\nclass SandboxRegistry {\r\n  /* private\r\n  _components: <url: instance>\r\n  */\r\n\r\n  constructor(bus) {\r\n    let _this = this;\r\n\r\n    _this._bus = bus;\r\n    _this._components = {};\r\n\r\n    // Add Message Factory\r\n    // let messageFactory = new MessageFactory();\r\n    // _this.messageFactory = messageFactory;\r\n\r\n    bus.addListener(SandboxRegistry.InternalDeployAddress, (msg) => {\r\n      //console.log('SandboxRegistry-RCV: ', msg);\r\n      // let responseMsg = {\r\n      //   id: msg.id, type: 'response', from: SandboxRegistry.InternalDeployAddress, to: SandboxRegistry.ExternalDeployAddress\r\n      // };\r\n\r\n      switch (msg.type) {\r\n        case 'create': _this._onDeploy(msg); break;\r\n        case 'delete': _this._onRemove(msg); break;\r\n      }\r\n    });\r\n  }\r\n\r\n  get components() { return this._components; }\r\n\r\n  _responseMsg(msg, code, value) {\r\n\r\n    let _this = this;\r\n\r\n    // let messageFactory = _this.messageFactory;\r\n\r\n    //FLOW-OUT: generic response message to external Sandbox (deploy and un-deploy responses)\r\n    let responseMsg = {\r\n      id: msg.id, type: 'response', from: SandboxRegistry.InternalDeployAddress, to: SandboxRegistry.ExternalDeployAddress\r\n    };\r\n\r\n    // Chanege the origin message, because the response;\r\n    // msg.from = SandboxRegistry.InternalDeployAddress;\r\n    // msg.to = SandboxRegistry.ExternalDeployAddress;\r\n\r\n    let body = {};\r\n    if (code) body.code = code;\r\n    if (value) body.desc = value;\r\n\r\n    responseMsg.body = body;\r\n\r\n    // return messageFactory.createResponse(msg, code, value);\r\n    return responseMsg;\r\n  }\r\n\r\n  //FLOW-IN: message from the runtime core Sandbox -> deployComponent\r\n  _onDeploy(msg) {\r\n    let _this = this;\r\n    let config = msg.body.config;\r\n    let componentURL = msg.body.url;\r\n    let sourceCode = msg.body.sourceCode;\r\n    let responseCode;\r\n    let responseDesc;\r\n\r\n    if (!_this._components.hasOwnProperty(componentURL)) {\r\n      try {\r\n        _this._components[componentURL] = _this._create(componentURL, sourceCode, config);\r\n        responseCode = 200;\r\n      } catch (error) {\r\n        responseCode = 500;\r\n        responseDesc = error;\r\n      }\r\n    } else {\r\n      responseCode = 500;\r\n      responseDesc = 'Instance ' + componentURL + ' already exist!';\r\n    }\r\n\r\n    // Create response message with MessageFactory\r\n    let responseMsg = _this._responseMsg(msg, responseCode, responseDesc);\r\n    _this._bus.postMessage(responseMsg);\r\n  }\r\n\r\n  //FLOW-IN: message from the runtime core Sandbox -> removeComponent\r\n  _onRemove(msg) {\r\n    let _this = this;\r\n    let componentURL = msg.body.url;\r\n    let responseCode;\r\n    let responseDesc;\r\n\r\n    if (_this._components.hasOwnProperty(componentURL)) {\r\n      //remove component from the pool and all listeners\r\n      delete _this._components[componentURL];\r\n      _this._bus.removeAllListenersOf(componentURL);\r\n      responseCode = 200;\r\n    } else {\r\n      responseCode = 500;\r\n      responseDesc = 'Instance ' + componentURL + ' doesn\\'t exist!';\r\n    }\r\n\r\n    let responseMsg = _this._responseMsg(msg, responseCode, responseDesc);\r\n\r\n    _this._bus.postMessage(responseMsg);\r\n  }\r\n\r\n  /**\r\n   * This method should be implemented by the internal sandbox code.\r\n   * @param  {ComponentURL} url URL used for the instance\r\n   * @param  {string} sourceCode Code of the component\r\n   * @param  {Config} config Configuration parameters\r\n   * @return {Object} Returns instance of the component or throw an error \"throw 'error message'\"\r\n   */\r\n  _create(url, sourceCode, config) {\r\n    //implementation specific\r\n    /* example code:\r\n      eval(sourceCode);\r\n      return activate(url, _this._bus, config);\r\n    */\r\n  }\r\n}\r\n\r\nSandboxRegistry.ExternalDeployAddress = 'hyperty-runtime://sandbox/external';\r\nSandboxRegistry.InternalDeployAddress = 'hyperty-runtime://sandbox/internal';\r\n\r\nexport default SandboxRegistry;\r\n",
    "static": true,
    "longname": "src/sandbox/SandboxRegistry.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 626,
    "kind": "class",
    "name": "SandboxRegistry",
    "memberof": "src/sandbox/SandboxRegistry.js",
    "static": true,
    "longname": "src/sandbox/SandboxRegistry.js~SandboxRegistry",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/sandbox/SandboxRegistry.js",
    "importStyle": "SandboxRegistry",
    "description": "",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nInternal component registry of all sandboxes.\nProcess internal request's for component deploy."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 627,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/sandbox/SandboxRegistry.js~SandboxRegistry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/sandbox/SandboxRegistry.js~SandboxRegistry#constructor",
    "access": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "bus",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 628,
    "kind": "get",
    "name": "components",
    "memberof": "src/sandbox/SandboxRegistry.js~SandboxRegistry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/sandbox/SandboxRegistry.js~SandboxRegistry#components",
    "access": null,
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 629,
    "kind": "method",
    "name": "_responseMsg",
    "memberof": "src/sandbox/SandboxRegistry.js~SandboxRegistry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/sandbox/SandboxRegistry.js~SandboxRegistry#_responseMsg",
    "access": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "code",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 630,
    "kind": "method",
    "name": "_onDeploy",
    "memberof": "src/sandbox/SandboxRegistry.js~SandboxRegistry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/sandbox/SandboxRegistry.js~SandboxRegistry#_onDeploy",
    "access": null,
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 631,
    "kind": "method",
    "name": "_onRemove",
    "memberof": "src/sandbox/SandboxRegistry.js~SandboxRegistry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/sandbox/SandboxRegistry.js~SandboxRegistry#_onRemove",
    "access": null,
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 632,
    "kind": "method",
    "name": "_create",
    "memberof": "src/sandbox/SandboxRegistry.js~SandboxRegistry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/sandbox/SandboxRegistry.js~SandboxRegistry#_create",
    "access": null,
    "description": "This method should be implemented by the internal sandbox code.",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "ComponentURL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "URL used for the instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceCode",
        "description": "Code of the component"
      },
      {
        "nullable": null,
        "types": [
          "Config"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "Configuration parameters"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Returns instance of the component or throw an error \"throw 'error message'\""
    }
  },
  {
    "__docId__": 633,
    "kind": "file",
    "name": "src/sandbox.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\nimport Sandbox from './sandbox/Sandbox';\r\nimport {SandboxType} from './sandbox/Sandbox';\r\nimport SandboxRegistry from './sandbox/SandboxRegistry';\r\n\r\nexport {Sandbox, SandboxType, SandboxRegistry};\r\n",
    "static": true,
    "longname": "src/sandbox.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 634,
    "kind": "file",
    "name": "src/syncher/ObserverObject.js",
    "content": "import { divideURL } from '../utils/utils';\r\nimport Subscription from './Subscription';\r\n\r\nclass ObserverObject {\r\n\r\n  constructor(parent, url, childrens) {\r\n    let _this = this;\r\n\r\n    _this._parent = parent;\r\n    _this._url = url;\r\n    _this._childrens = childrens;\r\n\r\n    _this._storageManager = parent._storageManager;\r\n\r\n    _this._bus = parent._bus;\r\n\r\n    _this._subscriptions = {};\r\n    _this._storageSubscriptions = {};\r\n  }\r\n\r\n  _newSubscription(hyperty) {\r\n    let _this = this;\r\n\r\n    _this._subscriptions[hyperty] = new Subscription(_this._bus, hyperty, _this._url, _this._childrens, false);\r\n  }\r\n\r\n  addSubscription(hyperty) {\r\n    let _this = this;\r\n\r\n    _this._newSubscription(hyperty);\r\n  }\r\n\r\n  removeSubscription(hyperty) {\r\n    let _this = this;\r\n\r\n    let domain = divideURL(hyperty).domain;\r\n    let objURLSubscription = _this._url + '/subscription';\r\n\r\n    let subscription = _this._subscriptions[hyperty];\r\n    if (subscription) {\r\n      //FLOW-OUT: message sent to remote ReporterObject -> _onRemoteUnSubscribe\r\n      _this._bus.postMessage({\r\n        type: 'unsubscribe', from: _this._parent._url, to: objURLSubscription,\r\n        body: { resource: _this._url }\r\n      });\r\n\r\n      //TODO: should I wait for response before unsubscribe on msg-node\r\n      //FLOW-OUT: message sent to msg-node SubscriptionManager component\r\n      _this._bus.postMessage({\r\n        type: 'unsubscribe', from: _this._parent._url, to: 'domain://msg-node.' + domain + '/sm',\r\n        body: { resource: _this._url, childrenResources: _this._childrens }\r\n      });\r\n\r\n      subscription._releaseListeners();\r\n      delete _this._subscriptions[hyperty];\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default ObserverObject;\r\n",
    "static": true,
    "longname": "src/syncher/ObserverObject.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 635,
    "kind": "class",
    "name": "ObserverObject",
    "memberof": "src/syncher/ObserverObject.js",
    "static": true,
    "longname": "src/syncher/ObserverObject.js~ObserverObject",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/syncher/ObserverObject.js",
    "importStyle": "ObserverObject",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 636,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/ObserverObject.js~ObserverObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ObserverObject.js~ObserverObject#constructor",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "parent",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "childrens",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 637,
    "kind": "method",
    "name": "_newSubscription",
    "memberof": "src/syncher/ObserverObject.js~ObserverObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ObserverObject.js~ObserverObject#_newSubscription",
    "access": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "hyperty",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 638,
    "kind": "method",
    "name": "addSubscription",
    "memberof": "src/syncher/ObserverObject.js~ObserverObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ObserverObject.js~ObserverObject#addSubscription",
    "access": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "hyperty",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 639,
    "kind": "method",
    "name": "removeSubscription",
    "memberof": "src/syncher/ObserverObject.js~ObserverObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ObserverObject.js~ObserverObject#removeSubscription",
    "access": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "hyperty",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 640,
    "kind": "file",
    "name": "src/syncher/ReporterObject.js",
    "content": "import { divideURL } from '../utils/utils';\r\nimport Subscription from './Subscription';\r\n\r\nclass ReporterObject {\r\n\r\n  constructor(parent, owner, url) {\r\n    let _this = this;\r\n\r\n    _this._parent = parent;\r\n    _this._owner = owner;\r\n    _this._url = url;\r\n\r\n    _this._bus = parent._bus;\r\n    _this._storageManager = parent._storageManager;\r\n\r\n    _this._domain = divideURL(url).domain;\r\n    _this._objSubscriptorURL = _this._url + '/subscription';\r\n\r\n    _this._subscriptions = {};\r\n    _this._childrens = [];\r\n    _this._childrenListeners = [];\r\n\r\n    _this._forwards = {};\r\n\r\n    _this._allocateListeners();\r\n  }\r\n\r\n  _allocateListeners() {\r\n    let _this = this;\r\n\r\n    //add subscription listener...\r\n    _this._subscriptionListener = _this._bus.addListener(_this._objSubscriptorURL, (msg) => {\r\n      console.log(_this._objSubscriptorURL + '-RCV: ', msg);\r\n      switch (msg.type) {\r\n        case 'subscribe': _this._onRemoteSubscribe(msg); break;\r\n        case 'unsubscribe': _this._onRemoteUnSubscribe(msg); break;\r\n        case 'response': _this._onRemoteResponse(msg); break;\r\n      }\r\n    });\r\n\r\n    let changeURL = _this._url + '/changes';\r\n    _this._changeListener = _this._bus.addListener(changeURL, (msg) => {\r\n      //TODO: what todo here? Save changes?\r\n      if (msg.body.attribute) {\r\n        _this._parent._storeDataObjects.updateData(_this._url, 'data', msg.body.attribute, msg.body.value, true);\r\n      }\r\n      console.log('SyncherManager-' + changeURL + '-RCV: ', msg);\r\n    });\r\n  }\r\n\r\n  resumeSubscriptions(subscriptions) {\r\n    let _this = this;\r\n\r\n    Object.keys(subscriptions).forEach((key) => {\r\n      let hypertyURL = subscriptions[key];\r\n\r\n      if (!_this._subscriptions[hypertyURL]) {\r\n        _this._subscriptions[hypertyURL] = new Subscription(_this._bus, _this._owner, _this._url, _this._childrens, true);\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n  _releaseListeners() {\r\n    let _this = this;\r\n\r\n    _this._subscriptionListener.remove();\r\n\r\n    _this._changeListener.remove();\r\n\r\n    _this._childrenListeners.forEach((cl) => {\r\n      cl.remove();\r\n    });\r\n\r\n    Object.keys(_this._forwards).forEach((key) => {\r\n      _this.forwardUnSubscribe(key);\r\n    });\r\n\r\n    //remove all subscriptions\r\n    Object.keys(_this._subscriptions).forEach((key) => {\r\n      _this._subscriptions[key]._releaseListeners();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Register a listener in the msg-node and in the local MessageBus, so that messages on this address are forwarded to the reporter object\r\n   * @param  {string} address - URL to register the listeners\r\n   * @return {Promise} Return Promise OK or error\r\n   */\r\n  forwardSubscribe(addresses) {\r\n    let _this = this;\r\n\r\n    //FLOW-OUT: message sent to the msg-node SubscriptionManager component\r\n    let nodeSubscribeMsg = {\r\n      type: 'subscribe', from: _this._parent._url, to: 'domain://msg-node.' + _this._domain + '/sm',\r\n      body: { subscribe: addresses, source: _this._owner }\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n      _this._bus.postMessage(nodeSubscribeMsg, (reply) => {\r\n        console.log('forward-subscribe-response(reporter): ', reply);\r\n        if (reply.body.code === 200) {\r\n          let newForward = _this._bus.addForward(_this._url, _this._owner);\r\n          _this._forwards[addresses[0]] = newForward;\r\n          resolve();\r\n        } else {\r\n          reject('Error on msg-node subscription: ' + reply.body.desc);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * UnRegister a listener in the msg-node and in the local MessageBus, so that messages on this address are removed from forward\r\n   * @param  {string} address - URL to un-register the listeners\r\n   */\r\n  forwardUnSubscribe(address) {\r\n    let _this = this;\r\n\r\n    _this._forwards[address].remove();\r\n    delete _this._forwards[address];\r\n\r\n    //FLOW-OUT: message sent to the msg-node SubscriptionManager component\r\n    let nodeUnSubscribeMsg = {\r\n      type: 'unsubscribe', from: _this._parent._url, to: 'domain://msg-node.' + _this._domain + '/sm',\r\n      body: { subscribe: [address], source: _this._owner }\r\n    };\r\n\r\n    _this._bus.postMessage(nodeUnSubscribeMsg);\r\n  }\r\n\r\n  /**\r\n   * Register listeners for a list of childrens. Public channels used to transmit messages.\r\n   * @param  {string[]} childrens - channels to register\r\n   * @return {Promise} Return Promise OK or error\r\n   */\r\n  addChildrens(childrens) {\r\n    let _this = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      if (childrens.length === 0) {\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      let childBaseURL = _this._url + '/children/';\r\n      _this._childrens.push(childrens);\r\n\r\n      /*\r\n      _this._childrens.forEach((child) => {\r\n        let childId = childBaseURL + child;\r\n\r\n        let selfForward = _this._bus.addForward(childId, owner);\r\n        _this._childrenListeners.push(selfForward);\r\n      });*/\r\n\r\n      let subscriptions = [];\r\n      childrens.forEach((child) => subscriptions.push(childBaseURL + child));\r\n\r\n      //_this._storageSubscriptions[_this._objSubscriptorURL] = {url: _this._url, owner: _this._owner, childrens: _this._childrens};\r\n\r\n      //FLOW-OUT: message sent to the msg-node SubscriptionManager component\r\n      let nodeSubscribeMsg = {\r\n        type: 'subscribe', from: _this._parent._url, to: 'domain://msg-node.' + _this._domain + '/sm',\r\n        body: { subscribe: subscriptions, source: _this._owner }\r\n      };\r\n\r\n      _this._bus.postMessage(nodeSubscribeMsg, (reply) => {\r\n        console.log('node-subscribe-response(reporter): ', reply);\r\n        if (reply.body.code === 200) {\r\n\r\n          //add children listeners on local ...\r\n          subscriptions.forEach((childURL) => {\r\n            let childListener = _this._bus.addListener(childURL, (msg) => {\r\n              //TODO: what todo here? Save childrens?\r\n              console.log('SyncherManager-' + childURL + '-RCV: ', msg);\r\n            });\r\n            _this._childrenListeners.push(childListener);\r\n\r\n            let selfForward = _this._bus.addForward(childURL, _this._owner);\r\n            _this._childrenListeners.push(selfForward);\r\n          });\r\n\r\n          resolve();\r\n        } else {\r\n          reject('Error on msg-node subscription: ' + reply.body.desc);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  delete() {\r\n    let _this = this;\r\n    let domain = divideURL(_this._owner).domain;\r\n\r\n    //FLOW-OUT: message sent directly to all subscribers of the reporter\r\n    _this._bus.postMessage({\r\n      type: 'delete', from: _this._objSubscriptorURL, to: _this._url + '/changes'\r\n    });\r\n\r\n    //FLOW-OUT: message sent to the msg-node ObjectAllocationManager component\r\n    _this._bus.postMessage({\r\n      type: 'delete', from: _this._parent._url, to: 'domain://msg-node.' + domain + '/object-address-allocation',\r\n      body: { resource: _this._url, childrenResources: _this._childrens }\r\n    });\r\n\r\n    _this._releaseListeners();\r\n    delete _this._parent._reporters[_this._url];\r\n  }\r\n\r\n  _onRemoteResponse(msg) {\r\n    let _this = this;\r\n\r\n    _this._bus.postMessage({\r\n      id: msg.id, type: 'response', from: msg.to, to: _this._url,\r\n      body: { code: msg.body.code, identity: msg.body.identity, source: msg.from }\r\n    });\r\n  }\r\n\r\n  //FLOW-IN: message received from Syncher -> subscribe\r\n  _onRemoteSubscribe(msg) {\r\n    let _this = this;\r\n    let hypertyURL = msg.body.subscriber;\r\n\r\n    //validate if subscription already exists?\r\n    if (_this._subscriptions[hypertyURL]) {\r\n      // let errorMsg = {\r\n      //   id: msg.id, type: 'response', from: msg.to, to: hypertyURL,\r\n      //   body: { code: 500, desc: 'Subscription for (' + _this._url + ' : ' +  hypertyURL + ') already exists!' }\r\n      // };\r\n      //\r\n      // _this._bus.postMessage(errorMsg);\r\n      // return;\r\n\r\n      // new version because of reusage\r\n      _this._subscriptions[hypertyURL]._releaseListeners();\r\n    }\r\n\r\n    //ask to subscribe to Syncher? (depends on the operation mode)\r\n    //TODO: get mode from object!\r\n    let mode = 'sub/pub';\r\n\r\n    if (mode === 'sub/pub') {\r\n      //FLOW-OUT: message sent to local hyperty address Syncher -> _onForward\r\n      let forwardMsg = {\r\n        type: 'forward', from: _this._url, to: _this._owner,\r\n        body: { type: msg.type, from: hypertyURL, to: _this._url, identity: msg.body.identity }\r\n      };\r\n\r\n      _this._bus.postMessage(forwardMsg, (reply) => {\r\n        console.log('forward-reply: ', reply);\r\n        if (reply.body.code === 200) {\r\n          if (!_this._subscriptions[hypertyURL]) {\r\n            _this._subscriptions[hypertyURL] = new Subscription(_this._bus, _this._owner, _this._url, _this._childrens, true);\r\n          }\r\n        }\r\n\r\n        // Store for each reporter hyperty the dataObject\r\n        let userURL;\r\n        if (msg.body.identity && msg.body.identity.userProfile.userURL) {\r\n          userURL = msg.body.identity.userProfile.userURL;\r\n          _this._parent._storeDataObjects.update(_this._url, 'subscriberUsers', userURL);\r\n        }\r\n\r\n        _this._parent._storeDataObjects.update(_this._url, 'subscriptions', hypertyURL);\r\n\r\n        //FLOW-OUT: subscription response sent (forward from internal Hyperty)\r\n        _this._bus.postMessage({\r\n          id: msg.id, type: 'response', from: msg.to, to: msg.from,\r\n          body: reply.body\r\n        });\r\n\r\n      });\r\n    }\r\n\r\n  }\r\n\r\n  //FLOW-IN: message received from remote ObserverObject -> removeSubscription\r\n  _onRemoteUnSubscribe(msg) {\r\n    let _this = this;\r\n    let hypertyURL = msg.body.subscriber;\r\n\r\n    let subscription = _this._subscriptions[hypertyURL];\r\n    if (subscription) {\r\n      subscription._releaseListeners();\r\n      delete _this._subscriptions[hypertyURL];\r\n\r\n      //TODO: send un-subscribe message to Syncher? (depends on the operation mode)\r\n    }\r\n\r\n  }\r\n\r\n}\r\n\r\nexport default ReporterObject;\r\n",
    "static": true,
    "longname": "src/syncher/ReporterObject.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 641,
    "kind": "class",
    "name": "ReporterObject",
    "memberof": "src/syncher/ReporterObject.js",
    "static": true,
    "longname": "src/syncher/ReporterObject.js~ReporterObject",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/syncher/ReporterObject.js",
    "importStyle": "ReporterObject",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 642,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#constructor",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "parent",
        "types": [
          "*"
        ]
      },
      {
        "name": "owner",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 643,
    "kind": "method",
    "name": "_allocateListeners",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#_allocateListeners",
    "access": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 644,
    "kind": "method",
    "name": "resumeSubscriptions",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#resumeSubscriptions",
    "access": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "subscriptions",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 645,
    "kind": "method",
    "name": "_releaseListeners",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#_releaseListeners",
    "access": null,
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 646,
    "kind": "method",
    "name": "forwardSubscribe",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#forwardSubscribe",
    "access": null,
    "description": "Register a listener in the msg-node and in the local MessageBus, so that messages on this address are forwarded to the reporter object",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "address",
        "description": "URL to register the listeners"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Return Promise OK or error"
    }
  },
  {
    "__docId__": 647,
    "kind": "method",
    "name": "forwardUnSubscribe",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#forwardUnSubscribe",
    "access": null,
    "description": "UnRegister a listener in the msg-node and in the local MessageBus, so that messages on this address are removed from forward",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "address",
        "description": "URL to un-register the listeners"
      }
    ]
  },
  {
    "__docId__": 648,
    "kind": "method",
    "name": "addChildrens",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#addChildrens",
    "access": null,
    "description": "Register listeners for a list of childrens. Public channels used to transmit messages.",
    "lineNumber": 137,
    "params": [
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "childrens",
        "description": "channels to register"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Return Promise OK or error"
    }
  },
  {
    "__docId__": 649,
    "kind": "method",
    "name": "delete",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#delete",
    "access": null,
    "description": null,
    "lineNumber": 192,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "_onRemoteResponse",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#_onRemoteResponse",
    "access": null,
    "description": null,
    "lineNumber": 211,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 651,
    "kind": "method",
    "name": "_onRemoteSubscribe",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#_onRemoteSubscribe",
    "access": null,
    "description": null,
    "lineNumber": 221,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 652,
    "kind": "method",
    "name": "_onRemoteUnSubscribe",
    "memberof": "src/syncher/ReporterObject.js~ReporterObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ReporterObject.js~ReporterObject#_onRemoteUnSubscribe",
    "access": null,
    "description": null,
    "lineNumber": 279,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 653,
    "kind": "file",
    "name": "src/syncher/StoreDataObjects.js",
    "content": "class StoreDataObjects {\r\n\r\n  constructor(storageManager) {\r\n    if (!storageManager) throw new Error('[Store Data Objects] - Needs the storageManager component');\r\n\r\n    this._storageManager = storageManager;\r\n    this._storeDataObject = {};\r\n  }\r\n\r\n  set(resource, isReporter, schema, status, data, subscription, children, childrenResources, subscriberUser) {\r\n\r\n    let type = this._getTypeOfObject(isReporter);\r\n    if (!this._storeDataObject.hasOwnProperty(type)) this._storeDataObject[type] = {};\r\n\r\n    if (!this._storeDataObject[type].hasOwnProperty(resource)) {\r\n      this._storeDataObject[type][resource] = {\r\n        resource: resource,\r\n        isReporter: isReporter,\r\n        subscriptions: [],\r\n        subscriberUsers: []\r\n      };\r\n    }\r\n\r\n    if (data) this._storeDataObject[type][resource].data = data;\r\n    if (schema) this._storeDataObject[type][resource].schema = schema;\r\n    if (status) this._storeDataObject[type][resource].status = status;\r\n    if (children) this._storeDataObject[type][resource].children = children;\r\n    if (childrenResources) this._storeDataObject[type][resource].childrenResources = childrenResources;\r\n\r\n    if (subscription && !isReporter) {\r\n      this._updateToArray(resource, 'subscriptions', subscription, type);\r\n    } else {\r\n      this._storeDataObject[type][resource].owner = subscription;\r\n    }\r\n\r\n    if (subscriberUser) {\r\n      if (this._storeDataObject[type][resource].subscriberUsers.indexOf(subscriberUser)) {\r\n        this._updateToArray(resource, 'subscriberUsers', subscriberUser, type);\r\n      }\r\n    }\r\n\r\n    return this._storageManager.set('syncherManager:ObjectURLs', 1, this._storeDataObject);\r\n  }\r\n\r\n  updateData(resource, key, attribute, value, isReporter = true) {\r\n    let type = this._getTypeOfObject(isReporter);\r\n\r\n    if (this._storeDataObject.hasOwnProperty(type) && this._storeDataObject[type][resource] && resource && key && value) {\r\n\r\n      if (key === 'subscriptions' || key === 'subscriberUsers') {\r\n        this._updateToArray(resource, key, value, type);\r\n      } else {\r\n        this._storeDataObject[type][resource][key][attribute] = value;\r\n      }\r\n\r\n      return this._storageManager.set('syncherManager:ObjectURLs', 1, this._storeDataObject);\r\n\r\n    }\r\n  }\r\n\r\n  update(resource, key, value, isReporter = true) {\r\n    let type = this._getTypeOfObject(isReporter);\r\n\r\n    if (this._storeDataObject[type] && this._storeDataObject[type][resource] && resource && key && value) {\r\n\r\n      if (key === 'subscriptions' || key === 'subscriberUsers') {\r\n        let update = true;\r\n\r\n        if (key === 'subscriptions') {\r\n          update = !this._isOwner(this._storeDataObject[type][resource], value);\r\n        }\r\n\r\n        if (update) this._updateToArray(resource, key, value, type);\r\n\r\n      } else {\r\n        this._storeDataObject[type][resource][key] = value;\r\n      }\r\n\r\n      return this._storageManager.set('syncherManager:ObjectURLs', 1, this._storeDataObject);\r\n\r\n    }\r\n  }\r\n\r\n  delete(resource, key, value, isReporter = true) {\r\n\r\n    let type = this._getTypeOfObject(isReporter);\r\n\r\n    if (this._storeDataObject[type] && this._storeDataObject[type][resource] && resource && key && value) {\r\n\r\n      if (key === 'subscriptions' || key === 'subscriberUsers') {\r\n        this._removeFromArray(resource, key, value, type);\r\n      } else {\r\n        delete this._storeDataObject[type][resource][key];\r\n      }\r\n\r\n      return this._storageManager.set('syncherManager:ObjectURLs', 1, this._storeDataObject);\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * TODO: check if this process is viable because the storage manager ability to delete\r\n   * now the storageManager only can delete an specific key, but not the specific value inside that key;\r\n   */\r\n  deleteResource(resource) {\r\n    if (resource) {\r\n\r\n      return this.getAll().then((storedDataObjects) => {\r\n        let tmp = storedDataObjects;\r\n\r\n        if (tmp.hasOwnProperty(resource)) {\r\n          delete tmp.observers[resource];\r\n          delete tmp.reporters[resource];\r\n          return this._storageManager.set('syncherManager:ObjectURLs', 1, tmp);\r\n        }\r\n      });\r\n\r\n    } else {\r\n      throw new Error('[StoreDataObjects] - Can\\'t delete this ' + resource);\r\n    }\r\n\r\n  }\r\n\r\n  getAll() {\r\n    return this._storageManager.get('syncherManager:ObjectURLs');\r\n  }\r\n\r\n  get(resource) {\r\n    if (this._storeDataObject[resource]) {\r\n      return this._storeDataObject[resource];\r\n    } else {\r\n      throw new Error('[StoreDataObjects] - Can\\'t find this ' + resource);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  getResourcesByCriteria(msg, isReporter) {\r\n\r\n    return new Promise((resolve) => {\r\n\r\n      let type = this._getTypeOfObject(isReporter);\r\n\r\n      this.getAll().then((storedDataObjects) => {\r\n\r\n        if (!storedDataObjects) {\r\n          console.log('don\\'t have stored data objects');\r\n          return resolve(null);\r\n        }\r\n\r\n        if (msg.body && msg.body.hasOwnProperty('resume') && !msg.body.resume) {\r\n          return resolve(null);\r\n        }\r\n\r\n        // check if the message have other criteria\r\n        // if not search for on the 'from' of the message.\r\n        let result = [];\r\n        let hasSubscription = this._hasSubscription(storedDataObjects[type], msg.from);\r\n        let isOwner = this._searchOwner(storedDataObjects[type], msg.from);\r\n\r\n        if (msg.hasOwnProperty('from') && hasSubscription || isOwner) {\r\n          let resource = this._getResourcesBySubscription(storedDataObjects[type], msg.from);\r\n\r\n          let identityFoundData = [];\r\n          if (msg.body && msg.body.identity) identityFoundData = this._getResourcesByIdentity(storedDataObjects[type], msg.body.identity);\r\n\r\n          let schemaFoundData = [];\r\n          if (msg.body && msg.body.schema) schemaFoundData = this._getResourcesBySchema(storedDataObjects[type], msg.body.schema);\r\n\r\n          let dataFound = [];\r\n          if (msg.body && msg.body.value) dataFound = this._getResourcesByData(storedDataObjects[type], msg.body.value);\r\n\r\n          // you can pass as arrays as you want.. it will be merged in on place\r\n          // removed duplicates;\r\n          result = this._intersection(resource, identityFoundData, schemaFoundData, dataFound);\r\n        } else {\r\n          return resolve(null);\r\n        }\r\n\r\n        let init = {};\r\n        result.forEach((key) => {\r\n          let currentIsReporter = storedDataObjects[type][key];\r\n          init[key] = currentIsReporter;\r\n          return init;\r\n        });\r\n\r\n        console.log('[Store Data Objects] - ', init);\r\n\r\n        resolve(init);\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n  _getResourcesByIdentity(storedData, userURL) {\r\n    if (!storedData) return [];\r\n\r\n    return Object.keys(storedData).filter((objectURL) => {\r\n      return storedData[objectURL].subscriberUsers.filter((current) => {\r\n        return current === userURL;\r\n      }).length;\r\n    });\r\n  }\r\n\r\n  _getResourcesBySubscription(storedData, subscription) {\r\n    if (!storedData) return [];\r\n\r\n    return Object.keys(storedData).filter((objectURL) => {\r\n      return storedData[objectURL].subscriptions.filter((current) => {\r\n        return current === subscription;\r\n      }).length;\r\n    });\r\n\r\n  }\r\n\r\n  _getResourcesBySchema(storedData, schema) {\r\n    return Object.keys(storedData).filter((objectURL) => {\r\n      let currentObject = storedData[objectURL];\r\n      return Object.keys(currentObject).filter((key) => {\r\n        return key === 'schema' && currentObject[key] === schema;\r\n      }).length;\r\n    });\r\n  }\r\n\r\n  _getResourcesByData(storedData, data) {\r\n    if (!data) return [];\r\n\r\n    return Object.keys(storedData).filter((objectURL) => {\r\n      let currentObject = storedData[objectURL].data;\r\n      return Object.keys(currentObject).filter((key) => {\r\n        // search on storeDataObjects for specific key provided from data;\r\n        return Object.keys(data).filter(searchFor => {\r\n          return key === searchFor && currentObject[key] === data[searchFor];\r\n        }).length;\r\n\r\n      }).length;\r\n    });\r\n  }\r\n\r\n  _hasSubscription(storedData, subscription) {\r\n    if (!storedData) return false;\r\n\r\n    return Object.keys(storedData).filter((objectURL) => {\r\n      return storedData[objectURL].subscriptions.filter((current) => {\r\n        return current === subscription;\r\n      }).length;\r\n    }).length > 0 ? true : false;\r\n  }\r\n\r\n  _searchOwner(storedData, from) {\r\n    if (!storedData) return false;\r\n\r\n    return Object.keys(storedData).filter((objectURL) => {\r\n      return storedData[objectURL].owner === from;\r\n    }).length > 0 ? true : false;\r\n  }\r\n\r\n  _isOwner(value, url) {\r\n    if (!value) return false;\r\n    return value.owner === url ? true : false;\r\n  }\r\n\r\n  _intersection() {\r\n    let args = Array.from(arguments);\r\n\r\n    let result = args.reduce((first, second) => {\r\n      return first.concat(second);\r\n    }).filter((value, index, self) => {\r\n      return self.indexOf(value) === index;\r\n    });\r\n    console.log('Result an unique array of strings: ', result);\r\n    return result;\r\n  }\r\n\r\n  _updateToArray(resource, key, value, type) {\r\n    if (this._storeDataObject[type][resource][key].indexOf(value)) this._storeDataObject[type][resource][key].push(value);\r\n  }\r\n\r\n  _removeFromArray(resource, key, value, type) {\r\n    let indexOfValue = this._storeDataObject[type][resource][key].indexOf(value);\r\n    if (indexOfValue) this._storeDataObject[type][resource][key].splice(indexOfValue, 1);\r\n  }\r\n\r\n  _hasValue(obj, key, value) {\r\n    return obj.hasOwnProperty(key) && obj[key] === value;\r\n  }\r\n\r\n  _getTypeOfObject(isReporter) {\r\n    return isReporter ? 'reporters' : 'observers';\r\n  }\r\n\r\n}\r\n\r\nexport default StoreDataObjects;\r\n",
    "static": true,
    "longname": "src/syncher/StoreDataObjects.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 654,
    "kind": "class",
    "name": "StoreDataObjects",
    "memberof": "src/syncher/StoreDataObjects.js",
    "static": true,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/syncher/StoreDataObjects.js",
    "importStyle": "StoreDataObjects",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 655,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#constructor",
    "access": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "storageManager",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 656,
    "kind": "member",
    "name": "_storageManager",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_storageManager",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 657,
    "kind": "member",
    "name": "_storeDataObject",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_storeDataObject",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 658,
    "kind": "method",
    "name": "set",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#set",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "resource",
        "types": [
          "*"
        ]
      },
      {
        "name": "isReporter",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "status",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "subscription",
        "types": [
          "*"
        ]
      },
      {
        "name": "children",
        "types": [
          "*"
        ]
      },
      {
        "name": "childrenResources",
        "types": [
          "*"
        ]
      },
      {
        "name": "subscriberUser",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 659,
    "kind": "method",
    "name": "updateData",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#updateData",
    "access": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "resource",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "attribute",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "isReporter",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": true,
        "defaultValue": "true"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 660,
    "kind": "method",
    "name": "update",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#update",
    "access": null,
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "resource",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "isReporter",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": true,
        "defaultValue": "true"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 661,
    "kind": "method",
    "name": "delete",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#delete",
    "access": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "resource",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "isReporter",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": true,
        "defaultValue": "true"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 662,
    "kind": "method",
    "name": "deleteResource",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#deleteResource",
    "access": null,
    "description": "TODO: check if this process is viable because the storage manager ability to delete\nnow the storageManager only can delete an specific key, but not the specific value inside that key;",
    "lineNumber": 106,
    "params": [
      {
        "name": "resource",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 663,
    "kind": "method",
    "name": "getAll",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#getAll",
    "access": null,
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 664,
    "kind": "method",
    "name": "get",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#get",
    "access": null,
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "resource",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 665,
    "kind": "method",
    "name": "getResourcesByCriteria",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#getResourcesByCriteria",
    "access": null,
    "description": "",
    "lineNumber": 140,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "isReporter",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 666,
    "kind": "method",
    "name": "_getResourcesByIdentity",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_getResourcesByIdentity",
    "access": null,
    "description": null,
    "lineNumber": 198,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "storedData",
        "types": [
          "*"
        ]
      },
      {
        "name": "userURL",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 667,
    "kind": "method",
    "name": "_getResourcesBySubscription",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_getResourcesBySubscription",
    "access": null,
    "description": null,
    "lineNumber": 208,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "storedData",
        "types": [
          "*"
        ]
      },
      {
        "name": "subscription",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 668,
    "kind": "method",
    "name": "_getResourcesBySchema",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_getResourcesBySchema",
    "access": null,
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "storedData",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 669,
    "kind": "method",
    "name": "_getResourcesByData",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_getResourcesByData",
    "access": null,
    "description": null,
    "lineNumber": 228,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "storedData",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 670,
    "kind": "method",
    "name": "_hasSubscription",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_hasSubscription",
    "access": null,
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "storedData",
        "types": [
          "*"
        ]
      },
      {
        "name": "subscription",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 671,
    "kind": "method",
    "name": "_searchOwner",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_searchOwner",
    "access": null,
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "storedData",
        "types": [
          "*"
        ]
      },
      {
        "name": "from",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 672,
    "kind": "method",
    "name": "_isOwner",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_isOwner",
    "access": null,
    "description": null,
    "lineNumber": 261,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 673,
    "kind": "method",
    "name": "_intersection",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_intersection",
    "access": null,
    "description": null,
    "lineNumber": 266,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 674,
    "kind": "method",
    "name": "_updateToArray",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_updateToArray",
    "access": null,
    "description": null,
    "lineNumber": 278,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "resource",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 675,
    "kind": "method",
    "name": "_removeFromArray",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_removeFromArray",
    "access": null,
    "description": null,
    "lineNumber": 282,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "resource",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 676,
    "kind": "method",
    "name": "_hasValue",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_hasValue",
    "access": null,
    "description": null,
    "lineNumber": 287,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 677,
    "kind": "method",
    "name": "_getTypeOfObject",
    "memberof": "src/syncher/StoreDataObjects.js~StoreDataObjects",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/StoreDataObjects.js~StoreDataObjects#_getTypeOfObject",
    "access": null,
    "description": null,
    "lineNumber": 291,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "isReporter",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 678,
    "kind": "file",
    "name": "src/syncher/Subscription.js",
    "content": "class Subscription {\r\n\r\n  constructor(bus, owner, url, childrens, isReporter) {\r\n    let _this = this;\r\n    let childBaseURL = url + '/children/';\r\n    let changeURL = url + '/changes';\r\n\r\n    //process delete message\r\n    _this._deleteListener = bus.addListener(changeURL, (msg) => {\r\n      if (msg.type === 'delete') {\r\n        console.log('Subscription-DELETE: ', msg);\r\n\r\n        //FLOW-OUT: message sent to all subscribers\r\n        let deleteMessageToHyperty = {\r\n          type: 'delete', from: msg.from, to: owner,\r\n          body: { identity: msg.body.identity, resource: url }\r\n        };\r\n\r\n        //send delete to hyperty\r\n        bus.postMessage(deleteMessageToHyperty, (reply) => {\r\n          console.log('Subscription-DELETE-REPLY: ', reply);\r\n          if (reply.body.code === 200) {\r\n            _this._releaseListeners();\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    //add change publish address or forward\r\n    if (isReporter) {\r\n      _this._changeListener = bus.addPublish(changeURL);\r\n    } else {\r\n      _this._changeListener = bus.addForward(changeURL, owner);\r\n    }\r\n\r\n    _this._childrenListeners = [];\r\n    childrens.forEach((child) => {\r\n      let childId = childBaseURL + child;\r\n\r\n      //add children publish address\r\n      let childrenForward = bus.addPublish(childId);\r\n      _this._childrenListeners.push(childrenForward);\r\n\r\n      //add self forward if an observer\r\n      if (!isReporter) {\r\n        let selfForward = bus.addForward(childId, owner);\r\n        _this._childrenListeners.push(selfForward);\r\n      }\r\n    });\r\n  }\r\n\r\n  _releaseListeners() {\r\n    let _this = this;\r\n\r\n    _this._deleteListener.remove();\r\n\r\n    _this._changeListener.remove();\r\n\r\n    _this._childrenListeners.forEach((forward) => {\r\n      forward.remove();\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default Subscription;\r\n",
    "static": true,
    "longname": "src/syncher/Subscription.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 679,
    "kind": "class",
    "name": "Subscription",
    "memberof": "src/syncher/Subscription.js",
    "static": true,
    "longname": "src/syncher/Subscription.js~Subscription",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/syncher/Subscription.js",
    "importStyle": "Subscription",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 680,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/Subscription.js~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Subscription.js~Subscription#constructor",
    "access": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "bus",
        "types": [
          "*"
        ]
      },
      {
        "name": "owner",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "childrens",
        "types": [
          "*"
        ]
      },
      {
        "name": "isReporter",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 681,
    "kind": "method",
    "name": "_releaseListeners",
    "memberof": "src/syncher/Subscription.js~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Subscription.js~Subscription#_releaseListeners",
    "access": null,
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 682,
    "kind": "file",
    "name": "src/syncher/SyncherManager.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\nimport { divideURL } from '../utils/utils';\r\nimport { schemaValidation } from '../utils/schemaValidation';\r\n\r\nimport AddressAllocation from '../allocation/AddressAllocation';\r\nimport ReporterObject from './ReporterObject';\r\nimport ObserverObject from './ObserverObject';\r\n\r\nimport {MessageFactory} from 'service-framework/dist/MessageFactory';\r\n\r\nimport StoreDataObjects from './StoreDataObjects';\r\n\r\n/**\r\n * @author micaelpedrosa@gmail.com\r\n * Core Syncronization system.\r\n */\r\nclass SyncherManager {\r\n  /* private\r\n  _url: URL\r\n  _bus: MiniBus\r\n  _registry: Registry\r\n  _allocator: AddressAllocation\r\n\r\n  _reporters: { ObjectURL: ReporterObject }\r\n  _observers: { ObjectURL: ObserverObject }\r\n  */\r\n\r\n  constructor(runtimeURL, bus, registry, catalog, storageManager, allocator) {\r\n    if (!runtimeURL) throw new Error('[Syncher Manager] - needs the runtimeURL parameter');\r\n    if (!bus) throw new Error('[Syncher Manager] - needs the MessageBus instance');\r\n    if (!registry) throw new Error('[Syncher Manager] - needs the Registry instance');\r\n    if (!catalog) throw new Error('[Syncher Manager] - needs the RuntimeCatalogue instance');\r\n    if (!storageManager) throw new Error('[Syncher Manager] - need the storageManager instance');\r\n\r\n    let _this = this;\r\n\r\n    _this._bus = bus;\r\n    _this._registry = registry;\r\n    _this._catalog = catalog;\r\n    _this._storageManager = storageManager;\r\n\r\n    //TODO: these should be saved in persistence engine?\r\n    _this.runtimeURL = runtimeURL;\r\n    _this._url = runtimeURL + '/sm';\r\n    _this._objectURL = runtimeURL + '/object-allocation';\r\n\r\n    _this._reporters = {};\r\n    _this._observers = {};\r\n\r\n    _this._storeDataObjects = new StoreDataObjects(storageManager);\r\n\r\n    //TODO: this should not be hardcoded!\r\n    _this._domain = divideURL(runtimeURL).domain;\r\n\r\n    _this._mf = new MessageFactory(false, {});\r\n\r\n    if (allocator) {\r\n      _this._allocator = allocator;\r\n    } else {\r\n      _this._allocator = AddressAllocation.instance;\r\n    }\r\n\r\n    console.log('[SyncherManager - AddressAllocation] - ', _this._allocator);\r\n\r\n    bus.addListener(_this._url, (msg) => {\r\n      console.log('SyncherManager-RCV: ', msg);\r\n      switch (msg.type) {\r\n        case 'create': _this._onCreate(msg); break;\r\n        case 'delete': _this._onDelete(msg); break;\r\n        case 'subscribe': _this._onLocalSubscribe(msg); break;\r\n        case 'unsubscribe': _this._onLocalUnSubscribe(msg); break;\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n  get url() { return this._url; }\r\n\r\n  //FLOW-IN: message received from Syncher -> create\r\n  _onCreate(msg) {\r\n\r\n    if (msg.body.hasOwnProperty('resume') && !msg.body.resume) {\r\n      console.info('[SyncherManager - Create New Object]', msg);\r\n      this._newCreate(msg);\r\n    } else {\r\n      this._storeDataObjects.getResourcesByCriteria(msg, true).then((result) => {\r\n\r\n        console.info('[SyncherManager - Create Resumed Object]', msg);\r\n\r\n        if (result && Object.keys(result).length > 0) {\r\n\r\n          // TODO: should reuse the storaged information\r\n          Object.keys(result).forEach((objURL) => {\r\n            this._resumeCreate(msg, result[objURL]);\r\n          });\r\n\r\n        } else {\r\n          //forward to hyperty:\r\n          let reply = {};\r\n          reply.id = msg.id;\r\n          reply.from = msg.to;\r\n          reply.to = msg.from;\r\n          reply.type = 'response';\r\n          reply.body = {\r\n            code: 404,\r\n            desc: 'No data objects to be resumed'\r\n          };\r\n          this._bus.postMessage(reply);\r\n        }\r\n\r\n      });\r\n    }\r\n\r\n  }\r\n\r\n  _newCreate(msg) {\r\n    let _this = this;\r\n\r\n    let owner = msg.from;\r\n    let domain = divideURL(msg.from).domain;\r\n\r\n    // if reporter is in a Interworking Protostub the runtime domain backend services will be used\r\n    if (_this._registry.isInterworkingProtoStub(msg.from)) {\r\n      domain = divideURL(_this.runtimeURL).domain;\r\n    }\r\n\r\n    if (msg.body.resource) {\r\n      _this._authorise(msg, msg.body.resource);\r\n      return;\r\n    }\r\n\r\n    //get schema from catalogue and parse -> (scheme, children)\r\n    _this._catalog.getDataSchemaDescriptor(msg.body.schema).then((descriptor) => {\r\n\r\n      let properties = descriptor.sourcePackage.sourceCode.properties;\r\n      let scheme = properties.scheme ? properties.scheme.constant : 'resource';\r\n      let childrens = properties.children ? properties.children.constant : [];\r\n\r\n      // Do schema validation\r\n      // TODO: check if is need to handle with the result of validation\r\n      schemaValidation(scheme, descriptor, msg.body.value);\r\n\r\n      let objectInfo = {\r\n        name: msg.body.value.name,\r\n        schema: msg.body.value.schema,\r\n        reporter: msg.body.value.reporter,\r\n        resources: msg.body.value.resources\r\n      };\r\n\r\n      // should resuse data object url if it passed\r\n      let reuseDataObject = msg.body.value.resource;\r\n      let numOfAddress = 1;\r\n\r\n      //request address allocation of a new object from the msg-node\r\n      _this._allocator.create(domain, numOfAddress, objectInfo, scheme, reuseDataObject).then((allocated) => {\r\n        let objURL = allocated.address[0];\r\n\r\n        console.log('ALLOCATOR CREATE:', allocated);\r\n\r\n        let subscriptionURL = objURL + '/subscription';\r\n\r\n        console.log('Subscription URL', subscriptionURL);\r\n\r\n        //To register the dataObject in the runtimeRegistry\r\n        console.info('Register Object: ', msg.body.value.name, msg.body.value.schema, objURL, msg.body.value.reporter, msg.body.value.resources);\r\n        _this._registry.registerDataObject(msg.body.value.name, msg.body.value.schema, objURL, msg.body.value.reporter, msg.body.value.resources, allocated, msg.body.authorise).then((resolve) => {\r\n          console.log('DataObject successfully registered', resolve);\r\n\r\n          //all OK -> create reporter and register listeners\r\n          let reporter;\r\n\r\n          if (!this._reporters[objURL]) {\r\n            reporter = new ReporterObject(_this, owner, objURL);\r\n          } else {\r\n            reporter = this._reporters[objURL];\r\n          }\r\n\r\n          console.log('[SyncherManager - new Create] - ', msg);\r\n\r\n          if (msg.body.hasOwnProperty('store') && msg.body.store) {\r\n            // Store for each reporter hyperty the dataObject\r\n            let userURL;\r\n            if (msg.body.hasOwnProperty('identity') && msg.body.identity.userProfile.userURL) {\r\n              userURL = msg.body.identity.userProfile.userURL;\r\n            }\r\n\r\n            _this._storeDataObjects.set(objURL, true, msg.body.schema, 'on', msg.body.value, owner, null, childrens, userURL);\r\n          }\r\n\r\n          reporter.forwardSubscribe([objURL, subscriptionURL]).then(() => {\r\n            reporter.addChildrens(childrens).then(() => {\r\n              _this._reporters[objURL] = reporter;\r\n\r\n              //FLOW-OUT: message response to Syncher -> create\r\n              _this._bus.postMessage({\r\n                id: msg.id, type: 'response', from: msg.to, to: owner,\r\n                body: { code: 200, resource: objURL, childrenResources: childrens }\r\n              });\r\n\r\n              //send create to all observers, responses will be deliver to the Hyperty owner?\r\n              //schedule for next cycle needed, because the Reporter should be available.\r\n              setTimeout(() => {\r\n                //will invite other hyperties\r\n                _this._authorise(msg, objURL);\r\n              });\r\n            });\r\n          });\r\n        }, function(error) {\r\n          console.error(error);\r\n        });\r\n\r\n      });\r\n    }).catch((reason) => {\r\n      //FLOW-OUT: error message response to Syncher -> create\r\n      let responseMsg = {\r\n        id: msg.id, type: 'response', from: msg.to, to: owner,\r\n        body: { code: 500, desc: reason }\r\n      };\r\n\r\n      _this._bus.postMessage(responseMsg);\r\n    });\r\n\r\n  }\r\n\r\n  _resumeCreate(msg, storedObject) {\r\n\r\n    let _this = this;\r\n\r\n    let owner = msg.from;\r\n    let schema = storedObject.schema;\r\n    let resource = storedObject.resource;\r\n    let initialData = storedObject.data;\r\n\r\n    console.log('[SyncherManager] - resumeCreate', msg);\r\n\r\n    let authMsg = msg;\r\n    authMsg.body.authorise = storedObject.subscriptions;\r\n\r\n    // // TODO: Check why the _authorise is called;\r\n    // if (resource) {\r\n    //   _this._authorise(authMsg, resource);\r\n    //   return;\r\n    // }\r\n\r\n    //get schema from catalogue and parse -> (scheme, children)\r\n    _this._catalog.getDataSchemaDescriptor(schema).then((descriptor) => {\r\n\r\n      let properties = descriptor.sourcePackage.sourceCode.properties;\r\n      let scheme = properties.scheme ? properties.scheme.constant : 'resource';\r\n      let childrens = properties.children ? properties.children.constant : [];\r\n\r\n      // Do schema validation\r\n      // TODO: check if is need to handle with the result of validation\r\n      schemaValidation(scheme, descriptor, initialData);\r\n\r\n      //all OK -> create reporter and register listeners\r\n      let reporter;\r\n\r\n      if (!this._reporters[resource]) {\r\n        reporter = new ReporterObject(_this, owner, resource);\r\n      } else {\r\n        reporter = this._reporters[resource];\r\n      }\r\n\r\n      _this._reporters[resource] = reporter;\r\n\r\n      reporter.resumeSubscriptions(storedObject.subscriptions);\r\n\r\n      //FLOW-OUT: message response to Syncher -> create\r\n      _this._bus.postMessage({\r\n        id: msg.id, type: 'response', from: msg.to, to: owner,\r\n        body: { code: 200, resource: resource, childrenResources: childrens, schema: schema, value: storedObject.data }\r\n      });\r\n\r\n      // //send create to all observers, responses will be deliver to the Hyperty owner?\r\n      // //schedule for next cycle needed, because the Reporter should be available.\r\n      // setTimeout(() => {\r\n      //   //will invite other hyperties\r\n      //   _this._authorise(authMsg, resource);\r\n      // });\r\n\r\n    });\r\n  }\r\n\r\n  _authorise(msg, objURL) {\r\n    let _this = this;\r\n    let objSubscriptorURL = objURL + '/subscription';\r\n\r\n    msg.body.authorise.forEach((hypertyURL) => {\r\n      //FLOW-OUT: send invites to list of remote Syncher -> _onRemoteCreate -> onNotification\r\n      _this._bus.postMessage({\r\n        type: 'create', from: objSubscriptorURL, to: hypertyURL,\r\n        body: { identity: msg.body.identity, source: msg.from, value: msg.body.value, schema: msg.body.schema }\r\n      });\r\n    });\r\n  }\r\n\r\n  //FLOW-IN: message received from DataObjectReporter -> delete\r\n  _onDelete(msg) {\r\n    let _this = this;\r\n\r\n    let objURL = msg.body.resource;\r\n\r\n    let object = _this._reporters[objURL];\r\n    if (object) {\r\n      //TODO: is there any policy verification before delete?\r\n      object.delete();\r\n\r\n      this._storeDataObjects.deleteResource(objURL);\r\n\r\n      //TODO: unregister object?\r\n      _this._bus.postMessage({\r\n        id: msg.id, type: 'response', from: msg.to, to: msg.from,\r\n        body: { code: 200 }\r\n      });\r\n    }\r\n  }\r\n\r\n  //FLOW-IN: message received from local Syncher -> subscribe\r\n  _onLocalSubscribe(msg) {\r\n\r\n    this._storeDataObjects.getResourcesByCriteria(msg, false).then((result) => {\r\n\r\n      console.log('[SyncherManager - Subscribe] - filter result', result);\r\n\r\n      if (result && Object.keys(result).length > 0) {\r\n\r\n        // TODO: should reuse the storaged information\r\n        Object.keys(result).forEach((objURL) => {\r\n          console.log('[SyncherManager - resume Subscribe] - reuse current object url: ', result[objURL]);\r\n          this._resumeSubscription(msg, result[objURL]);\r\n        });\r\n\r\n      } else if (msg.body.schema && msg.body.resource) {\r\n        console.log('[SyncherManager - new Subscribe] - ', msg.body.schema, msg.body.resource);\r\n        this._newSubscription(msg);\r\n      } else {\r\n        //forward to hyperty:\r\n        let reply = {};\r\n        reply.id = msg.id;\r\n        reply.from = msg.to;\r\n        reply.to = msg.from;\r\n        reply.type = 'response';\r\n        reply.body = {\r\n          code: 404,\r\n          desc: 'No data objects to be resumed'\r\n        };\r\n        this._bus.postMessage(reply);\r\n      }\r\n\r\n    });\r\n\r\n  }\r\n\r\n  _newSubscription(msg) {\r\n    let _this = this;\r\n\r\n    let objURL = msg.body.resource;\r\n\r\n    let hypertyURL = msg.from;\r\n    let domain = divideURL(objURL).domain;\r\n    let objURLSubscription = objURL + '/subscription';\r\n\r\n    let childBaseURL = objURL + '/children/';\r\n\r\n    //get schema from catalogue and parse -> (children)\r\n    _this._catalog.getDataSchemaDescriptor(msg.body.schema).then((descriptor) => {\r\n      let properties = descriptor.sourcePackage.sourceCode.properties;\r\n      let childrens = properties.children ? properties.children.constant : [];\r\n\r\n      //children addresses\r\n      let subscriptions = [];\r\n      subscriptions.push(objURL + '/changes');\r\n      childrens.forEach((child) => subscriptions.push(childBaseURL + child));\r\n\r\n      //FLOW-OUT: subscribe message to the msg-node, registering listeners on the broker\r\n      let nodeSubscribeMsg = {\r\n        type: 'subscribe', from: _this._url, to: 'domain://msg-node.' + domain + '/sm',\r\n        body: { identity: msg.body.identity, subscribe: subscriptions, source: hypertyURL }\r\n      };\r\n\r\n      //subscribe in msg-node\r\n      _this._bus.postMessage(nodeSubscribeMsg, (reply) => {\r\n        console.log('node-subscribe-response(observer): ', reply);\r\n        if (reply.body.code === 200) {\r\n\r\n          //FLOW-OUT: reply with provisional response\r\n          _this._bus.postMessage({\r\n            id: msg.id, type: 'response', from: msg.to, to: hypertyURL,\r\n            body: { code: 100, childrenResources: childrens, schema: msg.body.schema, resource: msg.body.resource }\r\n          });\r\n\r\n          //FLOW-OUT: subscribe message to remote ReporterObject -> _onRemoteSubscribe\r\n          let objSubscribeMsg = {\r\n            type: 'subscribe', from: _this._url, to: objURLSubscription,\r\n            body: { identity: nodeSubscribeMsg.body.identity, subscriber: hypertyURL }\r\n          };\r\n\r\n          //subscribe to reporter SM\r\n          _this._bus.postMessage(objSubscribeMsg, (reply) => {\r\n            console.log('reporter-subscribe-response-new: ', reply);\r\n            if (reply.body.code === 200) {\r\n\r\n              let observer = _this._observers[objURL];\r\n              if (!observer) {\r\n                observer = new ObserverObject(_this, objURL, childrens);\r\n                _this._observers[objURL] = observer;\r\n              }\r\n\r\n              if (msg.body.hasOwnProperty('store') && msg.body.store) {\r\n                // Store for each reporter hyperty the dataObject\r\n                let userURL;\r\n                if (msg.body.hasOwnProperty('identity') && msg.body.identity.userProfile.userURL) {\r\n                  userURL = msg.body.identity.userProfile.userURL;\r\n                }\r\n\r\n                _this._storeDataObjects.set(objURL, false, msg.body.schema, 'on', {}, hypertyURL, null, childrens, userURL);\r\n              }\r\n\r\n              //register new hyperty subscription\r\n              observer.addSubscription(hypertyURL);\r\n\r\n              //forward to hyperty:\r\n              reply.id = msg.id;\r\n              reply.from = _this._url;\r\n              reply.to = hypertyURL;\r\n              reply.body.schema = msg.body.schema;\r\n              reply.body.resource = msg.body.resource;\r\n\r\n              console.log('[subscribe] - new subscription: ', msg, reply, observer);\r\n\r\n              this._bus.postMessage(reply);\r\n\r\n            }\r\n          });\r\n\r\n        } else {\r\n          //listener rejected\r\n          _this._bus.postMessage({\r\n            id: msg.id, type: 'response', from: msg.to, to: hypertyURL,\r\n            body: reply.body\r\n          });\r\n        }\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n  _resumeSubscription(msg, storedObject) {\r\n    let objURL = storedObject.resource;\r\n    let schema = storedObject.schema;\r\n\r\n    let hypertyURL = msg.from;\r\n    let objURLSubscription = objURL + '/subscription';\r\n\r\n    let childBaseURL = objURL + '/children/';\r\n\r\n    console.log('[SyncherManager ReuseSubscription] - objURL: ', objURL, ' - schema:', schema);\r\n\r\n    //get schema from catalogue and parse -> (children)\r\n    this._catalog.getDataSchemaDescriptor(schema).then((descriptor) => {\r\n      let properties = descriptor.sourcePackage.sourceCode.properties;\r\n      let childrens = properties.children ? properties.children.constant : [];\r\n\r\n      //children addresses\r\n      let subscriptions = [];\r\n      subscriptions.push(objURL + '/changes');\r\n      childrens.forEach((child) => subscriptions.push(childBaseURL + child));\r\n\r\n      //FLOW-OUT: reply with provisional response\r\n      this._bus.postMessage({\r\n        id: msg.id, type: 'response', from: msg.to, to: hypertyURL,\r\n        body: { code: 100, childrenResources: childrens, schema: schema, resource: objURL }\r\n      });\r\n\r\n      //FLOW-OUT: subscribe message to remote ReporterObject -> _onRemoteSubscribe\r\n      let objSubscribeMsg = {\r\n        type: 'subscribe', from: this._url, to: objURLSubscription,\r\n        body: { subscriber: hypertyURL }\r\n      };\r\n\r\n      //subscribe to reporter SM\r\n      this._bus.postMessage(objSubscribeMsg, (reply) => {\r\n\r\n        let observer = this._observers[objURL];\r\n        if (!observer) {\r\n          observer = new ObserverObject(this, objURL, childrens);\r\n          this._observers[objURL] = observer;\r\n        }\r\n\r\n        //register new hyperty subscription\r\n        observer.addSubscription(hypertyURL);\r\n\r\n        //forward to hyperty:\r\n        let response = {\r\n          id: msg.id, from: this._url, to: hypertyURL, type: 'response',\r\n          body: reply.body\r\n        };\r\n\r\n        response.body.schema = schema;\r\n        response.body.resource = objURL;\r\n\r\n        console.log('[subscribe] - resume subscription: ', msg, reply, response, observer);\r\n\r\n        this._bus.postMessage(response);\r\n\r\n      });\r\n\r\n    });\r\n  }\r\n\r\n  //FLOW-IN: message received from local DataObjectObserver -> unsubscribe\r\n  _onLocalUnSubscribe(msg) {\r\n    let _this = this;\r\n\r\n    let hypertyURL = msg.from;\r\n    let objURL = msg.body.resource;\r\n\r\n    let observer = _this._observers[objURL];\r\n    if (observer) {\r\n      //TODO: is there any policy verification before delete?\r\n      observer.removeSubscription(hypertyURL);\r\n\r\n      //TODO: destroy object in the registry?\r\n      _this._bus.postMessage({\r\n        id: msg.id, type: 'response', from: msg.to, to: msg.from,\r\n        body: { code: 200 }\r\n      });\r\n\r\n      this._storeDataObjects.delete(objURL, 'subscriptions', hypertyURL, true);\r\n\r\n      //TODO: remove Object if no more subscription?\r\n      //delete _this._observers[objURL];\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default SyncherManager;\r\n",
    "static": true,
    "longname": "src/syncher/SyncherManager.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 683,
    "kind": "class",
    "name": "SyncherManager",
    "memberof": "src/syncher/SyncherManager.js",
    "static": true,
    "longname": "src/syncher/SyncherManager.js~SyncherManager",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/syncher/SyncherManager.js",
    "importStyle": "SyncherManager",
    "description": "",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nCore Syncronization system."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 684,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#constructor",
    "access": null,
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "runtimeURL",
        "types": [
          "*"
        ]
      },
      {
        "name": "bus",
        "types": [
          "*"
        ]
      },
      {
        "name": "registry",
        "types": [
          "*"
        ]
      },
      {
        "name": "catalog",
        "types": [
          "*"
        ]
      },
      {
        "name": "storageManager",
        "types": [
          "*"
        ]
      },
      {
        "name": "allocator",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 685,
    "kind": "get",
    "name": "url",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#url",
    "access": null,
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 686,
    "kind": "method",
    "name": "_onCreate",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#_onCreate",
    "access": null,
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 687,
    "kind": "method",
    "name": "_newCreate",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#_newCreate",
    "access": null,
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 688,
    "kind": "method",
    "name": "_resumeCreate",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#_resumeCreate",
    "access": null,
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "storedObject",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 689,
    "kind": "method",
    "name": "_authorise",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#_authorise",
    "access": null,
    "description": null,
    "lineNumber": 306,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "objURL",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 690,
    "kind": "method",
    "name": "_onDelete",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#_onDelete",
    "access": null,
    "description": null,
    "lineNumber": 320,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 691,
    "kind": "method",
    "name": "_onLocalSubscribe",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#_onLocalSubscribe",
    "access": null,
    "description": null,
    "lineNumber": 341,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 692,
    "kind": "method",
    "name": "_newSubscription",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#_newSubscription",
    "access": null,
    "description": null,
    "lineNumber": 376,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 693,
    "kind": "method",
    "name": "_resumeSubscription",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#_resumeSubscription",
    "access": null,
    "description": null,
    "lineNumber": 471,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "storedObject",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 694,
    "kind": "method",
    "name": "_onLocalUnSubscribe",
    "memberof": "src/syncher/SyncherManager.js~SyncherManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncherManager.js~SyncherManager#_onLocalUnSubscribe",
    "access": null,
    "description": null,
    "lineNumber": 535,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 695,
    "kind": "file",
    "name": "src/utils/EventEmitter.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n/**\r\n * EventEmitter\r\n * All classes which extends this, can have addEventListener and trigger events;\r\n */\r\nclass EventEmitter {\r\n\r\n  /**\r\n   * addEventListener listen for an eventType\r\n   * @param  {string}         eventType - listening for this type of event\r\n   * @param  {Function}       cb        - callback function will be executed when the event it is invoked\r\n   */\r\n  addEventListener(eventType, cb) {\r\n    let _this = this;\r\n    _this[eventType] = cb;\r\n  }\r\n\r\n  /**\r\n   * Invoke the eventType\r\n   * @param  {string} eventType - event will be invoked\r\n   * @param  {object} params - parameters will be passed to the addEventListener\r\n   */\r\n  trigger(eventType, params) {\r\n    let _this = this;\r\n\r\n    if (_this[eventType]) {\r\n      _this[eventType](params);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default EventEmitter;\r\n",
    "static": true,
    "longname": "src/utils/EventEmitter.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 696,
    "kind": "class",
    "name": "EventEmitter",
    "memberof": "src/utils/EventEmitter.js",
    "static": true,
    "longname": "src/utils/EventEmitter.js~EventEmitter",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/EventEmitter.js",
    "importStyle": "EventEmitter",
    "description": "EventEmitter\nAll classes which extends this, can have addEventListener and trigger events;",
    "lineNumber": 27,
    "interface": false
  },
  {
    "__docId__": 697,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/utils/EventEmitter.js~EventEmitter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/EventEmitter.js~EventEmitter#addEventListener",
    "access": null,
    "description": "addEventListener listen for an eventType",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventType",
        "description": "listening for this type of event"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "cb",
        "description": "callback function will be executed when the event it is invoked"
      }
    ]
  },
  {
    "__docId__": 698,
    "kind": "method",
    "name": "trigger",
    "memberof": "src/utils/EventEmitter.js~EventEmitter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/EventEmitter.js~EventEmitter#trigger",
    "access": null,
    "description": "Invoke the eventType",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventType",
        "description": "event will be invoked"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "parameters will be passed to the addEventListener"
      }
    ]
  },
  {
    "__docId__": 699,
    "kind": "file",
    "name": "src/utils/schemaValidation.js",
    "content": "import tv4 from './tv4';\r\n\r\nexport function schemaValidation(scheme, descriptor, value) {\r\n\r\n  console.log('Scheme: ', scheme);\r\n\r\n  // schema validation\r\n  console.log('Running object validation...');\r\n  try {\r\n    let obj = value;\r\n    let schema = descriptor.sourcePackage.sourceCode;\r\n\r\n    // add support for schema referencing itself\r\n    tv4.addSchema(schema.id, schema);\r\n\r\n    // validate\r\n    let result = tv4.validateMultiple(obj, schema);\r\n\r\n    // delete error stacks to improve logging\r\n    result.errors.forEach((error) => {\r\n      delete error.stack;\r\n    });\r\n\r\n    // print more details about validation if it fails or schema contains $refs\r\n    if (!result.valid || (result.missing.length > 0)) {\r\n      console.warn('Object validation ' + (result.valid ? 'succeeded, but schema contained references:' : 'failed:'), JSON.stringify(result, null, 2));\r\n      console.debug('Object:', JSON.stringify(obj, null, 2), '\\r\\nSchema:', JSON.stringify(schema, null, 2));\r\n    } else {\r\n      console.log('Object validation succeeded');\r\n    }\r\n  } catch (e) {\r\n    console.warn('Error during object validation:', e);\r\n  }\r\n\r\n}\r\n",
    "static": true,
    "longname": "src/utils/schemaValidation.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 700,
    "kind": "function",
    "name": "schemaValidation",
    "memberof": "src/utils/schemaValidation.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/schemaValidation.js~schemaValidation",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/schemaValidation.js",
    "importStyle": "{schemaValidation}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "scheme",
        "types": [
          "*"
        ]
      },
      {
        "name": "descriptor",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 701,
    "kind": "file",
    "name": "src/utils/tv4.js",
    "content": "/*\r\n Author: Geraint Luff and others\r\n Year: 2013\r\n\r\n This code is released into the \"public domain\" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.\r\n\r\n If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.\r\n */\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys\r\nif (!Object.keys) {\r\n    Object.keys = (function () {\r\n        var hasOwnProperty = Object.prototype.hasOwnProperty,\r\n            hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),\r\n            dontEnums = [\r\n                'toString',\r\n                'toLocaleString',\r\n                'valueOf',\r\n                'hasOwnProperty',\r\n                'isPrototypeOf',\r\n                'propertyIsEnumerable',\r\n                'constructor'\r\n            ],\r\n            dontEnumsLength = dontEnums.length;\r\n\r\n        return function (obj) {\r\n            if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {\r\n                throw new TypeError('Object.keys called on non-object');\r\n            }\r\n\r\n            var result = [];\r\n\r\n            for (var prop in obj) {\r\n                if (hasOwnProperty.call(obj, prop)) {\r\n                    result.push(prop);\r\n                }\r\n            }\r\n\r\n            if (hasDontEnumBug) {\r\n                for (var i = 0; i < dontEnumsLength; i++) {\r\n                    if (hasOwnProperty.call(obj, dontEnums[i])) {\r\n                        result.push(dontEnums[i]);\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n    })();\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\r\nif (!Object.create) {\r\n    Object.create = (function () {\r\n        function F() {\r\n        }\r\n\r\n        return function (o) {\r\n            if (arguments.length !== 1) {\r\n                throw new Error('Object.create implementation only accepts one parameter.');\r\n            }\r\n            F.prototype = o;\r\n            return new F();\r\n        };\r\n    })();\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray\r\nif (!Array.isArray) {\r\n    Array.isArray = function (vArg) {\r\n        return Object.prototype.toString.call(vArg) === \"[object Array]\";\r\n    };\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf\r\nif (!Array.prototype.indexOf) {\r\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */) {\r\n        if (this === null) {\r\n            throw new TypeError();\r\n        }\r\n        var t = Object(this);\r\n        var len = t.length >>> 0;\r\n\r\n        if (len === 0) {\r\n            return -1;\r\n        }\r\n        var n = 0;\r\n        if (arguments.length > 1) {\r\n            n = Number(arguments[1]);\r\n            if (n !== n) { // shortcut for verifying if it's NaN\r\n                n = 0;\r\n            } else if (n !== 0 && n !== Infinity && n !== -Infinity) {\r\n                n = (n > 0 || -1) * Math.floor(Math.abs(n));\r\n            }\r\n        }\r\n        if (n >= len) {\r\n            return -1;\r\n        }\r\n        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\r\n        for (; k < len; k++) {\r\n            if (k in t && t[k] === searchElement) {\r\n                return k;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n}\r\n\r\n// Grungey Object.isFrozen hack\r\nif (!Object.isFrozen) {\r\n    Object.isFrozen = function (obj) {\r\n        var key = \"tv4_test_frozen_key\";\r\n        while (obj.hasOwnProperty(key)) {\r\n            key += Math.random();\r\n        }\r\n        try {\r\n            obj[key] = true;\r\n            delete obj[key];\r\n            return false;\r\n        } catch (e) {\r\n            return true;\r\n        }\r\n    };\r\n}\r\n// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed\r\n\r\nvar uriTemplateGlobalModifiers = {\r\n    \"+\": true,\r\n    \"#\": true,\r\n    \".\": true,\r\n    \"/\": true,\r\n    \";\": true,\r\n    \"?\": true,\r\n    \"&\": true\r\n};\r\nvar uriTemplateSuffices = {\r\n    \"*\": true\r\n};\r\n\r\nfunction notReallyPercentEncode(string) {\r\n    return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {\r\n        return \"%\" + doubleEncoded.substring(3);\r\n    });\r\n}\r\n\r\nfunction uriTemplateSubstitution(spec) {\r\n    var modifier = \"\";\r\n    if (uriTemplateGlobalModifiers[spec.charAt(0)]) {\r\n        modifier = spec.charAt(0);\r\n        spec = spec.substring(1);\r\n    }\r\n    var separator = \"\";\r\n    var prefix = \"\";\r\n    var shouldEscape = true;\r\n    var showVariables = false;\r\n    var trimEmptyString = false;\r\n    if (modifier === '+') {\r\n        shouldEscape = false;\r\n    } else if (modifier === \".\") {\r\n        prefix = \".\";\r\n        separator = \".\";\r\n    } else if (modifier === \"/\") {\r\n        prefix = \"/\";\r\n        separator = \"/\";\r\n    } else if (modifier === '#') {\r\n        prefix = \"#\";\r\n        shouldEscape = false;\r\n    } else if (modifier === ';') {\r\n        prefix = \";\";\r\n        separator = \";\";\r\n        showVariables = true;\r\n        trimEmptyString = true;\r\n    } else if (modifier === '?') {\r\n        prefix = \"?\";\r\n        separator = \"&\";\r\n        showVariables = true;\r\n    } else if (modifier === '&') {\r\n        prefix = \"&\";\r\n        separator = \"&\";\r\n        showVariables = true;\r\n    }\r\n\r\n    var varNames = [];\r\n    var varList = spec.split(\",\");\r\n    var varSpecs = [];\r\n    var varSpecMap = {};\r\n    for (var i = 0; i < varList.length; i++) {\r\n        var varName = varList[i];\r\n        var truncate = null;\r\n        if (varName.indexOf(\":\") !== -1) {\r\n            var parts = varName.split(\":\");\r\n            varName = parts[0];\r\n            truncate = parseInt(parts[1], 10);\r\n        }\r\n        var suffices = {};\r\n        while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {\r\n            suffices[varName.charAt(varName.length - 1)] = true;\r\n            varName = varName.substring(0, varName.length - 1);\r\n        }\r\n        var varSpec = {\r\n            truncate: truncate,\r\n            name: varName,\r\n            suffices: suffices\r\n        };\r\n        varSpecs.push(varSpec);\r\n        varSpecMap[varName] = varSpec;\r\n        varNames.push(varName);\r\n    }\r\n    var subFunction = function (valueFunction) {\r\n        var result = \"\";\r\n        var startIndex = 0;\r\n        for (var i = 0; i < varSpecs.length; i++) {\r\n            var varSpec = varSpecs[i];\r\n            var value = valueFunction(varSpec.name);\r\n            if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {\r\n                startIndex++;\r\n                continue;\r\n            }\r\n            if (i === startIndex) {\r\n                result += prefix;\r\n            } else {\r\n                result += (separator || \",\");\r\n            }\r\n            if (Array.isArray(value)) {\r\n                if (showVariables) {\r\n                    result += varSpec.name + \"=\";\r\n                }\r\n                for (var j = 0; j < value.length; j++) {\r\n                    if (j > 0) {\r\n                        result += varSpec.suffices['*'] ? (separator || \",\") : \",\";\r\n                        if (varSpec.suffices['*'] && showVariables) {\r\n                            result += varSpec.name + \"=\";\r\n                        }\r\n                    }\r\n                    result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[j]);\r\n                }\r\n            } else if (typeof value === \"object\") {\r\n                if (showVariables && !varSpec.suffices['*']) {\r\n                    result += varSpec.name + \"=\";\r\n                }\r\n                var first = true;\r\n                for (var key in value) {\r\n                    if (!first) {\r\n                        result += varSpec.suffices['*'] ? (separator || \",\") : \",\";\r\n                    }\r\n                    first = false;\r\n                    result += shouldEscape ? encodeURIComponent(key).replace(/!/g, \"%21\") : notReallyPercentEncode(key);\r\n                    result += varSpec.suffices['*'] ? '=' : \",\";\r\n                    result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[key]);\r\n                }\r\n            } else {\r\n                if (showVariables) {\r\n                    result += varSpec.name;\r\n                    if (!trimEmptyString || value !== \"\") {\r\n                        result += \"=\";\r\n                    }\r\n                }\r\n                if (varSpec.truncate != null) {\r\n                    value = value.substring(0, varSpec.truncate);\r\n                }\r\n                result += shouldEscape ? encodeURIComponent(value).replace(/!/g, \"%21\") : notReallyPercentEncode(value);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    subFunction.varNames = varNames;\r\n    return {\r\n        prefix: prefix,\r\n        substitution: subFunction\r\n    };\r\n}\r\n\r\nfunction UriTemplate(template) {\r\n    if (!(this instanceof UriTemplate)) {\r\n        return new UriTemplate(template);\r\n    }\r\n    var parts = template.split(\"{\");\r\n    var textParts = [parts.shift()];\r\n    var prefixes = [];\r\n    var substitutions = [];\r\n    var varNames = [];\r\n    while (parts.length > 0) {\r\n        var part = parts.shift();\r\n        var spec = part.split(\"}\")[0];\r\n        var remainder = part.substring(spec.length + 1);\r\n        var funcs = uriTemplateSubstitution(spec);\r\n        substitutions.push(funcs.substitution);\r\n        prefixes.push(funcs.prefix);\r\n        textParts.push(remainder);\r\n        varNames = varNames.concat(funcs.substitution.varNames);\r\n    }\r\n    this.fill = function (valueFunction) {\r\n        var result = textParts[0];\r\n        for (var i = 0; i < substitutions.length; i++) {\r\n            var substitution = substitutions[i];\r\n            result += substitution(valueFunction);\r\n            result += textParts[i + 1];\r\n        }\r\n        return result;\r\n    };\r\n    this.varNames = varNames;\r\n    this.template = template;\r\n}\r\n\r\nUriTemplate.prototype = {\r\n    toString: function () {\r\n        return this.template;\r\n    },\r\n    fillFromObject: function (obj) {\r\n        return this.fill(function (varName) {\r\n            return obj[varName];\r\n        });\r\n    }\r\n};\r\nvar ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {\r\n    this.missing = [];\r\n    this.missingMap = {};\r\n    this.formatValidators = parent ? Object.create(parent.formatValidators) : {};\r\n    this.schemas = parent ? Object.create(parent.schemas) : {};\r\n    this.collectMultiple = collectMultiple;\r\n    this.errors = [];\r\n    this.handleError = collectMultiple ? this.collectError : this.returnError;\r\n    if (checkRecursive) {\r\n        this.checkRecursive = true;\r\n        this.scanned = [];\r\n        this.scannedFrozen = [];\r\n        this.scannedFrozenSchemas = [];\r\n        this.scannedFrozenValidationErrors = [];\r\n        this.validatedSchemasKey = 'tv4_validation_id';\r\n        this.validationErrorsKey = 'tv4_validation_errors_id';\r\n    }\r\n    if (trackUnknownProperties) {\r\n        this.trackUnknownProperties = true;\r\n        this.knownPropertyPaths = {};\r\n        this.unknownPropertyPaths = {};\r\n    }\r\n    this.errorReporter = errorReporter || defaultErrorReporter('en');\r\n    if (typeof this.errorReporter === 'string') {\r\n        throw new Error('debug');\r\n    }\r\n    this.definedKeywords = {};\r\n    if (parent) {\r\n        for (var key in parent.definedKeywords) {\r\n            this.definedKeywords[key] = parent.definedKeywords[key].slice(0);\r\n        }\r\n    }\r\n};\r\nValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {\r\n    this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];\r\n    this.definedKeywords[keyword].push(keywordFunction);\r\n};\r\nValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {\r\n    var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);\r\n    error.message = this.errorReporter(error, data, schema);\r\n    return error;\r\n};\r\nValidatorContext.prototype.returnError = function (error) {\r\n    return error;\r\n};\r\nValidatorContext.prototype.collectError = function (error) {\r\n    if (error) {\r\n        this.errors.push(error);\r\n    }\r\n    return null;\r\n};\r\nValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {\r\n    for (var i = startIndex; i < this.errors.length; i++) {\r\n        this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);\r\n    }\r\n    return this;\r\n};\r\nValidatorContext.prototype.banUnknownProperties = function (data, schema) {\r\n    for (var unknownPath in this.unknownPropertyPaths) {\r\n        var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, \"\", null, data, schema);\r\n        var result = this.handleError(error);\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.addFormat = function (format, validator) {\r\n    if (typeof format === 'object') {\r\n        for (var key in format) {\r\n            this.addFormat(key, format[key]);\r\n        }\r\n        return this;\r\n    }\r\n    this.formatValidators[format] = validator;\r\n};\r\nValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {\r\n    if (schema['$ref'] !== undefined) {\r\n        urlHistory = urlHistory || {};\r\n        if (urlHistory[schema['$ref']]) {\r\n            return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);\r\n        }\r\n        urlHistory[schema['$ref']] = true;\r\n        schema = this.getSchema(schema['$ref'], urlHistory);\r\n    }\r\n    return schema;\r\n};\r\nValidatorContext.prototype.getSchema = function (url, urlHistory) {\r\n    var schema;\r\n    if (this.schemas[url] !== undefined) {\r\n        schema = this.schemas[url];\r\n        return this.resolveRefs(schema, urlHistory);\r\n    }\r\n    var baseUrl = url;\r\n    var fragment = \"\";\r\n    if (url.indexOf('#') !== -1) {\r\n        fragment = url.substring(url.indexOf(\"#\") + 1);\r\n        baseUrl = url.substring(0, url.indexOf(\"#\"));\r\n    }\r\n    if (typeof this.schemas[baseUrl] === 'object') {\r\n        schema = this.schemas[baseUrl];\r\n        var pointerPath = decodeURIComponent(fragment);\r\n        if (pointerPath === \"\") {\r\n            return this.resolveRefs(schema, urlHistory);\r\n        } else if (pointerPath.charAt(0) !== \"/\") {\r\n            return undefined;\r\n        }\r\n        var parts = pointerPath.split(\"/\").slice(1);\r\n        for (var i = 0; i < parts.length; i++) {\r\n            var component = parts[i].replace(/~1/g, \"/\").replace(/~0/g, \"~\");\r\n            if (schema[component] === undefined) {\r\n                schema = undefined;\r\n                break;\r\n            }\r\n            schema = schema[component];\r\n        }\r\n        if (schema !== undefined) {\r\n            return this.resolveRefs(schema, urlHistory);\r\n        }\r\n    }\r\n    if (this.missing[baseUrl] === undefined) {\r\n        this.missing.push(baseUrl);\r\n        this.missing[baseUrl] = baseUrl;\r\n        this.missingMap[baseUrl] = baseUrl;\r\n    }\r\n};\r\nValidatorContext.prototype.searchSchemas = function (schema, url) {\r\n    if (Array.isArray(schema)) {\r\n        for (var i = 0; i < schema.length; i++) {\r\n            this.searchSchemas(schema[i], url);\r\n        }\r\n    } else if (schema && typeof schema === \"object\") {\r\n        if (typeof schema.id === \"string\") {\r\n            if (isTrustedUrl(url, schema.id)) {\r\n                if (this.schemas[schema.id] === undefined) {\r\n                    this.schemas[schema.id] = schema;\r\n                }\r\n            }\r\n        }\r\n        for (var key in schema) {\r\n            if (key !== \"enum\") {\r\n                if (typeof schema[key] === \"object\") {\r\n                    this.searchSchemas(schema[key], url);\r\n                } else if (key === \"$ref\") {\r\n                    var uri = getDocumentUri(schema[key]);\r\n                    if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {\r\n                        this.missingMap[uri] = uri;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nValidatorContext.prototype.addSchema = function (url, schema) {\r\n    //overload\r\n    if (typeof url !== 'string' || typeof schema === 'undefined') {\r\n        if (typeof url === 'object' && typeof url.id === 'string') {\r\n            schema = url;\r\n            url = schema.id;\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    if (url === getDocumentUri(url) + \"#\") {\r\n        // Remove empty fragment\r\n        url = getDocumentUri(url);\r\n    }\r\n    this.schemas[url] = schema;\r\n    delete this.missingMap[url];\r\n    normSchema(schema, url);\r\n    this.searchSchemas(schema, url);\r\n};\r\n\r\nValidatorContext.prototype.getSchemaMap = function () {\r\n    var map = {};\r\n    for (var key in this.schemas) {\r\n        map[key] = this.schemas[key];\r\n    }\r\n    return map;\r\n};\r\n\r\nValidatorContext.prototype.getSchemaUris = function (filterRegExp) {\r\n    var list = [];\r\n    for (var key in this.schemas) {\r\n        if (!filterRegExp || filterRegExp.test(key)) {\r\n            list.push(key);\r\n        }\r\n    }\r\n    return list;\r\n};\r\n\r\nValidatorContext.prototype.getMissingUris = function (filterRegExp) {\r\n    var list = [];\r\n    for (var key in this.missingMap) {\r\n        if (!filterRegExp || filterRegExp.test(key)) {\r\n            list.push(key);\r\n        }\r\n    }\r\n    return list;\r\n};\r\n\r\nValidatorContext.prototype.dropSchemas = function () {\r\n    this.schemas = {};\r\n    this.reset();\r\n};\r\nValidatorContext.prototype.reset = function () {\r\n    this.missing = [];\r\n    this.missingMap = {};\r\n    this.errors = [];\r\n};\r\n\r\nValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {\r\n    var topLevel;\r\n    schema = this.resolveRefs(schema);\r\n    if (!schema) {\r\n        return null;\r\n    } else if (schema instanceof ValidationError) {\r\n        this.errors.push(schema);\r\n        return schema;\r\n    }\r\n\r\n    var startErrorCount = this.errors.length;\r\n    var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;\r\n    if (this.checkRecursive && data && typeof data === 'object') {\r\n        topLevel = !this.scanned.length;\r\n        if (data[this.validatedSchemasKey]) {\r\n            var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);\r\n            if (schemaIndex !== -1) {\r\n                this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);\r\n                return null;\r\n            }\r\n        }\r\n        if (Object.isFrozen(data)) {\r\n            frozenIndex = this.scannedFrozen.indexOf(data);\r\n            if (frozenIndex !== -1) {\r\n                var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);\r\n                if (frozenSchemaIndex !== -1) {\r\n                    this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        this.scanned.push(data);\r\n        if (Object.isFrozen(data)) {\r\n            if (frozenIndex === -1) {\r\n                frozenIndex = this.scannedFrozen.length;\r\n                this.scannedFrozen.push(data);\r\n                this.scannedFrozenSchemas.push([]);\r\n            }\r\n            scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;\r\n            this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;\r\n            this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];\r\n        } else {\r\n            if (!data[this.validatedSchemasKey]) {\r\n                try {\r\n                    Object.defineProperty(data, this.validatedSchemasKey, {\r\n                        value: [],\r\n                        configurable: true\r\n                    });\r\n                    Object.defineProperty(data, this.validationErrorsKey, {\r\n                        value: [],\r\n                        configurable: true\r\n                    });\r\n                } catch (e) {\r\n                    //IE 7/8 workaround\r\n                    data[this.validatedSchemasKey] = [];\r\n                    data[this.validationErrorsKey] = [];\r\n                }\r\n            }\r\n            scannedSchemasIndex = data[this.validatedSchemasKey].length;\r\n            data[this.validatedSchemasKey][scannedSchemasIndex] = schema;\r\n            data[this.validationErrorsKey][scannedSchemasIndex] = [];\r\n        }\r\n    }\r\n\r\n    var errorCount = this.errors.length;\r\n    var error = this.validateBasic(data, schema, dataPointerPath)\r\n        || this.validateNumeric(data, schema, dataPointerPath)\r\n        || this.validateString(data, schema, dataPointerPath)\r\n        || this.validateArray(data, schema, dataPointerPath)\r\n        || this.validateObject(data, schema, dataPointerPath)\r\n        || this.validateCombinations(data, schema, dataPointerPath)\r\n        || this.validateHypermedia(data, schema, dataPointerPath)\r\n        || this.validateFormat(data, schema, dataPointerPath)\r\n        || this.validateDefinedKeywords(data, schema, dataPointerPath)\r\n        || null;\r\n\r\n    if (topLevel) {\r\n        while (this.scanned.length) {\r\n            var item = this.scanned.pop();\r\n            delete item[this.validatedSchemasKey];\r\n        }\r\n        this.scannedFrozen = [];\r\n        this.scannedFrozenSchemas = [];\r\n    }\r\n\r\n    if (error || errorCount !== this.errors.length) {\r\n        while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {\r\n            var dataPart = (dataPathParts && dataPathParts.length) ? \"\" + dataPathParts.pop() : null;\r\n            var schemaPart = (schemaPathParts && schemaPathParts.length) ? \"\" + schemaPathParts.pop() : null;\r\n            if (error) {\r\n                error = error.prefixWith(dataPart, schemaPart);\r\n            }\r\n            this.prefixErrors(errorCount, dataPart, schemaPart);\r\n        }\r\n    }\r\n\r\n    if (scannedFrozenSchemaIndex !== null) {\r\n        this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);\r\n    } else if (scannedSchemasIndex !== null) {\r\n        data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);\r\n    }\r\n\r\n    return this.handleError(error);\r\n};\r\nValidatorContext.prototype.validateFormat = function (data, schema) {\r\n    if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {\r\n        return null;\r\n    }\r\n    var errorMessage = this.formatValidators[schema.format].call(null, data, schema);\r\n    if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {\r\n        return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);\r\n    } else if (errorMessage && typeof errorMessage === 'object') {\r\n        return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || \"?\"}, errorMessage.dataPath || '', errorMessage.schemaPath || \"/format\", null, data, schema);\r\n    }\r\n    return null;\r\n};\r\nValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {\r\n    for (var key in this.definedKeywords) {\r\n        if (typeof schema[key] === 'undefined') {\r\n            continue;\r\n        }\r\n        var validationFunctions = this.definedKeywords[key];\r\n        for (var i = 0; i < validationFunctions.length; i++) {\r\n            var func = validationFunctions[i];\r\n            var result = func(data, schema[key], schema, dataPointerPath);\r\n            if (typeof result === 'string' || typeof result === 'number') {\r\n                return this.createError(ErrorCodes.KEYWORD_CUSTOM, {\r\n                    key: key,\r\n                    message: result\r\n                }, '', '', null, data, schema).prefixWith(null, key);\r\n            } else if (result && typeof result === 'object') {\r\n                var code = result.code;\r\n                if (typeof code === 'string') {\r\n                    if (!ErrorCodes[code]) {\r\n                        throw new Error('Undefined error code (use defineError): ' + code);\r\n                    }\r\n                    code = ErrorCodes[code];\r\n                } else if (typeof code !== 'number') {\r\n                    code = ErrorCodes.KEYWORD_CUSTOM;\r\n                }\r\n                var messageParams = (typeof result.message === 'object') ? result.message : {\r\n                    key: key,\r\n                    message: result.message || \"?\"\r\n                };\r\n                var schemaPath = result.schemaPath || (\"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1'));\r\n                return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nfunction recursiveCompare(A, B) {\r\n    if (A === B) {\r\n        return true;\r\n    }\r\n    if (A && B && typeof A === \"object\" && typeof B === \"object\") {\r\n        if (Array.isArray(A) !== Array.isArray(B)) {\r\n            return false;\r\n        } else if (Array.isArray(A)) {\r\n            if (A.length !== B.length) {\r\n                return false;\r\n            }\r\n            for (var i = 0; i < A.length; i++) {\r\n                if (!recursiveCompare(A[i], B[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            var key;\r\n            for (key in A) {\r\n                if (B[key] === undefined && A[key] !== undefined) {\r\n                    return false;\r\n                }\r\n            }\r\n            for (key in B) {\r\n                if (A[key] === undefined && B[key] !== undefined) {\r\n                    return false;\r\n                }\r\n            }\r\n            for (key in A) {\r\n                if (!recursiveCompare(A[key], B[key])) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {\r\n    var error;\r\n    if (error = this.validateType(data, schema, dataPointerPath)) {\r\n        return error.prefixWith(null, \"type\");\r\n    }\r\n    if (error = this.validateEnum(data, schema, dataPointerPath)) {\r\n        return error.prefixWith(null, \"type\");\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateType = function validateType(data, schema) {\r\n    if (schema.type === undefined) {\r\n        return null;\r\n    }\r\n    var dataType = typeof data;\r\n    if (data === null) {\r\n        dataType = \"null\";\r\n    } else if (Array.isArray(data)) {\r\n        dataType = \"array\";\r\n    }\r\n    var allowedTypes = schema.type;\r\n    if (!Array.isArray(allowedTypes)) {\r\n        allowedTypes = [allowedTypes];\r\n    }\r\n\r\n    for (var i = 0; i < allowedTypes.length; i++) {\r\n        var type = allowedTypes[i];\r\n        if (type === dataType || (type === \"integer\" && dataType === \"number\" && (data % 1 === 0))) {\r\n            return null;\r\n        }\r\n    }\r\n    return this.createError(ErrorCodes.INVALID_TYPE, {\r\n        type: dataType,\r\n        expected: allowedTypes.join(\"/\")\r\n    }, '', '', null, data, schema);\r\n};\r\n\r\nValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {\r\n    if (schema[\"enum\"] === undefined) {\r\n        return null;\r\n    }\r\n    for (var i = 0; i < schema[\"enum\"].length; i++) {\r\n        var enumVal = schema[\"enum\"][i];\r\n        if (recursiveCompare(data, enumVal)) {\r\n            return null;\r\n        }\r\n    }\r\n    return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);\r\n};\r\n\r\nValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {\r\n    return this.validateMultipleOf(data, schema, dataPointerPath)\r\n        || this.validateMinMax(data, schema, dataPointerPath)\r\n        || this.validateNaN(data, schema, dataPointerPath)\r\n        || null;\r\n};\r\n\r\nvar CLOSE_ENOUGH_LOW = Math.pow(2, -51);\r\nvar CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;\r\nValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {\r\n    var multipleOf = schema.multipleOf || schema.divisibleBy;\r\n    if (multipleOf === undefined) {\r\n        return null;\r\n    }\r\n    if (typeof data === \"number\") {\r\n        var remainder = (data / multipleOf) % 1;\r\n        if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {\r\n            return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {\r\n                value: data,\r\n                multipleOf: multipleOf\r\n            }, '', '', null, data, schema);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {\r\n    if (typeof data !== \"number\") {\r\n        return null;\r\n    }\r\n    if (schema.minimum !== undefined) {\r\n        if (data < schema.minimum) {\r\n            return this.createError(ErrorCodes.NUMBER_MINIMUM, {\r\n                value: data,\r\n                minimum: schema.minimum\r\n            }, '', '/minimum', null, data, schema);\r\n        }\r\n        if (schema.exclusiveMinimum && data === schema.minimum) {\r\n            return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {\r\n                value: data,\r\n                minimum: schema.minimum\r\n            }, '', '/exclusiveMinimum', null, data, schema);\r\n        }\r\n    }\r\n    if (schema.maximum !== undefined) {\r\n        if (data > schema.maximum) {\r\n            return this.createError(ErrorCodes.NUMBER_MAXIMUM, {\r\n                value: data,\r\n                maximum: schema.maximum\r\n            }, '', '/maximum', null, data, schema);\r\n        }\r\n        if (schema.exclusiveMaximum && data === schema.maximum) {\r\n            return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {\r\n                value: data,\r\n                maximum: schema.maximum\r\n            }, '', '/exclusiveMaximum', null, data, schema);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {\r\n    if (typeof data !== \"number\") {\r\n        return null;\r\n    }\r\n    if (isNaN(data) === true || data === Infinity || data === -Infinity) {\r\n        return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {\r\n    return this.validateStringLength(data, schema, dataPointerPath)\r\n        || this.validateStringPattern(data, schema, dataPointerPath)\r\n        || null;\r\n};\r\n\r\nValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {\r\n    if (typeof data !== \"string\") {\r\n        return null;\r\n    }\r\n    if (schema.minLength !== undefined) {\r\n        if (data.length < schema.minLength) {\r\n            return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {\r\n                length: data.length,\r\n                minimum: schema.minLength\r\n            }, '', '/minLength', null, data, schema);\r\n        }\r\n    }\r\n    if (schema.maxLength !== undefined) {\r\n        if (data.length > schema.maxLength) {\r\n            return this.createError(ErrorCodes.STRING_LENGTH_LONG, {\r\n                length: data.length,\r\n                maximum: schema.maxLength\r\n            }, '', '/maxLength', null, data, schema);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {\r\n    if (typeof data !== \"string\" || (typeof schema.pattern !== \"string\" && !(schema.pattern instanceof RegExp))) {\r\n        return null;\r\n    }\r\n    var regexp;\r\n    if (schema.pattern instanceof RegExp) {\r\n        regexp = schema.pattern;\r\n    }\r\n    else {\r\n        var body, flags = '';\r\n        // Check for regular expression literals\r\n        // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5\r\n        var literal = schema.pattern.match(/^\\/(.+)\\/([img]*)$/);\r\n        if (literal) {\r\n            body = literal[1];\r\n            flags = literal[2];\r\n        }\r\n        else {\r\n            body = schema.pattern;\r\n        }\r\n        regexp = new RegExp(body, flags);\r\n    }\r\n    if (!regexp.test(data)) {\r\n        return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {\r\n    if (!Array.isArray(data)) {\r\n        return null;\r\n    }\r\n    return this.validateArrayLength(data, schema, dataPointerPath)\r\n        || this.validateArrayUniqueItems(data, schema, dataPointerPath)\r\n        || this.validateArrayItems(data, schema, dataPointerPath)\r\n        || null;\r\n};\r\n\r\nValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {\r\n    var error;\r\n    if (schema.minItems !== undefined) {\r\n        if (data.length < schema.minItems) {\r\n            error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {\r\n                length: data.length,\r\n                minimum: schema.minItems\r\n            }, '', '/minItems', null, data, schema);\r\n            if (this.handleError(error)) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (schema.maxItems !== undefined) {\r\n        if (data.length > schema.maxItems) {\r\n            error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {\r\n                length: data.length,\r\n                maximum: schema.maxItems\r\n            }, '', '/maxItems', null, data, schema);\r\n            if (this.handleError(error)) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {\r\n    if (schema.uniqueItems) {\r\n        for (var i = 0; i < data.length; i++) {\r\n            for (var j = i + 1; j < data.length; j++) {\r\n                if (recursiveCompare(data[i], data[j])) {\r\n                    var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {\r\n                        match1: i,\r\n                        match2: j\r\n                    }, '', '/uniqueItems', null, data, schema);\r\n                    if (this.handleError(error)) {\r\n                        return error;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {\r\n    if (schema.items === undefined) {\r\n        return null;\r\n    }\r\n    var error, i;\r\n    if (Array.isArray(schema.items)) {\r\n        for (i = 0; i < data.length; i++) {\r\n            if (i < schema.items.length) {\r\n                if (error = this.validateAll(data[i], schema.items[i], [i], [\"items\", i], dataPointerPath + \"/\" + i)) {\r\n                    return error;\r\n                }\r\n            } else if (schema.additionalItems !== undefined) {\r\n                if (typeof schema.additionalItems === \"boolean\") {\r\n                    if (!schema.additionalItems) {\r\n                        error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));\r\n                        if (this.handleError(error)) {\r\n                            return error;\r\n                        }\r\n                    }\r\n                } else if (error = this.validateAll(data[i], schema.additionalItems, [i], [\"additionalItems\"], dataPointerPath + \"/\" + i)) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (i = 0; i < data.length; i++) {\r\n            if (error = this.validateAll(data[i], schema.items, [i], [\"items\"], dataPointerPath + \"/\" + i)) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {\r\n    if (typeof data !== \"object\" || data === null || Array.isArray(data)) {\r\n        return null;\r\n    }\r\n    return this.validateObjectMinMaxProperties(data, schema, dataPointerPath)\r\n        || this.validateObjectRequiredProperties(data, schema, dataPointerPath)\r\n        || this.validateObjectProperties(data, schema, dataPointerPath)\r\n        || this.validateObjectDependencies(data, schema, dataPointerPath)\r\n        || null;\r\n};\r\n\r\nValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {\r\n    var keys = Object.keys(data);\r\n    var error;\r\n    if (schema.minProperties !== undefined) {\r\n        if (keys.length < schema.minProperties) {\r\n            error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {\r\n                propertyCount: keys.length,\r\n                minimum: schema.minProperties\r\n            }, '', '/minProperties', null, data, schema);\r\n            if (this.handleError(error)) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (schema.maxProperties !== undefined) {\r\n        if (keys.length > schema.maxProperties) {\r\n            error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {\r\n                propertyCount: keys.length,\r\n                maximum: schema.maxProperties\r\n            }, '', '/maxProperties', null, data, schema);\r\n            if (this.handleError(error)) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {\r\n    if (schema.required !== undefined) {\r\n        for (var i = 0; i < schema.required.length; i++) {\r\n            var key = schema.required[i];\r\n            if (data[key] === undefined) {\r\n                var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);\r\n                if (this.handleError(error)) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {\r\n    var error;\r\n    for (var key in data) {\r\n        var keyPointerPath = dataPointerPath + \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n        var foundMatch = false;\r\n        if (schema.properties !== undefined && schema.properties[key] !== undefined) {\r\n            foundMatch = true;\r\n            if (error = this.validateAll(data[key], schema.properties[key], [key], [\"properties\", key], keyPointerPath)) {\r\n                return error;\r\n            }\r\n        }\r\n        if (schema.patternProperties !== undefined) {\r\n            for (var patternKey in schema.patternProperties) {\r\n                var regexp = new RegExp(patternKey);\r\n                if (regexp.test(key)) {\r\n                    foundMatch = true;\r\n                    if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], [\"patternProperties\", patternKey], keyPointerPath)) {\r\n                        return error;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!foundMatch) {\r\n            if (schema.additionalProperties !== undefined) {\r\n                if (this.trackUnknownProperties) {\r\n                    this.knownPropertyPaths[keyPointerPath] = true;\r\n                    delete this.unknownPropertyPaths[keyPointerPath];\r\n                }\r\n                if (typeof schema.additionalProperties === \"boolean\") {\r\n                    if (!schema.additionalProperties) {\r\n                        error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);\r\n                        if (this.handleError(error)) {\r\n                            return error;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (error = this.validateAll(data[key], schema.additionalProperties, [key], [\"additionalProperties\"], keyPointerPath)) {\r\n                        return error;\r\n                    }\r\n                }\r\n            } else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {\r\n                this.unknownPropertyPaths[keyPointerPath] = true;\r\n            }\r\n        } else if (this.trackUnknownProperties) {\r\n            this.knownPropertyPaths[keyPointerPath] = true;\r\n            delete this.unknownPropertyPaths[keyPointerPath];\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {\r\n    var error;\r\n    if (schema.dependencies !== undefined) {\r\n        for (var depKey in schema.dependencies) {\r\n            if (data[depKey] !== undefined) {\r\n                var dep = schema.dependencies[depKey];\r\n                if (typeof dep === \"string\") {\r\n                    if (data[dep] === undefined) {\r\n                        error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {\r\n                            key: depKey,\r\n                            missing: dep\r\n                        }, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\r\n                        if (this.handleError(error)) {\r\n                            return error;\r\n                        }\r\n                    }\r\n                } else if (Array.isArray(dep)) {\r\n                    for (var i = 0; i < dep.length; i++) {\r\n                        var requiredKey = dep[i];\r\n                        if (data[requiredKey] === undefined) {\r\n                            error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {\r\n                                key: depKey,\r\n                                missing: requiredKey\r\n                            }, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\r\n                            if (this.handleError(error)) {\r\n                                return error;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (error = this.validateAll(data, dep, [], [\"dependencies\", depKey], dataPointerPath)) {\r\n                        return error;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {\r\n    return this.validateAllOf(data, schema, dataPointerPath)\r\n        || this.validateAnyOf(data, schema, dataPointerPath)\r\n        || this.validateOneOf(data, schema, dataPointerPath)\r\n        || this.validateNot(data, schema, dataPointerPath)\r\n        || null;\r\n};\r\n\r\nValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {\r\n    if (schema.allOf === undefined) {\r\n        return null;\r\n    }\r\n    var error;\r\n    for (var i = 0; i < schema.allOf.length; i++) {\r\n        var subSchema = schema.allOf[i];\r\n        if (error = this.validateAll(data, subSchema, [], [\"allOf\", i], dataPointerPath)) {\r\n            return error;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {\r\n    if (schema.anyOf === undefined) {\r\n        return null;\r\n    }\r\n    var errors = [];\r\n    var startErrorCount = this.errors.length;\r\n    var oldUnknownPropertyPaths, oldKnownPropertyPaths;\r\n    if (this.trackUnknownProperties) {\r\n        oldUnknownPropertyPaths = this.unknownPropertyPaths;\r\n        oldKnownPropertyPaths = this.knownPropertyPaths;\r\n    }\r\n    var errorAtEnd = true;\r\n    for (var i = 0; i < schema.anyOf.length; i++) {\r\n        if (this.trackUnknownProperties) {\r\n            this.unknownPropertyPaths = {};\r\n            this.knownPropertyPaths = {};\r\n        }\r\n        var subSchema = schema.anyOf[i];\r\n\r\n        var errorCount = this.errors.length;\r\n        var error = this.validateAll(data, subSchema, [], [\"anyOf\", i], dataPointerPath);\r\n\r\n        if (error === null && errorCount === this.errors.length) {\r\n            this.errors = this.errors.slice(0, startErrorCount);\r\n\r\n            if (this.trackUnknownProperties) {\r\n                for (var knownKey in this.knownPropertyPaths) {\r\n                    oldKnownPropertyPaths[knownKey] = true;\r\n                    delete oldUnknownPropertyPaths[knownKey];\r\n                }\r\n                for (var unknownKey in this.unknownPropertyPaths) {\r\n                    if (!oldKnownPropertyPaths[unknownKey]) {\r\n                        oldUnknownPropertyPaths[unknownKey] = true;\r\n                    }\r\n                }\r\n                // We need to continue looping so we catch all the property definitions, but we don't want to return an error\r\n                errorAtEnd = false;\r\n                continue;\r\n            }\r\n\r\n            return null;\r\n        }\r\n        if (error) {\r\n            errors.push(error.prefixWith(null, \"\" + i).prefixWith(null, \"anyOf\"));\r\n        }\r\n    }\r\n    if (this.trackUnknownProperties) {\r\n        this.unknownPropertyPaths = oldUnknownPropertyPaths;\r\n        this.knownPropertyPaths = oldKnownPropertyPaths;\r\n    }\r\n    if (errorAtEnd) {\r\n        errors = errors.concat(this.errors.slice(startErrorCount));\r\n        this.errors = this.errors.slice(0, startErrorCount);\r\n        return this.createError(ErrorCodes.ANY_OF_MISSING, {}, \"\", \"/anyOf\", errors, data, schema);\r\n    }\r\n};\r\n\r\nValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {\r\n    if (schema.oneOf === undefined) {\r\n        return null;\r\n    }\r\n    var validIndex = null;\r\n    var errors = [];\r\n    var startErrorCount = this.errors.length;\r\n    var oldUnknownPropertyPaths, oldKnownPropertyPaths;\r\n    if (this.trackUnknownProperties) {\r\n        oldUnknownPropertyPaths = this.unknownPropertyPaths;\r\n        oldKnownPropertyPaths = this.knownPropertyPaths;\r\n    }\r\n    for (var i = 0; i < schema.oneOf.length; i++) {\r\n        if (this.trackUnknownProperties) {\r\n            this.unknownPropertyPaths = {};\r\n            this.knownPropertyPaths = {};\r\n        }\r\n        var subSchema = schema.oneOf[i];\r\n\r\n        var errorCount = this.errors.length;\r\n        var error = this.validateAll(data, subSchema, [], [\"oneOf\", i], dataPointerPath);\r\n\r\n        if (error === null && errorCount === this.errors.length) {\r\n            if (validIndex === null) {\r\n                validIndex = i;\r\n            } else {\r\n                this.errors = this.errors.slice(0, startErrorCount);\r\n                return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {\r\n                    index1: validIndex,\r\n                    index2: i\r\n                }, \"\", \"/oneOf\", null, data, schema);\r\n            }\r\n            if (this.trackUnknownProperties) {\r\n                for (var knownKey in this.knownPropertyPaths) {\r\n                    oldKnownPropertyPaths[knownKey] = true;\r\n                    delete oldUnknownPropertyPaths[knownKey];\r\n                }\r\n                for (var unknownKey in this.unknownPropertyPaths) {\r\n                    if (!oldKnownPropertyPaths[unknownKey]) {\r\n                        oldUnknownPropertyPaths[unknownKey] = true;\r\n                    }\r\n                }\r\n            }\r\n        } else if (error) {\r\n            errors.push(error);\r\n        }\r\n    }\r\n    if (this.trackUnknownProperties) {\r\n        this.unknownPropertyPaths = oldUnknownPropertyPaths;\r\n        this.knownPropertyPaths = oldKnownPropertyPaths;\r\n    }\r\n    if (validIndex === null) {\r\n        errors = errors.concat(this.errors.slice(startErrorCount));\r\n        this.errors = this.errors.slice(0, startErrorCount);\r\n        return this.createError(ErrorCodes.ONE_OF_MISSING, {}, \"\", \"/oneOf\", errors, data, schema);\r\n    } else {\r\n        this.errors = this.errors.slice(0, startErrorCount);\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {\r\n    if (schema.not === undefined) {\r\n        return null;\r\n    }\r\n    var oldErrorCount = this.errors.length;\r\n    var oldUnknownPropertyPaths, oldKnownPropertyPaths;\r\n    if (this.trackUnknownProperties) {\r\n        oldUnknownPropertyPaths = this.unknownPropertyPaths;\r\n        oldKnownPropertyPaths = this.knownPropertyPaths;\r\n        this.unknownPropertyPaths = {};\r\n        this.knownPropertyPaths = {};\r\n    }\r\n    var error = this.validateAll(data, schema.not, null, null, dataPointerPath);\r\n    var notErrors = this.errors.slice(oldErrorCount);\r\n    this.errors = this.errors.slice(0, oldErrorCount);\r\n    if (this.trackUnknownProperties) {\r\n        this.unknownPropertyPaths = oldUnknownPropertyPaths;\r\n        this.knownPropertyPaths = oldKnownPropertyPaths;\r\n    }\r\n    if (error === null && notErrors.length === 0) {\r\n        return this.createError(ErrorCodes.NOT_PASSED, {}, \"\", \"/not\", null, data, schema);\r\n    }\r\n    return null;\r\n};\r\n\r\nValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {\r\n    if (!schema.links) {\r\n        return null;\r\n    }\r\n    var error;\r\n    for (var i = 0; i < schema.links.length; i++) {\r\n        var ldo = schema.links[i];\r\n        if (ldo.rel === \"describedby\") {\r\n            var template = new UriTemplate(ldo.href);\r\n            var allPresent = true;\r\n            for (var j = 0; j < template.varNames.length; j++) {\r\n                if (!(template.varNames[j] in data)) {\r\n                    allPresent = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (allPresent) {\r\n                var schemaUrl = template.fillFromObject(data);\r\n                var subSchema = {\"$ref\": schemaUrl};\r\n                if (error = this.validateAll(data, subSchema, [], [\"links\", i], dataPointerPath)) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n// parseURI() and resolveUrl() are from https://gist.github.com/1088850\r\n//   -  released as public domain by author (\"Yaffle\") - see comments on gist\r\n\r\nfunction parseURI(url) {\r\n    var m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\r\n    // authority = '//' + user + ':' + pass '@' + hostname + ':' port\r\n    return (m ? {\r\n        href: m[0] || '',\r\n        protocol: m[1] || '',\r\n        authority: m[2] || '',\r\n        host: m[3] || '',\r\n        hostname: m[4] || '',\r\n        port: m[5] || '',\r\n        pathname: m[6] || '',\r\n        search: m[7] || '',\r\n        hash: m[8] || ''\r\n    } : null);\r\n}\r\n\r\nfunction resolveUrl(base, href) {// RFC 3986\r\n\r\n    function removeDotSegments(input) {\r\n        var output = [];\r\n        input.replace(/^(\\.\\.?(\\/|$))+/, '')\r\n            .replace(/\\/(\\.(\\/|$))+/g, '/')\r\n            .replace(/\\/\\.\\.$/, '/../')\r\n            .replace(/\\/?[^\\/]*/g, function (p) {\r\n                if (p === '/..') {\r\n                    output.pop();\r\n                } else {\r\n                    output.push(p);\r\n                }\r\n            });\r\n        return output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\r\n    }\r\n\r\n    href = parseURI(href || '');\r\n    base = parseURI(base || '');\r\n\r\n    return !href || !base ? null : (href.protocol || base.protocol) +\r\n    (href.protocol || href.authority ? href.authority : base.authority) +\r\n    removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +\r\n    (href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +\r\n    href.hash;\r\n}\r\n\r\nfunction getDocumentUri(uri) {\r\n    return uri.split('#')[0];\r\n}\r\n\r\nfunction normSchema(schema, baseUri) {\r\n    if (schema && typeof schema === \"object\") {\r\n        if (baseUri === undefined) {\r\n            baseUri = schema.id;\r\n        } else if (typeof schema.id === \"string\") {\r\n            baseUri = resolveUrl(baseUri, schema.id);\r\n            schema.id = baseUri;\r\n        }\r\n        if (Array.isArray(schema)) {\r\n            for (var i = 0; i < schema.length; i++) {\r\n                normSchema(schema[i], baseUri);\r\n            }\r\n        } else {\r\n            if (typeof schema['$ref'] === \"string\") {\r\n                schema['$ref'] = resolveUrl(baseUri, schema['$ref']);\r\n            }\r\n            for (var key in schema) {\r\n                if (key !== \"enum\") {\r\n                    normSchema(schema[key], baseUri);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction defaultErrorReporter(language) {\r\n    language = language || 'en';\r\n\r\n    var errorMessages = languages[language];\r\n\r\n    return function (error) {\r\n        var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];\r\n        if (typeof messageTemplate !== 'string') {\r\n            return \"Unknown error code \" + error.code + \": \" + JSON.stringify(error.messageParams);\r\n        }\r\n        var messageParams = error.params;\r\n        // Adapted from Crockford's supplant()\r\n        return messageTemplate.replace(/\\{([^{}]*)\\}/g, function (whole, varName) {\r\n            var subValue = messageParams[varName];\r\n            return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;\r\n        });\r\n    };\r\n}\r\n\r\nvar ErrorCodes = {\r\n    INVALID_TYPE: 0,\r\n    ENUM_MISMATCH: 1,\r\n    ANY_OF_MISSING: 10,\r\n    ONE_OF_MISSING: 11,\r\n    ONE_OF_MULTIPLE: 12,\r\n    NOT_PASSED: 13,\r\n    // Numeric errors\r\n    NUMBER_MULTIPLE_OF: 100,\r\n    NUMBER_MINIMUM: 101,\r\n    NUMBER_MINIMUM_EXCLUSIVE: 102,\r\n    NUMBER_MAXIMUM: 103,\r\n    NUMBER_MAXIMUM_EXCLUSIVE: 104,\r\n    NUMBER_NOT_A_NUMBER: 105,\r\n    // String errors\r\n    STRING_LENGTH_SHORT: 200,\r\n    STRING_LENGTH_LONG: 201,\r\n    STRING_PATTERN: 202,\r\n    // Object errors\r\n    OBJECT_PROPERTIES_MINIMUM: 300,\r\n    OBJECT_PROPERTIES_MAXIMUM: 301,\r\n    OBJECT_REQUIRED: 302,\r\n    OBJECT_ADDITIONAL_PROPERTIES: 303,\r\n    OBJECT_DEPENDENCY_KEY: 304,\r\n    // Array errors\r\n    ARRAY_LENGTH_SHORT: 400,\r\n    ARRAY_LENGTH_LONG: 401,\r\n    ARRAY_UNIQUE: 402,\r\n    ARRAY_ADDITIONAL_ITEMS: 403,\r\n    // Custom/user-defined errors\r\n    FORMAT_CUSTOM: 500,\r\n    KEYWORD_CUSTOM: 501,\r\n    // Schema structure\r\n    CIRCULAR_REFERENCE: 600,\r\n    // Non-standard validation options\r\n    UNKNOWN_PROPERTY: 1000\r\n};\r\nvar ErrorCodeLookup = {};\r\nfor (var key in ErrorCodes) {\r\n    ErrorCodeLookup[ErrorCodes[key]] = key;\r\n}\r\nvar ErrorMessagesDefault = {\r\n    INVALID_TYPE: \"Invalid type: {type} (expected {expected})\",\r\n    ENUM_MISMATCH: \"No enum match for: {value}\",\r\n    ANY_OF_MISSING: \"Data does not match any schemas from \\\"anyOf\\\"\",\r\n    ONE_OF_MISSING: \"Data does not match any schemas from \\\"oneOf\\\"\",\r\n    ONE_OF_MULTIPLE: \"Data is valid against more than one schema from \\\"oneOf\\\": indices {index1} and {index2}\",\r\n    NOT_PASSED: \"Data matches schema from \\\"not\\\"\",\r\n    // Numeric errors\r\n    NUMBER_MULTIPLE_OF: \"Value {value} is not a multiple of {multipleOf}\",\r\n    NUMBER_MINIMUM: \"Value {value} is less than minimum {minimum}\",\r\n    NUMBER_MINIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive minimum {minimum}\",\r\n    NUMBER_MAXIMUM: \"Value {value} is greater than maximum {maximum}\",\r\n    NUMBER_MAXIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive maximum {maximum}\",\r\n    NUMBER_NOT_A_NUMBER: \"Value {value} is not a valid number\",\r\n    // String errors\r\n    STRING_LENGTH_SHORT: \"String is too short ({length} chars), minimum {minimum}\",\r\n    STRING_LENGTH_LONG: \"String is too long ({length} chars), maximum {maximum}\",\r\n    STRING_PATTERN: \"String does not match pattern: {pattern}\",\r\n    // Object errors\r\n    OBJECT_PROPERTIES_MINIMUM: \"Too few properties defined ({propertyCount}), minimum {minimum}\",\r\n    OBJECT_PROPERTIES_MAXIMUM: \"Too many properties defined ({propertyCount}), maximum {maximum}\",\r\n    OBJECT_REQUIRED: \"Missing required property: {key}\",\r\n    OBJECT_ADDITIONAL_PROPERTIES: \"Additional properties not allowed\",\r\n    OBJECT_DEPENDENCY_KEY: \"Dependency failed - key must exist: {missing} (due to key: {key})\",\r\n    // Array errors\r\n    ARRAY_LENGTH_SHORT: \"Array is too short ({length}), minimum {minimum}\",\r\n    ARRAY_LENGTH_LONG: \"Array is too long ({length}), maximum {maximum}\",\r\n    ARRAY_UNIQUE: \"Array items are not unique (indices {match1} and {match2})\",\r\n    ARRAY_ADDITIONAL_ITEMS: \"Additional items not allowed\",\r\n    // Format errors\r\n    FORMAT_CUSTOM: \"Format validation failed ({message})\",\r\n    KEYWORD_CUSTOM: \"Keyword failed: {key} ({message})\",\r\n    // Schema structure\r\n    CIRCULAR_REFERENCE: \"Circular $refs: {urls}\",\r\n    // Non-standard validation options\r\n    UNKNOWN_PROPERTY: \"Unknown property (not in schema)\"\r\n};\r\n\r\nfunction ValidationError(code, params, dataPath, schemaPath, subErrors) {\r\n    Error.call(this);\r\n    if (code === undefined) {\r\n        throw new Error(\"No error code supplied: \" + schemaPath);\r\n    }\r\n    this.message = '';\r\n    this.params = params;\r\n    this.code = code;\r\n    this.dataPath = dataPath || \"\";\r\n    this.schemaPath = schemaPath || \"\";\r\n    this.subErrors = subErrors || null;\r\n\r\n    var err = new Error(this.message);\r\n    this.stack = err.stack || err.stacktrace;\r\n    if (!this.stack) {\r\n        try {\r\n            throw err;\r\n        }\r\n        catch (err) {\r\n            this.stack = err.stack || err.stacktrace;\r\n        }\r\n    }\r\n}\r\n\r\nValidationError.prototype = Object.create(Error.prototype);\r\nValidationError.prototype.constructor = ValidationError;\r\nValidationError.prototype.name = 'ValidationError';\r\n\r\nValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {\r\n    if (dataPrefix !== null) {\r\n        dataPrefix = dataPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\r\n        this.dataPath = \"/\" + dataPrefix + this.dataPath;\r\n    }\r\n    if (schemaPrefix !== null) {\r\n        schemaPrefix = schemaPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\r\n        this.schemaPath = \"/\" + schemaPrefix + this.schemaPath;\r\n    }\r\n    if (this.subErrors !== null) {\r\n        for (var i = 0; i < this.subErrors.length; i++) {\r\n            this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\nfunction isTrustedUrl(baseUrl, testUrl) {\r\n    if (testUrl.substring(0, baseUrl.length) === baseUrl) {\r\n        var remainder = testUrl.substring(baseUrl.length);\r\n        if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === \"/\")\r\n            || remainder.charAt(0) === \"#\"\r\n            || remainder.charAt(0) === \"?\") {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvar languages = {};\r\n\r\nfunction createApi(language) {\r\n    var globalContext = new ValidatorContext();\r\n    var currentLanguage;\r\n    var customErrorReporter;\r\n    var api = {\r\n        setErrorReporter: function (reporter) {\r\n            if (typeof reporter === 'string') {\r\n                return this.language(reporter);\r\n            }\r\n            customErrorReporter = reporter;\r\n            return true;\r\n        },\r\n        addFormat: function () {\r\n            globalContext.addFormat.apply(globalContext, arguments);\r\n        },\r\n        language: function (code) {\r\n            if (!code) {\r\n                return currentLanguage;\r\n            }\r\n            if (!languages[code]) {\r\n                code = code.split('-')[0]; // fall back to base language\r\n            }\r\n            if (languages[code]) {\r\n                currentLanguage = code;\r\n                return code; // so you can tell if fall-back has happened\r\n            }\r\n            return false;\r\n        },\r\n        addLanguage: function (code, messageMap) {\r\n            var key;\r\n            for (key in ErrorCodes) {\r\n                if (messageMap[key] && !messageMap[ErrorCodes[key]]) {\r\n                    messageMap[ErrorCodes[key]] = messageMap[key];\r\n                }\r\n            }\r\n            var rootCode = code.split('-')[0];\r\n            if (!languages[rootCode]) { // use for base language if not yet defined\r\n                languages[code] = messageMap;\r\n                languages[rootCode] = messageMap;\r\n            } else {\r\n                languages[code] = Object.create(languages[rootCode]);\r\n                for (key in messageMap) {\r\n                    if (typeof languages[rootCode][key] === 'undefined') {\r\n                        languages[rootCode][key] = messageMap[key];\r\n                    }\r\n                    languages[code][key] = messageMap[key];\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        freshApi: function (language) {\r\n            var result = createApi();\r\n            if (language) {\r\n                result.language(language);\r\n            }\r\n            return result;\r\n        },\r\n        validate: function (data, schema, checkRecursive, banUnknownProperties) {\r\n            var def = defaultErrorReporter(currentLanguage);\r\n            var errorReporter = customErrorReporter ? function (error, data, schema) {\r\n                return customErrorReporter(error, data, schema) || def(error, data, schema);\r\n            } : def;\r\n            var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);\r\n            if (typeof schema === \"string\") {\r\n                schema = {\"$ref\": schema};\r\n            }\r\n            context.addSchema(\"\", schema);\r\n            var error = context.validateAll(data, schema, null, null, \"\");\r\n            if (!error && banUnknownProperties) {\r\n                error = context.banUnknownProperties(data, schema);\r\n            }\r\n            this.error = error;\r\n            this.missing = context.missing;\r\n            this.valid = (error === null);\r\n            return this.valid;\r\n        },\r\n        validateResult: function () {\r\n            var result = {};\r\n            this.validate.apply(result, arguments);\r\n            return result;\r\n        },\r\n        validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {\r\n            var def = defaultErrorReporter(currentLanguage);\r\n            var errorReporter = customErrorReporter ? function (error, data, schema) {\r\n                return customErrorReporter(error, data, schema) || def(error, data, schema);\r\n            } : def;\r\n            var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);\r\n            if (typeof schema === \"string\") {\r\n                schema = {\"$ref\": schema};\r\n            }\r\n            context.addSchema(\"\", schema);\r\n            context.validateAll(data, schema, null, null, \"\");\r\n            if (banUnknownProperties) {\r\n                context.banUnknownProperties(data, schema);\r\n            }\r\n            var result = {};\r\n            result.errors = context.errors;\r\n            result.missing = context.missing;\r\n            result.valid = (result.errors.length === 0);\r\n            return result;\r\n        },\r\n        addSchema: function () {\r\n            return globalContext.addSchema.apply(globalContext, arguments);\r\n        },\r\n        getSchema: function () {\r\n            return globalContext.getSchema.apply(globalContext, arguments);\r\n        },\r\n        getSchemaMap: function () {\r\n            return globalContext.getSchemaMap.apply(globalContext, arguments);\r\n        },\r\n        getSchemaUris: function () {\r\n            return globalContext.getSchemaUris.apply(globalContext, arguments);\r\n        },\r\n        getMissingUris: function () {\r\n            return globalContext.getMissingUris.apply(globalContext, arguments);\r\n        },\r\n        dropSchemas: function () {\r\n            globalContext.dropSchemas.apply(globalContext, arguments);\r\n        },\r\n        defineKeyword: function () {\r\n            globalContext.defineKeyword.apply(globalContext, arguments);\r\n        },\r\n        defineError: function (codeName, codeNumber, defaultMessage) {\r\n            if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {\r\n                throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');\r\n            }\r\n            if (typeof codeNumber !== 'number' || codeNumber % 1 !== 0 || codeNumber < 10000) {\r\n                throw new Error('Code number must be an integer > 10000');\r\n            }\r\n            if (typeof ErrorCodes[codeName] !== 'undefined') {\r\n                throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);\r\n            }\r\n            if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {\r\n                throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);\r\n            }\r\n            ErrorCodes[codeName] = codeNumber;\r\n            ErrorCodeLookup[codeNumber] = codeName;\r\n            ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;\r\n            for (var langCode in languages) {\r\n                var language = languages[langCode];\r\n                if (language[codeName]) {\r\n                    language[codeNumber] = language[codeNumber] || language[codeName];\r\n                }\r\n            }\r\n        },\r\n        reset: function () {\r\n            globalContext.reset();\r\n            this.error = null;\r\n            this.missing = [];\r\n            this.valid = true;\r\n        },\r\n        missing: [],\r\n        error: null,\r\n        valid: true,\r\n        normSchema: normSchema,\r\n        resolveUrl: resolveUrl,\r\n        getDocumentUri: getDocumentUri,\r\n        errorCodes: ErrorCodes\r\n    };\r\n    api.language(language || 'en');\r\n    return api;\r\n}\r\n\r\n//export function validator() {\r\nvar tv4 = createApi();\r\ntv4.addLanguage('en-gb', ErrorMessagesDefault);\r\n\r\n//legacy property\r\ntv4.tv4 = tv4;\r\n//return tv4;\r\nexport default tv4;\r\n//}",
    "static": true,
    "longname": "src/utils/tv4.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 702,
    "kind": "variable",
    "name": "uriTemplateGlobalModifiers",
    "memberof": "src/utils/tv4.js",
    "static": true,
    "longname": "src/utils/tv4.js~uriTemplateGlobalModifiers",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"+\": boolean, \"#\": boolean, \".\": boolean, \"/\": boolean, \";\": boolean, \"?\": boolean, \"&\": boolean}"
      ]
    }
  },
  {
    "__docId__": 703,
    "kind": "variable",
    "name": "uriTemplateSuffices",
    "memberof": "src/utils/tv4.js",
    "static": true,
    "longname": "src/utils/tv4.js~uriTemplateSuffices",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"*\": boolean}"
      ]
    }
  },
  {
    "__docId__": 704,
    "kind": "function",
    "name": "notReallyPercentEncode",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~notReallyPercentEncode",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 705,
    "kind": "function",
    "name": "uriTemplateSubstitution",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~uriTemplateSubstitution",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "spec",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"prefix\": *, \"substitution\": *}"
      ]
    }
  },
  {
    "__docId__": 706,
    "kind": "function",
    "name": "UriTemplate",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~UriTemplate",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 268,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "template",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 707,
    "kind": "function",
    "name": "ValidatorContext",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~ValidatorContext",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 310,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "parent",
        "types": [
          "*"
        ]
      },
      {
        "name": "collectMultiple",
        "types": [
          "*"
        ]
      },
      {
        "name": "errorReporter",
        "types": [
          "*"
        ]
      },
      {
        "name": "checkRecursive",
        "types": [
          "*"
        ]
      },
      {
        "name": "trackUnknownProperties",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 708,
    "kind": "function",
    "name": "defineKeyword",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~defineKeyword",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 343,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "keyword",
        "types": [
          "*"
        ]
      },
      {
        "name": "keywordFunction",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 709,
    "kind": "function",
    "name": "createError",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~createError",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 347,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "code",
        "types": [
          "*"
        ]
      },
      {
        "name": "messageParams",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPath",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaPath",
        "types": [
          "*"
        ]
      },
      {
        "name": "subErrors",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 710,
    "kind": "function",
    "name": "returnError",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~returnError",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 352,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 711,
    "kind": "function",
    "name": "collectError",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~collectError",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 355,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 712,
    "kind": "function",
    "name": "prefixErrors",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~prefixErrors",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 361,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "startIndex",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPath",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 713,
    "kind": "function",
    "name": "banUnknownProperties",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~banUnknownProperties",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 367,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 714,
    "kind": "function",
    "name": "addFormat",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~addFormat",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 378,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "format",
        "types": [
          "*"
        ]
      },
      {
        "name": "validator",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 715,
    "kind": "function",
    "name": "resolveRefs",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~resolveRefs",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 387,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "urlHistory",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 716,
    "kind": "function",
    "name": "getSchema",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~getSchema",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 398,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "urlHistory",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 717,
    "kind": "function",
    "name": "searchSchemas",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~searchSchemas",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 437,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 718,
    "kind": "function",
    "name": "addSchema",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~addSchema",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 464,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 719,
    "kind": "function",
    "name": "getSchemaMap",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~getSchemaMap",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 485,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 720,
    "kind": "function",
    "name": "getSchemaUris",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~getSchemaUris",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 493,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "filterRegExp",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 721,
    "kind": "function",
    "name": "getMissingUris",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~getMissingUris",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 503,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "filterRegExp",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 722,
    "kind": "function",
    "name": "dropSchemas",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~dropSchemas",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 513,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 723,
    "kind": "function",
    "name": "reset",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~reset",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 517,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 724,
    "kind": "function",
    "name": "validateAll",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateAll",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 523,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPathParts",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaPathParts",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 725,
    "kind": "function",
    "name": "validateFormat",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateFormat",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 627,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 726,
    "kind": "function",
    "name": "validateDefinedKeywords",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateDefinedKeywords",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 639,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 727,
    "kind": "function",
    "name": "recursiveCompare",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~recursiveCompare",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 675,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "A",
        "types": [
          "*"
        ]
      },
      {
        "name": "B",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 728,
    "kind": "function",
    "name": "validateBasic",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateBasic",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 714,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 729,
    "kind": "function",
    "name": "validateType",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateType",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 725,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 730,
    "kind": "function",
    "name": "validateEnum",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateEnum",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 752,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 731,
    "kind": "function",
    "name": "validateNumeric",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateNumeric",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 765,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 732,
    "kind": "variable",
    "name": "CLOSE_ENOUGH_LOW",
    "memberof": "src/utils/tv4.js",
    "static": true,
    "longname": "src/utils/tv4.js~CLOSE_ENOUGH_LOW",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 772,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 733,
    "kind": "variable",
    "name": "CLOSE_ENOUGH_HIGH",
    "memberof": "src/utils/tv4.js",
    "static": true,
    "longname": "src/utils/tv4.js~CLOSE_ENOUGH_HIGH",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 773,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 734,
    "kind": "function",
    "name": "validateMultipleOf",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateMultipleOf",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 774,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 735,
    "kind": "function",
    "name": "validateMinMax",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateMinMax",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 791,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 736,
    "kind": "function",
    "name": "validateNaN",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateNaN",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 826,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 737,
    "kind": "function",
    "name": "validateString",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateString",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 836,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 738,
    "kind": "function",
    "name": "validateStringLength",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateStringLength",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 842,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 739,
    "kind": "function",
    "name": "validateStringPattern",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateStringPattern",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 865,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 740,
    "kind": "function",
    "name": "validateArray",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateArray",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 893,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 741,
    "kind": "function",
    "name": "validateArrayLength",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateArrayLength",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 903,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 742,
    "kind": "function",
    "name": "validateArrayUniqueItems",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateArrayUniqueItems",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 930,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 743,
    "kind": "function",
    "name": "validateArrayItems",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateArrayItems",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 949,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 744,
    "kind": "function",
    "name": "validateObject",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateObject",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 983,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 745,
    "kind": "function",
    "name": "validateObjectMinMaxProperties",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateObjectMinMaxProperties",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 994,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 746,
    "kind": "function",
    "name": "validateObjectRequiredProperties",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateObjectRequiredProperties",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1022,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 747,
    "kind": "function",
    "name": "validateObjectProperties",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateObjectProperties",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1037,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 748,
    "kind": "function",
    "name": "validateObjectDependencies",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateObjectDependencies",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1088,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 749,
    "kind": "function",
    "name": "validateCombinations",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateCombinations",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1128,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 750,
    "kind": "function",
    "name": "validateAllOf",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateAllOf",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1136,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 751,
    "kind": "function",
    "name": "validateAnyOf",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateAnyOf",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1150,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 752,
    "kind": "function",
    "name": "validateOneOf",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateOneOf",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1207,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 753,
    "kind": "function",
    "name": "validateNot",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateNot",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1268,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 754,
    "kind": "function",
    "name": "validateHypermedia",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~validateHypermedia",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1293,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPointerPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 755,
    "kind": "function",
    "name": "parseURI",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~parseURI",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1323,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 756,
    "kind": "function",
    "name": "resolveUrl",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~resolveUrl",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1339,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "base",
        "types": [
          "*"
        ]
      },
      {
        "name": "href",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 757,
    "kind": "function",
    "name": "getDocumentUri",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~getDocumentUri",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1366,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "uri",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 758,
    "kind": "function",
    "name": "normSchema",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~normSchema",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1370,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      },
      {
        "name": "baseUri",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 759,
    "kind": "function",
    "name": "defaultErrorReporter",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~defaultErrorReporter",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1395,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "language",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 760,
    "kind": "variable",
    "name": "ErrorCodes",
    "memberof": "src/utils/tv4.js",
    "static": true,
    "longname": "src/utils/tv4.js~ErrorCodes",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1414,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"INVALID_TYPE\": *, \"ENUM_MISMATCH\": number, \"ANY_OF_MISSING\": number, \"ONE_OF_MISSING\": number, \"ONE_OF_MULTIPLE\": number, \"NOT_PASSED\": number, \"NUMBER_MULTIPLE_OF\": number, \"NUMBER_MINIMUM\": number, \"NUMBER_MINIMUM_EXCLUSIVE\": number, \"NUMBER_MAXIMUM\": number, \"NUMBER_MAXIMUM_EXCLUSIVE\": number, \"NUMBER_NOT_A_NUMBER\": number, \"STRING_LENGTH_SHORT\": number, \"STRING_LENGTH_LONG\": number, \"STRING_PATTERN\": number, \"OBJECT_PROPERTIES_MINIMUM\": number, \"OBJECT_PROPERTIES_MAXIMUM\": number, \"OBJECT_REQUIRED\": number, \"OBJECT_ADDITIONAL_PROPERTIES\": number, \"OBJECT_DEPENDENCY_KEY\": number, \"ARRAY_LENGTH_SHORT\": number, \"ARRAY_LENGTH_LONG\": number, \"ARRAY_UNIQUE\": number, \"ARRAY_ADDITIONAL_ITEMS\": number, \"FORMAT_CUSTOM\": number, \"KEYWORD_CUSTOM\": number, \"CIRCULAR_REFERENCE\": number, \"UNKNOWN_PROPERTY\": number}"
      ]
    }
  },
  {
    "__docId__": 761,
    "kind": "variable",
    "name": "ErrorCodeLookup",
    "memberof": "src/utils/tv4.js",
    "static": true,
    "longname": "src/utils/tv4.js~ErrorCodeLookup",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1451,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 762,
    "kind": "variable",
    "name": "ErrorMessagesDefault",
    "memberof": "src/utils/tv4.js",
    "static": true,
    "longname": "src/utils/tv4.js~ErrorMessagesDefault",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1455,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"INVALID_TYPE\": string, \"ENUM_MISMATCH\": string, \"ANY_OF_MISSING\": string, \"ONE_OF_MISSING\": string, \"ONE_OF_MULTIPLE\": string, \"NOT_PASSED\": string, \"NUMBER_MULTIPLE_OF\": string, \"NUMBER_MINIMUM\": string, \"NUMBER_MINIMUM_EXCLUSIVE\": string, \"NUMBER_MAXIMUM\": string, \"NUMBER_MAXIMUM_EXCLUSIVE\": string, \"NUMBER_NOT_A_NUMBER\": string, \"STRING_LENGTH_SHORT\": string, \"STRING_LENGTH_LONG\": string, \"STRING_PATTERN\": string, \"OBJECT_PROPERTIES_MINIMUM\": string, \"OBJECT_PROPERTIES_MAXIMUM\": string, \"OBJECT_REQUIRED\": string, \"OBJECT_ADDITIONAL_PROPERTIES\": string, \"OBJECT_DEPENDENCY_KEY\": string, \"ARRAY_LENGTH_SHORT\": string, \"ARRAY_LENGTH_LONG\": string, \"ARRAY_UNIQUE\": string, \"ARRAY_ADDITIONAL_ITEMS\": string, \"FORMAT_CUSTOM\": string, \"KEYWORD_CUSTOM\": string, \"CIRCULAR_REFERENCE\": string, \"UNKNOWN_PROPERTY\": string}"
      ]
    }
  },
  {
    "__docId__": 763,
    "kind": "function",
    "name": "ValidationError",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~ValidationError",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1493,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "code",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataPath",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaPath",
        "types": [
          "*"
        ]
      },
      {
        "name": "subErrors",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 764,
    "kind": "function",
    "name": "prefixWith",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~prefixWith",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1521,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "dataPrefix",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaPrefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 765,
    "kind": "function",
    "name": "isTrustedUrl",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~isTrustedUrl",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1538,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "baseUrl",
        "types": [
          "*"
        ]
      },
      {
        "name": "testUrl",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 766,
    "kind": "variable",
    "name": "languages",
    "memberof": "src/utils/tv4.js",
    "static": true,
    "longname": "src/utils/tv4.js~languages",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1550,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 767,
    "kind": "function",
    "name": "createApi",
    "memberof": "src/utils/tv4.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/tv4.js~createApi",
    "access": null,
    "export": false,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1552,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "language",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 768,
    "kind": "variable",
    "name": "tv4",
    "memberof": "src/utils/tv4.js",
    "static": true,
    "longname": "src/utils/tv4.js~tv4",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/tv4.js",
    "importStyle": "tv4",
    "description": null,
    "lineNumber": 1716,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 769,
    "kind": "file",
    "name": "src/utils/utils.js",
    "content": "/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n/**\r\n * Support module with some functions will be useful\r\n * @module utils\r\n */\r\n\r\n/**\r\n * @typedef divideURL\r\n * @type Object\r\n * @property {string} type The type of URL\r\n * @property {string} domain The domain of URL\r\n * @property {string} identity The identity of URL\r\n */\r\n\r\n/**\r\n * Divide an url in type, domain and identity\r\n * @param  {URL.URL} url - url address\r\n * @return {divideURL} the result of divideURL\r\n */\r\nexport function divideURL(url) {\r\n\r\n  function recurse(value) {\r\n    const regex = /([a-zA-Z-]*)(:\\/\\/(?:\\.)?|:)([-a-zA-Z0-9@:%._\\+~#=]{2,256})([-a-zA-Z0-9@:%._\\+~#=\\/]*)/gi;\r\n    const subst = '$1,$3,$4';\r\n    let parts = value.replace(regex, subst).split(',');\r\n    return parts;\r\n  }\r\n\r\n  let parts = recurse(url);\r\n\r\n  // If the url has no scheme\r\n  if (parts[0] === url && !parts[0].includes('@')) {\r\n\r\n    let result = {\r\n      type: '',\r\n      domain: url,\r\n      identity: ''\r\n    };\r\n\r\n    console.warn('[DivideURL] DivideURL don\\'t support url without scheme. Please review your url address', url);\r\n\r\n    return result;\r\n  }\r\n\r\n\t// check if the url has the scheme and includes an @\r\n  if (parts[0] === url && parts[0].includes('@')) {\r\n    let scheme = parts[0] === url ? 'smtp' : parts[0];\r\n    parts = recurse(scheme + '://' + parts[0]);\r\n  }\r\n\r\n\t// if the domain includes an @, divide it to domain and identity respectively\r\n  if (parts[1].includes('@')) {\r\n    parts[2] = parts[0] + '://' + parts[1];\r\n    parts[1] = parts[1].substr(parts[1].indexOf('@') + 1);\r\n  } \t/*else if (parts[2].includes('/')) {\r\n    parts[2] = parts[2].substr(parts[2].lastIndexOf('/')+1);\r\n  }*/\r\n\r\n  let result = {\r\n    type: parts[0],\r\n    domain: parts[1],\r\n    identity: parts[2]\r\n  };\r\n\r\n  return result;\r\n\r\n}\r\n\r\n/**\r\n * Check if an Object is empty\r\n * @param  {Object} object Object to be checked\r\n * @return {Boolean}       status of Object, empty or not (true|false);\r\n */\r\nexport function emptyObject(object) {\r\n  return Object.keys(object).length > 0 ? false : true;\r\n}\r\n\r\n/**\r\n * Make a COPY of the original data\r\n * @param  {Object}  obj - object to be cloned\r\n * @return {Object}\r\n */\r\nexport function deepClone(obj) {\r\n  //TODO: simple but inefficient JSON deep clone...\r\n  if (obj) return JSON.parse(JSON.stringify(obj));\r\n}\r\n\r\nexport function removePathFromURL(url) {\r\n  let splitURL = url.split('/');\r\n  return splitURL[0] + '//' + splitURL[2] + '/' + splitURL[3];\r\n}\r\n\r\n/**\r\n * Obtains the user URL that corresponds to a given email\r\n * @param  {string} userEmail The user email\r\n * @return {URL.URL} userURL The user URL\r\n */\r\nexport function getUserURLFromEmail(userEmail) {\r\n  let indexOfAt = userEmail.indexOf('@');\r\n  return 'user://' + userEmail.substring(indexOfAt + 1, userEmail.length) + '/' + userEmail.substring(0, indexOfAt);\r\n}\r\n\r\n/**\r\n * Obtains the user email that corresponds to a given URL\r\n * @param  {URL.URL} userURL The user URL\r\n * @return {string} userEmail The user email\r\n */\r\nexport function getUserEmailFromURL(userURL) {\r\n  let url = divideURL(userURL);\r\n  return url.identity.replace('/', '') + '@' + url.domain; // identity field has '/exampleID' instead of 'exampleID'\r\n}\r\n\r\n/**\r\n * Check if the user identifier is already in the URL format, if not, convert to URL format\r\n * @param  {string}   identifier  user identifier\r\n * @return {string}   userURL    the user URL\r\n */\r\nexport function convertToUserURL(identifier) {\r\n\r\n  // check if the identifier is already in the url format\r\n  if (identifier.substring(0, 7) === 'user://') {\r\n    let dividedURL = divideURL(identifier);\r\n\r\n    //check if the url is well formated\r\n    if (dividedURL.domain && dividedURL.identity) {\r\n      return identifier;\r\n    } else {\r\n      throw 'userURL with wrong format';\r\n    }\r\n\r\n  //if not, convert the user email to URL format\r\n  } else {\r\n    return getUserURLFromEmail(identifier);\r\n  }\r\n}\r\n\r\nexport function isDataObjectURL(url) {\r\n  let schemasToIgnore = ['domain-idp', 'runtime', 'domain', 'hyperty'];\r\n  let splitURL = (url).split('://');\r\n  let urlSchema = splitURL[0];\r\n\r\n  return schemasToIgnore.indexOf(urlSchema) === -1;\r\n}\r\n\r\nexport function isLegacy(url) {\r\n  if (url.split('@').length > 1) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function isURL(url) {\r\n  return (url).split('/').length >= 3;\r\n}\r\n\r\nexport function isUserURL(url) {\r\n  return divideURL(url).type === 'user';\r\n}\r\n\r\nexport function isHypertyURL(url) {\r\n  return divideURL(url).type === 'hyperty';\r\n}\r\n\r\n/**\r\n * get information relative each component configured on runtime configuration;\r\n * @param  {object} configuration object with all configuration\r\n * @param  {string} component     string with the component to get the configuration, like, runtimeURLS, catalogueURLs, msgNodeURL, domainRegistryURL;\r\n * @param  {string} resource      type of resource to get, like, catalogue, runtimeUA, protocolstub, idpProxy\r\n * @return {object}               return an object with all configurations;\r\n */\r\nexport function getConfigurationResources(configuration, component, resource) {\r\n  let objectResource = configuration[component];\r\n  let resourceType = objectResource[resource];\r\n\r\n  return resourceType;\r\n}\r\n\r\n/**\r\n * Build a full url with the runtime configuration;\r\n * @param  {object} configuration object with all configuration\r\n * @param  {string} component     string with the component to get the configuration, like, runtimeURLS, catalogueURLs, msgNodeURL, domainRegistryURL;\r\n * @param  {string} resource      type of resource to get, like, catalogue, runtimeUA, protocolstub, idpProxy\r\n * @param  {string} type          resource to get, like a hyperty name or protocolstub name;\r\n * @param  {boolean} useFallback  if true the function will check if have a fallback url;\r\n * @return {string}               partial url to contact the resource;\r\n */\r\nexport function buildURL(configuration, component, resource, type, useFallback = false) {\r\n  let objectResource = configuration[component];\r\n  let url;\r\n\r\n  if (!objectResource.hasOwnProperty(resource)) {\r\n    throw Error('The configuration ' + JSON.stringify(objectResource, '', 2) + ' don\\'t have the ' + resource + ' resource you are looking for');\r\n  }\r\n\r\n  let resourceType = objectResource[resource];\r\n\r\n  if (type) {\r\n    url = resourceType.prefix + configuration.domain + resourceType.suffix + type;\r\n    if (resourceType.hasOwnProperty('fallback') && useFallback) {\r\n      if (resourceType.fallback.indexOf('%domain%')) {\r\n        url = resourceType.fallback.replace(/(%domain%)/g, configuration.domain) + type;\r\n      } else {\r\n        url = resourceType.fallback + type;\r\n      }\r\n    }\r\n  } else {\r\n    url = resourceType.prefix + configuration.domain + resourceType.suffix;\r\n  }\r\n\r\n  // console.log(url);\r\n\r\n  return url;\r\n}\r\n\r\n/**\r\n * Generate a Global Unique ID\r\n *\r\n * @returns String;\r\n */\r\nexport function generateGUID() {\r\n\r\n  function s4() {\r\n    return Math.floor((1 + Math.random()) * 0x10000)\r\n      .toString(16)\r\n      .substring(1);\r\n  }\r\n\r\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\r\n\r\n}\r\n\r\nexport function getUserIdentityDomain(url) {\r\n  let dividedURL = divideURL(url);\r\n  let splitedDomain = dividedURL.domain.split('.');\r\n  let splitedLength = splitedDomain.length;\r\n  if (splitedLength == 1) {\r\n    return splitedDomain[splitedLength - 1];\r\n  }\r\n  let domain = splitedDomain[splitedLength - 2] + '.' + splitedDomain[splitedLength - 1];\r\n  return domain;\r\n}\r\n\r\n/**\r\n * Check if URL is from a backend service\r\n * @param  {string} url     URL to be processed\r\n * @return {boolean}\r\n */\r\n\r\nexport function isBackendServiceURL(url) {\r\n  let dividedURL = divideURL(url);\r\n  let splitedDomain = dividedURL.domain.split('.');\r\n  let backendSchemes = ['domain', 'global', 'domain-idp']; // should be defined in the runtime configuration\r\n  let backendSubDomains = ['registry', 'msg-node']; // should be defined in the runtime configuration\r\n  let subDomain;\r\n\r\n  if (splitedDomain.length > 1) {\r\n    subDomain = splitedDomain[0];\r\n  }\r\n\r\n  if (subDomain && backendSubDomains.indexOf(subDomain)) {\r\n    return true;\r\n  }\r\n\r\n  if (dividedURL.type) {\r\n    return (backendSchemes.indexOf(dividedURL.type) !== -1);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function divideEmail(email) {\r\n  let indexOfAt = email.indexOf('@');\r\n\r\n  let result = {\r\n    username: email.substring(0, indexOfAt),\r\n    domain: email.substring(indexOfAt + 1, email.length)\r\n  };\r\n\r\n  return result;\r\n}\r\n",
    "static": true,
    "longname": "src/utils/utils.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 770,
    "kind": "typedef",
    "name": "divideURL",
    "memberof": "src/utils/utils.js",
    "static": true,
    "longname": "src/utils/utils.js~divideURL",
    "access": null,
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type of URL"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "The domain of URL"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "The identity of URL"
      }
    ],
    "type": {
      "types": [
        "*"
      ],
      "optional": false,
      "name": "divideURL"
    }
  },
  {
    "__docId__": 771,
    "kind": "function",
    "name": "divideURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~divideURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{divideURL}",
    "description": "Divide an url in type, domain and identity",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "url address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "divideURL"
      ],
      "spread": false,
      "description": "the result of divideURL"
    }
  },
  {
    "__docId__": 772,
    "kind": "function",
    "name": "emptyObject",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~emptyObject",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{emptyObject}",
    "description": "Check if an Object is empty",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": "Object to be checked"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": "status of Object, empty or not (true|false);"
    }
  },
  {
    "__docId__": 773,
    "kind": "function",
    "name": "deepClone",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~deepClone",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{deepClone}",
    "description": "Make a COPY of the original data",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "object to be cloned"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 774,
    "kind": "function",
    "name": "removePathFromURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~removePathFromURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{removePathFromURL}",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 775,
    "kind": "function",
    "name": "getUserURLFromEmail",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~getUserURLFromEmail",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{getUserURLFromEmail}",
    "description": "Obtains the user URL that corresponds to a given email",
    "lineNumber": 119,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userEmail",
        "description": "The user email"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "URL.URL"
      ],
      "spread": false,
      "description": "userURL The user URL"
    }
  },
  {
    "__docId__": 776,
    "kind": "function",
    "name": "getUserEmailFromURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~getUserEmailFromURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{getUserEmailFromURL}",
    "description": "Obtains the user email that corresponds to a given URL",
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "userURL",
        "description": "The user URL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "userEmail The user email"
    }
  },
  {
    "__docId__": 777,
    "kind": "function",
    "name": "convertToUserURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~convertToUserURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{convertToUserURL}",
    "description": "Check if the user identifier is already in the URL format, if not, convert to URL format",
    "lineNumber": 139,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "user identifier"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "userURL    the user URL"
    }
  },
  {
    "__docId__": 778,
    "kind": "function",
    "name": "isDataObjectURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~isDataObjectURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{isDataObjectURL}",
    "description": null,
    "lineNumber": 158,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 779,
    "kind": "function",
    "name": "isLegacy",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~isLegacy",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{isLegacy}",
    "description": null,
    "lineNumber": 166,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 780,
    "kind": "function",
    "name": "isURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~isURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{isURL}",
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 781,
    "kind": "function",
    "name": "isUserURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~isUserURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{isUserURL}",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 782,
    "kind": "function",
    "name": "isHypertyURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~isHypertyURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{isHypertyURL}",
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 783,
    "kind": "function",
    "name": "getConfigurationResources",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~getConfigurationResources",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{getConfigurationResources}",
    "description": "get information relative each component configured on runtime configuration;",
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "object with all configuration"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "component",
        "description": "string with the component to get the configuration, like, runtimeURLS, catalogueURLs, msgNodeURL, domainRegistryURL;"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "type of resource to get, like, catalogue, runtimeUA, protocolstub, idpProxy"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "return an object with all configurations;"
    }
  },
  {
    "__docId__": 784,
    "kind": "function",
    "name": "buildURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~buildURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{buildURL}",
    "description": "Build a full url with the runtime configuration;",
    "lineNumber": 209,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "object with all configuration"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "component",
        "description": "string with the component to get the configuration, like, runtimeURLS, catalogueURLs, msgNodeURL, domainRegistryURL;"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "type of resource to get, like, catalogue, runtimeUA, protocolstub, idpProxy"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "resource to get, like a hyperty name or protocolstub name;"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useFallback",
        "description": "if true the function will check if have a fallback url;"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "partial url to contact the resource;"
    }
  },
  {
    "__docId__": 785,
    "kind": "function",
    "name": "generateGUID",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~generateGUID",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{generateGUID}",
    "description": "Generate a Global Unique ID",
    "lineNumber": 242,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "String;"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "String;"
    }
  },
  {
    "__docId__": 786,
    "kind": "function",
    "name": "getUserIdentityDomain",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~getUserIdentityDomain",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{getUserIdentityDomain}",
    "description": null,
    "lineNumber": 254,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 787,
    "kind": "function",
    "name": "isBackendServiceURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~isBackendServiceURL",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{isBackendServiceURL}",
    "description": "Check if URL is from a backend service",
    "lineNumber": 271,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "URL to be processed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 788,
    "kind": "function",
    "name": "divideEmail",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~divideEmail",
    "access": null,
    "export": true,
    "importPath": "runtime-core/src/utils/utils.js",
    "importStyle": "{divideEmail}",
    "description": null,
    "lineNumber": 293,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "email",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 790,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 791,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 792,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 793,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 794,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 795,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 796,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 797,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 798,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 799,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 800,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 801,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 802,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 803,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 804,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 805,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 806,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 807,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 808,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 809,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 810,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 811,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 812,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 813,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 814,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 815,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 816,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 817,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 818,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 819,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 820,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 821,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 822,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 823,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 824,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 825,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 826,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 827,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 828,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 829,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 830,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 831,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 832,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 833,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 834,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 835,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 836,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "lineNumber": 193,
    "builtinExternal": true
  },
  {
    "__docId__": 838,
    "kind": "external",
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 839,
    "kind": "external",
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 840,
    "kind": "external",
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 841,
    "kind": "external",
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 842,
    "kind": "external",
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 843,
    "kind": "external",
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 844,
    "kind": "external",
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 845,
    "kind": "external",
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "lineNumber": 34,
    "builtinExternal": true
  },
  {
    "__docId__": 846,
    "kind": "testFile",
    "name": "test/AddressAllocation.spec.js",
    "content": "import chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\nimport sinonChai from 'sinon-chai';\r\n\r\nimport { generateGUID } from '../src/utils/utils';\r\nimport AddressAllocation from '../src/allocation/AddressAllocation';\r\n\r\nchai.config.truncateThreshold = 0;\r\n\r\nlet expect = chai.expect;\r\n\r\nchai.use(chaiAsPromised);\r\nchai.use(sinonChai);\r\n\r\ndescribe('AddressAllocation', function() {\r\n\r\n  let aa;\r\n  let registry;\r\n  let bus;\r\n  let guid = generateGUID();\r\n  let domain = 'sp.domain';\r\n\r\n  before(() => {\r\n\r\n    registry = {\r\n      registerHyperty: () => {},\r\n      checkRegisteredURLs: () => {}\r\n    };\r\n\r\n    bus = {\r\n      postMessage: (msg, replyCallback) => {\r\n\r\n        if (!msg.body.scheme) { msg.body.scheme = 'hyperty'; }\r\n\r\n        replyCallback({\r\n          id: 1, type: 'response', from: 'domain://msg-node.sp.domain/address-allocation', to: 'local://fake.url',\r\n          body: {code: 200, value: {allocated: msg.body.scheme + '://' + domain + '/' + guid}}\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n    sinon.stub(registry, 'checkRegisteredURLs', (info) => {\r\n\r\n      return new Promise((resolve) => {\r\n\r\n        console.log('CHECK REGISTER: ', info);\r\n\r\n        if (info.reporter.length === 0) {\r\n          resolve('hyperty://' + domain + '/' + guid);\r\n        } else {\r\n          resolve('comm://' + domain + '/' + guid);\r\n        }\r\n\r\n      });\r\n\r\n    });\r\n\r\n    let runtimeURL = 'hyperty-runtime://ua.pt/123';\r\n    new AddressAllocation(runtimeURL, bus, registry);\r\n    aa = AddressAllocation.instance;\r\n  });\r\n\r\n  it('should create a new hyperty address', function(done) {\r\n\r\n    let number = 2;\r\n    let scheme = 'hyperty';\r\n    let info = {\r\n      name: 'test',\r\n      schema: 'hyperty-catalogue://' + domain + '/.well-known/dataschema/hello',\r\n      reporter: [],\r\n      resources: []\r\n    };\r\n    expect(aa.create(domain, number, info, scheme))\r\n    .eventually.to.eql({newAddress: true, address: 'hyperty://' + domain + '/' + guid})\r\n    .notify(done);\r\n  });\r\n\r\n  it('should create a new data Object address', function(done) {\r\n\r\n    let number = 2;\r\n    let scheme = 'comm';\r\n    let info = {\r\n      name: 'dataObjectName',\r\n      schema: 'hyperty-catalogue://' + domain + '/.well-known/dataschema/communication',\r\n      reporter: ['comm://' + domain + '/' + guid],\r\n      resources: ['chat']\r\n    };\r\n    expect(aa.create(domain, number, info, scheme))\r\n    .eventually.to.eql({newAddress: true, address: 'comm://' + domain + '/' + guid})\r\n    .notify(done);\r\n  });\r\n\r\n\r\n  it('should reuse an hyperty url address based on reuse option', function(done) {\r\n\r\n    let number = 1;\r\n    let scheme = 'hyperty';\r\n    let info = {\r\n      name: 'test',\r\n      schema: 'hyperty-catalogue://' + domain + '/.well-known/dataschema/hello',\r\n      reporter: [],\r\n      resources: []\r\n    };\r\n\r\n    expect(aa.create(domain, number, info, scheme, true))\r\n    .eventually.to.eql({newAddress: false, address: 'hyperty://' + domain + '/' + guid})\r\n    .notify(done);\r\n\r\n  });\r\n\r\n  it('should reuse an hyperty url address based on an given url', function(done) {\r\n\r\n    let number = 1;\r\n    let scheme = 'hyperty';\r\n    let info = {\r\n      name: 'test',\r\n      schema: 'hyperty-catalogue://' + domain + '/.well-known/dataschema/hello',\r\n      reporter: [],\r\n      resources: []\r\n    };\r\n\r\n    expect(aa.create(domain, number, info, scheme, 'hyperty://' + domain + '/' + guid))\r\n    .eventually.to.eql({newAddress: false, address: 'hyperty://' + domain + '/' + guid})\r\n    .notify(done);\r\n\r\n  });\r\n\r\n});\r\n",
    "static": true,
    "longname": "test/AddressAllocation.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 847,
    "kind": "testDescribe",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/AddressAllocation.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/AddressAllocation.spec.js~describe0",
    "access": null,
    "description": "AddressAllocation",
    "lineNumber": 15
  },
  {
    "__docId__": 848,
    "kind": "testIt",
    "name": "it1",
    "testId": 1,
    "memberof": "test/AddressAllocation.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/AddressAllocation.spec.js~describe0.it1",
    "access": null,
    "description": "should create a new hyperty address",
    "lineNumber": 64
  },
  {
    "__docId__": 849,
    "kind": "testIt",
    "name": "it2",
    "testId": 2,
    "memberof": "test/AddressAllocation.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/AddressAllocation.spec.js~describe0.it2",
    "access": null,
    "description": "should create a new data Object address",
    "lineNumber": 79
  },
  {
    "__docId__": 850,
    "kind": "testIt",
    "name": "it3",
    "testId": 3,
    "memberof": "test/AddressAllocation.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/AddressAllocation.spec.js~describe0.it3",
    "access": null,
    "description": "should reuse an hyperty url address based on reuse option",
    "lineNumber": 95
  },
  {
    "__docId__": 851,
    "kind": "testIt",
    "name": "it4",
    "testId": 4,
    "memberof": "test/AddressAllocation.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/AddressAllocation.spec.js~describe0.it4",
    "access": null,
    "description": "should reuse an hyperty url address based on an given url",
    "lineNumber": 112
  },
  {
    "__docId__": 852,
    "kind": "testFile",
    "name": "test/Descriptors.spec.js",
    "content": "import chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\nimport sinonChai from 'sinon-chai';\r\n\r\nlet expect = chai.expect;\r\n\r\nchai.use(chaiAsPromised);\r\nchai.use(sinonChai);\r\n\r\nimport { descriptors } from './resources/descriptors.js';\r\n\r\nimport { buildURL } from '../src/utils/utils';\r\nimport { runtimeConfiguration } from './resources/runtimeConfiguration';\r\nimport { runtimeFactory } from './resources/runtimeFactory';\r\nimport Descriptors from '../src/runtime/Descriptors';\r\n\r\ndescribe('Should get configuration and parse to Descriptors', () => {\r\n\r\n  // Testing Registry\r\n  let domain = 'sp.domain';\r\n  let runtimeURL = 'hyperty-runtime://' + domain + '/123';\r\n  let descriptorsInstance;\r\n\r\n  runtimeConfiguration.domain = domain;\r\n\r\n  before(()=> {\r\n    let catalogue = runtimeFactory.createRuntimeCatalogue();\r\n    descriptorsInstance = new Descriptors(runtimeURL, catalogue, runtimeConfiguration);\r\n\r\n    sinon.stub(descriptorsInstance.catalogue, 'getStubDescriptor', (url) => {\r\n      return new Promise((resolve) => {\r\n        resolve(descriptors.ProtoStubs.default);\r\n      });\r\n    });\r\n\r\n    sinon.stub(descriptorsInstance.catalogue, 'getIdpProxyDescriptor', (url) => {\r\n      return new Promise((resolve, reject) => {\r\n        if (url.includes('catalogue.google.com')) {\r\n          reject();\r\n        } else {\r\n          resolve(descriptors.IdpProxies['google.com']);\r\n        }\r\n      });\r\n    });\r\n\r\n    sinon.stub(descriptorsInstance.catalogue, 'getHypertyDescriptor', (url) => {\r\n      return new Promise((resolve) => {\r\n        resolve(descriptors.Hyperties.HelloHyperty);\r\n      });\r\n    });\r\n\r\n  });\r\n\r\n  after(() => {\r\n    descriptorsInstance.catalogue.getIdpProxyDescriptor.restore();\r\n    descriptorsInstance.catalogue.getHypertyDescriptor.restore();\r\n    descriptorsInstance.catalogue.getStubDescriptor.restore();\r\n  });\r\n\r\n  it('constructor should receive 3 arguments', () => {\r\n\r\n    expect(descriptorsInstance)\r\n    .to.have.property('runtimeURL')\r\n    .that.is.an('string')\r\n    .to.not.be.empty;\r\n\r\n    expect(descriptorsInstance)\r\n    .to.have.property('catalogue');\r\n\r\n    expect(descriptorsInstance)\r\n    .to.have.property('runtimeConfiguration')\r\n    .that.is.a('object')\r\n    .and.to.contain.all.keys(runtimeConfiguration);\r\n\r\n  });\r\n\r\n  it('should get hyperty', (done) => {\r\n\r\n    let hypertyDescriptorURL = 'hyperty-catalogue://catalogue.sp.domain/.well-known/hyperty/Connector';\r\n\r\n    expect(descriptorsInstance.getHypertyDescriptor(hypertyDescriptorURL))\r\n    .to.be.fulfilled\r\n    .and.notify(done);\r\n\r\n  });\r\n\r\n  it('should get protocolstub', (done) => {\r\n\r\n    let stubDescriptorURL = 'sp.domain';\r\n\r\n    expect(descriptorsInstance.getStubDescriptor(stubDescriptorURL))\r\n    .to.be.fulfilled\r\n    .and.notify(done);\r\n\r\n  });\r\n\r\n  it('should get protocolstub', (done) => {\r\n\r\n    let idpProxyURL = 'google.com';\r\n\r\n    expect(descriptorsInstance.getIdpProxyDescriptor(idpProxyURL))\r\n    .to.be.fulfilled\r\n    .and.notify(done);\r\n\r\n  });\r\n\r\n});\r\n",
    "static": true,
    "longname": "test/Descriptors.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 853,
    "kind": "testDescribe",
    "name": "describe5",
    "testId": 5,
    "memberof": "test/Descriptors.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/Descriptors.spec.js~describe5",
    "access": null,
    "description": "Should get configuration and parse to Descriptors",
    "lineNumber": 17
  },
  {
    "__docId__": 854,
    "kind": "testIt",
    "name": "it6",
    "testId": 6,
    "memberof": "test/Descriptors.spec.js~describe5",
    "testDepth": 1,
    "static": true,
    "longname": "test/Descriptors.spec.js~describe5.it6",
    "access": null,
    "description": "constructor should receive 3 arguments",
    "lineNumber": 60
  },
  {
    "__docId__": 855,
    "kind": "testIt",
    "name": "it7",
    "testId": 7,
    "memberof": "test/Descriptors.spec.js~describe5",
    "testDepth": 1,
    "static": true,
    "longname": "test/Descriptors.spec.js~describe5.it7",
    "access": null,
    "description": "should get hyperty",
    "lineNumber": 77
  },
  {
    "__docId__": 856,
    "kind": "testIt",
    "name": "it8",
    "testId": 8,
    "memberof": "test/Descriptors.spec.js~describe5",
    "testDepth": 1,
    "static": true,
    "longname": "test/Descriptors.spec.js~describe5.it8",
    "access": null,
    "description": "should get protocolstub",
    "lineNumber": 87
  },
  {
    "__docId__": 857,
    "kind": "testIt",
    "name": "it9",
    "testId": 9,
    "memberof": "test/Descriptors.spec.js~describe5",
    "testDepth": 1,
    "static": true,
    "longname": "test/Descriptors.spec.js~describe5.it9",
    "access": null,
    "description": "should get protocolstub",
    "lineNumber": 97
  },
  {
    "__docId__": 858,
    "kind": "testFile",
    "name": "test/GraphConnector.spec.js",
    "content": "import chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\n\r\nchai.config.truncateThreshold = 0;\r\n\r\nlet expect = chai.expect;\r\nchai.use(chaiAsPromised);\r\n\r\n// dependencies\r\nimport BloomFilter from '../src/graphconnector/BloomFilter';\r\nimport GraphConnector from '../src/graphconnector/GraphConnector';\r\nimport GraphConnectorContactData from '../src/graphconnector/GraphConnectorContactData';\r\nimport bip39 from 'bip39';\r\nimport jsrsasign from 'jsrsasign';\r\nimport Registry from '../src/registry/Registry';\r\nimport MessageBus from '../src/bus/MessageBus';\r\nimport RuntimeFactory from '../resources/RuntimeFactory';\r\n\r\n// variables\r\nlet runtimeURL = 'hyperty-runtime://ua.pt/123';\r\nlet runtimeFactory = new RuntimeFactory();\r\nlet appSandbox = runtimeFactory.createAppSandbox();\r\n\r\nlet identityModule = {\r\n  getIdentities: () => {\r\n    let identities = [];\r\n    let identityBundle = {identity: 'user://gmail.com/openidtest10', token: 'idToken'};\r\n    identities.push(identityBundle);\r\n    return identities;\r\n  }\r\n};\r\n\r\nlet getRegistry = new Promise(function(resolve, reject) {\r\n  let registry = new Registry(runtimeURL, appSandbox, identityModule);\r\n  resolve(registry);\r\n});\r\n\r\ngetRegistry.then(function(registry) {\r\n  describe('Graph Connector', function() {\r\n\r\n    describe('construction', function() {\r\n      it('create new GraphConnector instance with zero contacts', function() {\r\n        let msgbus = new MessageBus(registry);\r\n        registry.messageBus = msgbus;\r\n        let graphConnector = new GraphConnector(runtimeURL, msgbus);\r\n        expect(graphConnector.contacts.length).to.equal(0);\r\n      });\r\n    });\r\n\r\n    describe('create mock address book', function() {\r\n      let msgbus = new MessageBus(registry);\r\n      registry.messageBus = msgbus;\r\n      var graphConnector = new GraphConnector(runtimeURL, msgbus);\r\n      let guid;\r\n      let firstName;\r\n      let lastName;\r\n      let remGUIDArr = [];\r\n      for (let j = 0; j < 299; j++) {\r\n\r\n        // to mock GUIDs for now\r\n        guid = Math.floor(Math.random() * 9999999999999999999999999999999999) + 1000000000000000000000000000000000;\r\n\r\n        firstName = randomName();\r\n        lastName = randomName();\r\n        graphConnector.addContact(guid, firstName, lastName);\r\n        if (j % 10 === 0) {\r\n          remGUIDArr.push(guid);\r\n        }\r\n      }\r\n      graphConnector.addContact('123', 'Alice', 'Wonderland');\r\n      var expected = new GraphConnectorContactData('123', 'Alice', 'Wonderland');\r\n\r\n      it('create new GraphConnector with random contacts', function() {\r\n        expect(graphConnector.contacts.length).to.equal(300);\r\n      });\r\n\r\n      it('remove some contacts from GraphConnector', function() {\r\n        for (let j = 0; j < remGUIDArr.length; j++) {\r\n          graphConnector.removeContact(remGUIDArr[j]);\r\n        }\r\n        expect(graphConnector.contacts.length).to.equal(270);\r\n      });\r\n\r\n      it('get contact by first name', function() {\r\n        let result = graphConnector.getContact('Alice');\r\n        expect(result.length).to.equal(1);\r\n        expect(result[0]).to.eql(expected);\r\n      });\r\n\r\n      it('get contact by last name', function() {\r\n        let result = graphConnector.getContact('Wonderland');\r\n        expect(result.length).to.equal(1);\r\n        expect(result[0]).to.eql(expected);\r\n      });\r\n\r\n      it('check GUID when in direct contacts', function() {\r\n\r\n        // Format is: RelatedContacts<Direct<GraphConnectorContactData>,FoF<GraphConnectorContactData>>\r\n        let result = graphConnector.checkGUID('123');\r\n        let directContacts = result[0];\r\n        let fofs = result [1];\r\n        expect(result.length).to.equal(2);\r\n        expect(directContacts.length).to.equal(1);\r\n        expect(fofs.length).to.equal(0);\r\n        expect(directContacts[0]).to.eql(expected);\r\n      });\r\n\r\n      it('test direct contacts bloom filter', function() {\r\n\r\n        graphConnector.calculateBloomFilter1Hop();\r\n\r\n        for (let i = 0; i < remGUIDArr.length; i++) {\r\n          let result = graphConnector.contactsBloomFilter1Hop.test(remGUIDArr[i]);\r\n          expect(result).to.equal(false);\r\n        }\r\n\r\n        let resultAlice = graphConnector.contactsBloomFilter1Hop.test('123');\r\n        expect(resultAlice).to.equal(true);\r\n        expect(graphConnector.contactsBloomFilter1Hop.test('absdgdghdftgh')).to.equal(false);\r\n        graphConnector.removeContact('123');\r\n        expect(graphConnector.contactsBloomFilter1Hop.test('123')).to.equal(false);\r\n\r\n      });\r\n\r\n      it('test privacy setting for contacts', function() {\r\n\r\n        graphConnector.addContact('123', 'Alice', 'Wonderland');\r\n        graphConnector.calculateBloomFilter1Hop();\r\n        expect(graphConnector.contactsBloomFilter1Hop.test('123')).to.equal(true);\r\n\r\n        // set private\r\n        graphConnector.getContact('Alice')[0].privateContact = true;\r\n        graphConnector.calculateBloomFilter1Hop();\r\n        expect(graphConnector.contactsBloomFilter1Hop.test('123')).to.equal(false);\r\n\r\n      });\r\n\r\n      it('check GUID when in friend-of-friend connection', function() {\r\n\r\n        let bf = new BloomFilter(\r\n          431328,   // number of bits to allocate.\r\n          10        // number of hash functions.\r\n        );\r\n\r\n        bf.add('george');\r\n        bf.add('jerry');\r\n        bf.add('elaine');\r\n        graphConnector.getContact('Alice')[0].contactsBloomFilter1Hop = bf;\r\n\r\n        let result = graphConnector.checkGUID('george');\r\n        let directContacts = result[0];\r\n        let fofs = result [1];\r\n        expect(result.length).to.equal(2);\r\n        expect(directContacts.length).to.equal(0);\r\n        expect(fofs.length).to.equal(1);\r\n\r\n        // connection through Alice\r\n        expect(fofs[0].firstName).to.eql('Alice');\r\n        expect(fofs[0].lastName).to.eql('Wonderland');\r\n        expect(fofs[0].guid).to.eql('123');\r\n\r\n      });\r\n\r\n      it('bloom filter tests', function() {\r\n\r\n        let jabberwocky = '`Twas brillig, and the slithy toves\\n  Did gyre and gimble in the wabe:\\nAll mimsy were the borogoves,\\n  And the mome raths outgrabe.\\n\\n\\\"Beware the Jabberwock, my son!\\n  The jaws that bite, the claws that catch!\\nBeware the Jubjub bird, and shun\\n  The frumious Bandersnatch!\\\"\\n\\nHe took his vorpal sword in hand:\\n  Long time the manxome foe he sought --\\nSo rested he by the Tumtum tree,\\n  And stood awhile in thought.\\n\\nAnd, as in uffish thought he stood,\\n  The Jabberwock, with eyes of flame,\\nCame whiffling through the tulgey wood,\\n  And burbled as it came!\\n\\nOne, two! One, two! And through and through\\n  The vorpal blade went snicker-snack!\\nHe left it dead, and with its head\\n  He went galumphing back.\\n\\n\\\"And, has thou slain the Jabberwock?\\n  Come to my arms, my beamish boy!\\nO frabjous day! Callooh! Callay!\\n  He chortled in his joy.\\n\\n`Twas brillig, and the slithy toves\\n  Did gyre and gimble in the wabe;\\nAll mimsy were the borogoves,\\n  And the mome raths outgrabe.';\r\n\r\n        let f = new BloomFilter(1000, 4);\r\n        let n1 = 'Bess';\r\n        let n2 = 'Jane';\r\n        f.add(n1);\r\n        expect(f.test(n1)).to.equal(true);\r\n        expect(f.test(n2)).to.equal(false);\r\n\r\n        f = new BloomFilter(1000, 4);\r\n        n1 = jabberwocky;\r\n        n2 = jabberwocky + '\\n';\r\n        f.add(n1);\r\n        expect(f.test(n1)).to.equal(true);\r\n        expect(f.test(n2)).to.equal(false);\r\n\r\n        f = new BloomFilter(1000, 4);\r\n        n1 = '\\u0100';\r\n        n2 = '\\u0101';\r\n        let n3 = '\\u0103';\r\n        f.add(n1);\r\n        expect(f.test(n1)).to.equal(true);\r\n        expect(f.test(n2)).to.equal(false);\r\n        expect(f.test(n3)).to.equal(false);\r\n\r\n        f = new BloomFilter(20, 10);\r\n        f.add('abc');\r\n        expect(f.test('wtf')).to.equal(false);\r\n\r\n        f = new BloomFilter(1000, 4);\r\n        f.add(1);\r\n        expect(f.test(1)).to.equal(true);\r\n        expect(f.test(2)).to.equal(false);\r\n\r\n        f = new BloomFilter(1000, 4);\r\n        for (let i = 0; i < 100; ++i) {\r\n          f.add(i);\r\n        }\r\n        expect(f.size()).to.be.closeTo(99.953102, 1e-6);\r\n        for (let i = 0; i < 1000; ++i) {\r\n          f.add(i);\r\n        }\r\n        expect(f.size()).to.be.closeTo(950.424571, 1e-6);\r\n\r\n      });\r\n\r\n    });\r\n\r\n    describe('GUID', function() {\r\n      let msgbus = new MessageBus(registry);\r\n      registry.messageBus = msgbus;\r\n      let graphConnector1 = new GraphConnector(runtimeURL, msgbus);\r\n      let graphConnector2 = new GraphConnector(runtimeURL, msgbus);\r\n\r\n      it('GUID generation', function() {\r\n\r\n        this.timeout(30000);\r\n\r\n        let mnemonic1 = graphConnector1.generateGUID();\r\n        let res = mnemonic1.split(' ');\r\n\r\n        expect(res.length).to.equal(16);\r\n\r\n      });\r\n\r\n      it('GUID re-generation', function(done) {\r\n\r\n        this.timeout(15000);\r\n\r\n        // create mnemonic and sign Global Regsitry record\r\n        let mnemonic1 = graphConnector1.generateGUID();\r\n        let jwt1 = graphConnector1.signGlobalRegistryRecord();\r\n\r\n        // mock reply from Global Registry\r\n        graphConnector2.messageBus.addListener('global://registry/', (msg) => {\r\n          let message = {id: msg.id, type: 'response', from: 'global://registry/', to: msg.from,\r\n          body: { message: 'request was performed successfully',\r\n          responseCode: 200,\r\n          data: jwt1,\r\n          errorCode: 0 }};\r\n\r\n          graphConnector2.messageBus.postMessage(message, (reply) => {\r\n            console.log('Reply GUID re-generation: ', reply);\r\n          });\r\n        });\r\n\r\n        expect(graphConnector2.useGUID(mnemonic1).then(function(response) {\r\n\r\n          let publicKey2 = graphConnector2.globalRegistryRecord.publicKey;\r\n          let publicKeyObject2 = jsrsasign.KEYUTIL.getKey(publicKey2);\r\n\r\n          let unwrappedJWT = KJUR.jws.JWS.parse(jwt1);\r\n          let encodedString = jwt1.split('.').slice(0, 2).join('.');\r\n          let sigValueHex = unwrappedJWT.sigHex;\r\n          let sig = new KJUR.crypto.Signature({alg: 'SHA256withECDSA'});\r\n          sig.init(publicKeyObject2);\r\n          sig.updateString(encodedString);\r\n          let isValid = sig.verify(sigValueHex);\r\n\r\n          return isValid;\r\n        })).to.be.fulfilled.and.eventually.equal(true).and.notify(done);\r\n\r\n      });\r\n    });\r\n\r\n    describe('Global Registry Connection - send', function() {\r\n      let msgbus = new MessageBus(registry);\r\n      registry.messageBus = msgbus;\r\n      let graphConnector1 = new GraphConnector(runtimeURL, msgbus);\r\n      let graphConnector2 = new GraphConnector(runtimeURL, msgbus);\r\n\r\n      it('send Global Registry Record', function(done) {\r\n\r\n        this.timeout(15000);\r\n\r\n        // create mnemonic and sign Global Regsitry record\r\n        let mnemonic1 = graphConnector1.generateGUID();\r\n        let jwt1 = graphConnector1.signGlobalRegistryRecord();\r\n\r\n        // mock reply from Global Registry 1\r\n        graphConnector1.messageBus.addListener('global://registry/', (msg) => {\r\n          let message = {id: msg.id, type: 'response', from: 'global://registry/', to: msg.from,\r\n          body: { message: 'request was performed successfully',\r\n          responseCode: 200,\r\n          errorCode: 0 }};\r\n\r\n          graphConnector1.messageBus.postMessage(message, (reply) => {\r\n            console.log('Reply GRC - send: ', reply);\r\n          });\r\n        });\r\n\r\n        expect(graphConnector1.sendGlobalRegistryRecord(jwt1).then(function(response) {\r\n          return response;\r\n        })).to.be.fulfilled.and.eventually.equal(200).and.notify(done);\r\n\r\n      });\r\n    });\r\n\r\n    describe('Global Registry Connection - use GUID', function() {\r\n      let msgbus = new MessageBus(registry);\r\n      registry.messageBus = msgbus;\r\n      let graphConnector1 = new GraphConnector(runtimeURL, msgbus);\r\n      let graphConnector2 = new GraphConnector(runtimeURL, msgbus);\r\n\r\n      it('re-use GUID and retrieve data from Global Registry', function(done) {\r\n\r\n        this.timeout(15000);\r\n\r\n        // create mnemonic and sign Global Regsitry record\r\n        let mnemonic1 = graphConnector1.generateGUID();\r\n        let jwt1 = graphConnector1.signGlobalRegistryRecord();\r\n        let grr1 = graphConnector1.globalRegistryRecord;\r\n\r\n        // mock reply from Global Registry 2\r\n        graphConnector2.messageBus.addListener('global://registry/', (msg) => {\r\n          let message = {id: msg.id, type: 'response', from: 'global://registry/', to: msg.from,\r\n          body: { message: 'request was performed successfully',\r\n          responseCode: 200,\r\n          data: jwt1,\r\n          errorCode: 0 }};\r\n\r\n          graphConnector2.messageBus.postMessage(message, (reply) => {\r\n            console.log('Reply GRC - use GUID: ', reply);\r\n          });\r\n        });\r\n\r\n        expect(graphConnector2.useGUID(mnemonic1).then(function(response) {\r\n          return graphConnector2.globalRegistryRecord;\r\n        })).to.be.fulfilled.and.eventually.eql(grr1).and.notify(done);\r\n      });\r\n\r\n    });\r\n\r\n    describe('Querying Global Registry', function() {\r\n      let msgbus = new MessageBus(registry);\r\n      registry.messageBus = msgbus;\r\n      let graphConnector1 = new GraphConnector(runtimeURL, msgbus);\r\n      let graphConnector2 = new GraphConnector(runtimeURL, msgbus);\r\n\r\n      it('query Global Registry', function(done) {\r\n\r\n        this.timeout(15000);\r\n\r\n        // create mnemonic and sign Global Regsitry record\r\n        let mnemonic1 = graphConnector1.generateGUID();\r\n        let jwt1 = graphConnector1.signGlobalRegistryRecord();\r\n        let guid1 = graphConnector1.globalRegistryRecord.guid;\r\n        let result = new GraphConnectorContactData();\r\n\r\n        // mock reply from Global Registry\r\n        graphConnector2.messageBus.addListener('global://registry/', (msg) => {\r\n          let message = {id: 1, type: 'response', from: 'global://registry/', to: msg.from,\r\n          body: { message: 'request was performed successfully',\r\n          responseCode: 200,\r\n          data: jwt1,\r\n          errorCode: 0 }};\r\n\r\n          graphConnector2.messageBus.postMessage(message, (reply) => {\r\n            console.log('Reply QGR - query: ', reply);\r\n          });\r\n        });\r\n\r\n        expect(graphConnector2.queryGlobalRegistry(guid1).then(function(response) {\r\n          return response.guid;\r\n        })).to.be.fulfilled.and.eventually.equal(guid1).and.notify(done);\r\n\r\n      });\r\n\r\n    });\r\n\r\n  });\r\n});\r\n\r\nfunction randomName() {\r\n  let text = '';\r\n  let firstLetter = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n  let restLetters = 'abcdefghijklmnopqrstuvwxyz';\r\n\r\n  text += firstLetter.charAt(Math.floor(Math.random() * firstLetter.length));\r\n\r\n  for (let i = 0; i < 4; i++) {\r\n    text += restLetters.charAt(Math.floor(Math.random() * restLetters.length));\r\n  }\r\n\r\n  return text;\r\n}\r\n",
    "static": true,
    "longname": "test/GraphConnector.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 859,
    "kind": "testDescribe",
    "name": "describe10",
    "testId": 10,
    "memberof": "test/GraphConnector.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10",
    "access": null,
    "description": "Graph Connector",
    "lineNumber": 39
  },
  {
    "__docId__": 860,
    "kind": "testDescribe",
    "name": "describe11",
    "testId": 11,
    "memberof": "test/GraphConnector.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe11",
    "access": null,
    "description": "construction",
    "lineNumber": 41
  },
  {
    "__docId__": 861,
    "kind": "testIt",
    "name": "it12",
    "testId": 12,
    "memberof": "test/GraphConnector.spec.js~describe10.describe11",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe11.it12",
    "access": null,
    "description": "create new GraphConnector instance with zero contacts",
    "lineNumber": 42
  },
  {
    "__docId__": 862,
    "kind": "testDescribe",
    "name": "describe13",
    "testId": 13,
    "memberof": "test/GraphConnector.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13",
    "access": null,
    "description": "create mock address book",
    "lineNumber": 50
  },
  {
    "__docId__": 863,
    "kind": "testIt",
    "name": "it14",
    "testId": 14,
    "memberof": "test/GraphConnector.spec.js~describe10.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13.it14",
    "access": null,
    "description": "create new GraphConnector with random contacts",
    "lineNumber": 73
  },
  {
    "__docId__": 864,
    "kind": "testIt",
    "name": "it15",
    "testId": 15,
    "memberof": "test/GraphConnector.spec.js~describe10.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13.it15",
    "access": null,
    "description": "remove some contacts from GraphConnector",
    "lineNumber": 77
  },
  {
    "__docId__": 865,
    "kind": "testIt",
    "name": "it16",
    "testId": 16,
    "memberof": "test/GraphConnector.spec.js~describe10.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13.it16",
    "access": null,
    "description": "get contact by first name",
    "lineNumber": 84
  },
  {
    "__docId__": 866,
    "kind": "testIt",
    "name": "it17",
    "testId": 17,
    "memberof": "test/GraphConnector.spec.js~describe10.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13.it17",
    "access": null,
    "description": "get contact by last name",
    "lineNumber": 90
  },
  {
    "__docId__": 867,
    "kind": "testIt",
    "name": "it18",
    "testId": 18,
    "memberof": "test/GraphConnector.spec.js~describe10.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13.it18",
    "access": null,
    "description": "check GUID when in direct contacts",
    "lineNumber": 96
  },
  {
    "__docId__": 868,
    "kind": "testIt",
    "name": "it19",
    "testId": 19,
    "memberof": "test/GraphConnector.spec.js~describe10.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13.it19",
    "access": null,
    "description": "test direct contacts bloom filter",
    "lineNumber": 108
  },
  {
    "__docId__": 869,
    "kind": "testIt",
    "name": "it20",
    "testId": 20,
    "memberof": "test/GraphConnector.spec.js~describe10.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13.it20",
    "access": null,
    "description": "test privacy setting for contacts",
    "lineNumber": 125
  },
  {
    "__docId__": 870,
    "kind": "testIt",
    "name": "it21",
    "testId": 21,
    "memberof": "test/GraphConnector.spec.js~describe10.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13.it21",
    "access": null,
    "description": "check GUID when in friend-of-friend connection",
    "lineNumber": 138
  },
  {
    "__docId__": 871,
    "kind": "testIt",
    "name": "it22",
    "testId": 22,
    "memberof": "test/GraphConnector.spec.js~describe10.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe13.it22",
    "access": null,
    "description": "bloom filter tests",
    "lineNumber": 164
  },
  {
    "__docId__": 872,
    "kind": "testDescribe",
    "name": "describe23",
    "testId": 23,
    "memberof": "test/GraphConnector.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe23",
    "access": null,
    "description": "GUID",
    "lineNumber": 214
  },
  {
    "__docId__": 873,
    "kind": "testIt",
    "name": "it24",
    "testId": 24,
    "memberof": "test/GraphConnector.spec.js~describe10.describe23",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe23.it24",
    "access": null,
    "description": "GUID generation",
    "lineNumber": 220
  },
  {
    "__docId__": 874,
    "kind": "testIt",
    "name": "it25",
    "testId": 25,
    "memberof": "test/GraphConnector.spec.js~describe10.describe23",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe23.it25",
    "access": null,
    "description": "GUID re-generation",
    "lineNumber": 231
  },
  {
    "__docId__": 875,
    "kind": "testDescribe",
    "name": "describe26",
    "testId": 26,
    "memberof": "test/GraphConnector.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe26",
    "access": null,
    "description": "Global Registry Connection - send",
    "lineNumber": 271
  },
  {
    "__docId__": 876,
    "kind": "testIt",
    "name": "it27",
    "testId": 27,
    "memberof": "test/GraphConnector.spec.js~describe10.describe26",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe26.it27",
    "access": null,
    "description": "send Global Registry Record",
    "lineNumber": 277
  },
  {
    "__docId__": 877,
    "kind": "testDescribe",
    "name": "describe28",
    "testId": 28,
    "memberof": "test/GraphConnector.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe28",
    "access": null,
    "description": "Global Registry Connection - use GUID",
    "lineNumber": 304
  },
  {
    "__docId__": 878,
    "kind": "testIt",
    "name": "it29",
    "testId": 29,
    "memberof": "test/GraphConnector.spec.js~describe10.describe28",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe28.it29",
    "access": null,
    "description": "re-use GUID and retrieve data from Global Registry",
    "lineNumber": 310
  },
  {
    "__docId__": 879,
    "kind": "testDescribe",
    "name": "describe30",
    "testId": 30,
    "memberof": "test/GraphConnector.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe30",
    "access": null,
    "description": "Querying Global Registry",
    "lineNumber": 339
  },
  {
    "__docId__": 880,
    "kind": "testIt",
    "name": "it31",
    "testId": 31,
    "memberof": "test/GraphConnector.spec.js~describe10.describe30",
    "testDepth": 2,
    "static": true,
    "longname": "test/GraphConnector.spec.js~describe10.describe30.it31",
    "access": null,
    "description": "query Global Registry",
    "lineNumber": 345
  },
  {
    "__docId__": 881,
    "kind": "testFile",
    "name": "test/IdentityModule.spec.js",
    "content": "import chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\nimport MessageBus from '../src/bus/MessageBus';\r\n\r\nchai.config.truncateThreshold = 0;\r\n\r\nlet expect = chai.expect;\r\nchai.use(chaiAsPromised);\r\n\r\nimport IdentityModule from '../src/identity/IdentityModule';\r\nimport { runtimeFactory } from './resources/runtimeFactory';\r\n\r\nlet storageManager = runtimeFactory.storageManager();\r\nlet persistenceManager = runtimeFactory.persistenceManager();\r\nlet runtimeURL = 'hyperty-runtime://csp.com/123';\r\n\r\nlet msgbus = {\r\n  postMessage: (msg, callback) => {\r\n    expect(msg).to.eql({\r\n      type: 'create',\r\n      from: 'hyperty-runtime://csp.com/123/idm',\r\n      to: 'hyperty-runtime://csp.com/123/identity-gui',\r\n      body: {value: {identities: [], idps: ['google.com', 'microsoft.com', 'orange.fr']}}\r\n    });\r\n\r\n    callback({\r\n      id: 1, type: 'response', from: 'hyperty-runtime://csp.com/123/identity-gui', to: 'hyperty-runtime://csp.com/123/idm',\r\n      body: {type: 'idp', value: 'google.com', code: 200}\r\n    });\r\n  }\r\n};\r\n\r\nlet identityModule = new IdentityModule(runtimeURL, 'runtimeCapabilities', storageManager);\r\n\r\nidentityModule.messageBus = msgbus;\r\n\r\ndescribe('IdentityModule', function() {\r\n\r\n  describe('constructor()', function() {\r\n\r\n    it('successfully instantiated', function() {\r\n      expect(identityModule).to.be.instanceof(IdentityModule);\r\n    });\r\n  });\r\n\r\n  describe('getIdentitiesToChoose()', function() {\r\n\r\n    //not expected to have initially an identity registered\r\n    let expectedInfo = {\r\n      identities: [],\r\n      idps: [{ domain: 'google.com', type: 'idToken' },\r\n            { domain: 'microsoft.com', type: 'idToken' },\r\n            { domain: 'orange.fr', type: 'idToken' },\r\n            { domain: 'slack.com', type: 'Legacy' }]\r\n    };\r\n\r\n    it('should return a list of IdPs and a list of identities previously registered', () => {\r\n      expect(identityModule.getIdentitiesToChoose()).to.be.eql(expectedInfo);\r\n    });\r\n  });\r\n\r\n  /*describe('requestIdentityToGUI(identities, idps)', () => {\r\n\r\n    let idInfo = identityModule.getIdentitiesToChoose();\r\n\r\n    // the fake gui, will choose the first idp on the list\r\n    let expectedValue = {type: 'idp', value: 'google.com'};\r\n\r\n    it('should return the first idp on the list', (done) => {\r\n\r\n      expect(identityModule.requestIdentityToGUI(idInfo.identities, idInfo.idps).then((value) => {\r\n        return value;\r\n      })).to.be.fulfilled.and.eventually.to.be.eql(expectedValue).and.notify(done);\r\n    });\r\n\r\n  });*/\r\n\r\n  //TODO complete with encryptMessage() and decryptMessage()\r\n  /*describe('encryptMessage()', function() {\r\n\r\n    it('successfully instantiated', function() {\r\n      expect(identityModule).to.be.instanceof(IdentityModule);\r\n    });\r\n  });*/\r\n});\r\n",
    "static": true,
    "longname": "test/IdentityModule.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 882,
    "kind": "testDescribe",
    "name": "describe32",
    "testId": 32,
    "memberof": "test/IdentityModule.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/IdentityModule.spec.js~describe32",
    "access": null,
    "description": "IdentityModule",
    "lineNumber": 37
  },
  {
    "__docId__": 883,
    "kind": "testDescribe",
    "name": "describe33",
    "testId": 33,
    "memberof": "test/IdentityModule.spec.js~describe32",
    "testDepth": 1,
    "static": true,
    "longname": "test/IdentityModule.spec.js~describe32.describe33",
    "access": null,
    "description": "constructor()",
    "lineNumber": 39
  },
  {
    "__docId__": 884,
    "kind": "testIt",
    "name": "it34",
    "testId": 34,
    "memberof": "test/IdentityModule.spec.js~describe32.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/IdentityModule.spec.js~describe32.describe33.it34",
    "access": null,
    "description": "successfully instantiated",
    "lineNumber": 41
  },
  {
    "__docId__": 885,
    "kind": "testDescribe",
    "name": "describe35",
    "testId": 35,
    "memberof": "test/IdentityModule.spec.js~describe32",
    "testDepth": 1,
    "static": true,
    "longname": "test/IdentityModule.spec.js~describe32.describe35",
    "access": null,
    "description": "getIdentitiesToChoose()",
    "lineNumber": 46
  },
  {
    "__docId__": 886,
    "kind": "testIt",
    "name": "it36",
    "testId": 36,
    "memberof": "test/IdentityModule.spec.js~describe32.describe35",
    "testDepth": 2,
    "static": true,
    "longname": "test/IdentityModule.spec.js~describe32.describe35.it36",
    "access": null,
    "description": "should return a list of IdPs and a list of identities previously registered",
    "lineNumber": 57
  },
  {
    "__docId__": 887,
    "kind": "testFile",
    "name": "test/MessageBus.spec.js",
    "content": "import chai from 'chai';\r\nimport MessageBus from '../src/bus/MessageBus';\r\n\r\nlet expect = chai.expect;\r\n\r\ndescribe('MessageBus', function() {\r\n  it('sending message', function(done) {\r\n    let msgResult;\r\n\r\n    let mockRegistry = {\r\n      resolve(url) {\r\n        return new Promise((resolve) => {\r\n          //resolve to the same URL\r\n          resolve(url);\r\n        });\r\n      }\r\n    };\r\n\r\n    let msgBus = new MessageBus(mockRegistry);\r\n    msgBus.addListener('hyper-2', (msg) => {\r\n      msgResult = msg;\r\n    });\r\n\r\n    msgBus.postMessage({\r\n      from: 'hyper-1', to: 'hyper-2',\r\n      body: {value: 'x'}\r\n    });\r\n\r\n    setTimeout(() => {\r\n      expect(msgResult).to.eql({\r\n        id: 1, from: 'hyper-1', to: 'hyper-2',\r\n        body: {value: 'x'}\r\n      });\r\n\r\n      done();\r\n    });\r\n  });\r\n\r\n  it('pipeline msg change', function(done) {\r\n    let mBus = new MessageBus();\r\n    mBus.pipeline.handlers = [\r\n      function(ctx) {\r\n        ctx.msg.token = '12345678';\r\n        ctx.next();\r\n      }\r\n    ];\r\n\r\n    mBus.addListener('hyper-2', (msg) => {\r\n      expect(msg).to.eql({ id: 1, type: 'ping', token: '12345678', from: 'hyper-1', to: 'hyper-2' });\r\n      done();\r\n    });\r\n\r\n    mBus.postMessage({ type: 'ping', from: 'hyper-1', to: 'hyper-2' });\r\n  });\r\n\r\n  it('sending using external system', function(done) {\r\n    let msgResult;\r\n\r\n    let mockRegistry = {\r\n      resolve() {\r\n        return new Promise((resolve) => {\r\n          //resolve to default\r\n          resolve('protostub');\r\n        });\r\n      }\r\n    };\r\n\r\n    let msgBus = new MessageBus(mockRegistry);\r\n    msgBus.addListener('protostub', (msg) => {\r\n      msgResult = msg;\r\n    });\r\n\r\n    msgBus.postMessage({\r\n      from: 'hyper-1', to: 'hyper-2/other',\r\n      body: {value: 'x'}\r\n    });\r\n\r\n    setTimeout(() => {\r\n      expect(msgResult).to.eql({\r\n        id: 1, from: 'hyper-1', to: 'hyper-2/other',\r\n        body: {value: 'x'}\r\n      });\r\n\r\n      done();\r\n    });\r\n\r\n  });\r\n\r\n  it('publish unique messages', function(done) {\r\n    let result = { obj1: 0, obj2: 0 };\r\n\r\n    let msgBus = new MessageBus();\r\n    msgBus._onPostMessage = (msg) => {\r\n      console.log(msg);\r\n      result[msg.to]++;\r\n    };\r\n\r\n    msgBus.addPublish('obj1');\r\n    msgBus.addPublish('obj1'); //repeated route ignored\r\n    msgBus.addPublish('obj2');\r\n\r\n    setTimeout(() => {\r\n      msgBus.postMessage({ from: 'x', to: 'obj1' });\r\n      msgBus.postMessage({ from: 'x', to: 'obj2' });\r\n      msgBus.postMessage({ from: 'x', to: 'obj2' });\r\n\r\n      setTimeout(() => {\r\n        expect(result).to.eql({ obj1: 1, obj2: 2 });\r\n        done();\r\n      });\r\n    });\r\n  });\r\n});\r\n",
    "static": true,
    "longname": "test/MessageBus.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 888,
    "kind": "testDescribe",
    "name": "describe37",
    "testId": 37,
    "memberof": "test/MessageBus.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/MessageBus.spec.js~describe37",
    "access": null,
    "description": "MessageBus",
    "lineNumber": 6
  },
  {
    "__docId__": 889,
    "kind": "testIt",
    "name": "it38",
    "testId": 38,
    "memberof": "test/MessageBus.spec.js~describe37",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageBus.spec.js~describe37.it38",
    "access": null,
    "description": "sending message",
    "lineNumber": 7
  },
  {
    "__docId__": 890,
    "kind": "testIt",
    "name": "it39",
    "testId": 39,
    "memberof": "test/MessageBus.spec.js~describe37",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageBus.spec.js~describe37.it39",
    "access": null,
    "description": "pipeline msg change",
    "lineNumber": 39
  },
  {
    "__docId__": 891,
    "kind": "testIt",
    "name": "it40",
    "testId": 40,
    "memberof": "test/MessageBus.spec.js~describe37",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageBus.spec.js~describe37.it40",
    "access": null,
    "description": "sending using external system",
    "lineNumber": 56
  },
  {
    "__docId__": 892,
    "kind": "testIt",
    "name": "it41",
    "testId": 41,
    "memberof": "test/MessageBus.spec.js~describe37",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageBus.spec.js~describe37.it41",
    "access": null,
    "description": "publish unique messages",
    "lineNumber": 89
  },
  {
    "__docId__": 893,
    "kind": "testFile",
    "name": "test/MiniBus.spec.js",
    "content": "import chai from 'chai';\r\nimport MiniBus from '../src/bus/MiniBus';\r\n\r\nlet expect = chai.expect;\r\n\r\ndescribe('MiniBus', function() {\r\n  it('simple sending message', function(done) {\r\n    let mBus = new MiniBus();\r\n    mBus._onPostMessage = (msg) => {\r\n      expect(msg).to.eql({\r\n        id: 1, type: 'test', from: 'hyper-1', to: 'hyper-2',\r\n        body: {value: 'x'}\r\n      });\r\n\r\n      done();\r\n    };\r\n\r\n    mBus.postMessage({\r\n      type: 'test', from: 'hyper-1', to: 'hyper-2',\r\n      body: {value: 'x'}\r\n    });\r\n  });\r\n\r\n  it('send with external response', function(done) {\r\n    this.timeout(4000);\r\n    let msgResult = {};\r\n\r\n    let mBus = new MiniBus();\r\n    mBus.addListener('hyper-1', (msg) => {\r\n      msgResult = msg;\r\n    });\r\n\r\n    mBus._onPostMessage = (msg) => {\r\n      expect(msg).to.eql({\r\n        id: 1, type: 'test', from: 'hyper-1', to: 'hyper-2',\r\n        body: {value: 'x'}\r\n      });\r\n\r\n      mBus._onMessage({\r\n        id: 1, type: 'response', from: 'hyper-2', to: 'hyper-1',\r\n        body: {value: 'y'}\r\n      });\r\n    };\r\n\r\n    mBus.postMessage({\r\n      type: 'test', from: 'hyper-1', to: 'hyper-2',\r\n      body: {value: 'x'}\r\n    }, (response) => {\r\n      expect(response).to.eql({\r\n        id: 1, type: 'response', from: 'hyper-2', to: 'hyper-1',\r\n        body: {value: 'y'}\r\n      });\r\n\r\n      setTimeout(() => {\r\n        //expect not to enter in the hyper-1 listener\r\n        expect(msgResult).to.be.empty;\r\n        done();\r\n      });\r\n    });\r\n  });\r\n\r\n  it('send and publish', function(done) {\r\n    let mBus = new MiniBus();\r\n    let msgResult = {};\r\n\r\n    let defaultListener = false;\r\n    let hyper2Listener = false;\r\n    let objListener = false;\r\n\r\n    mBus.addListener('*', (msg) => {\r\n      msgResult = msg;\r\n      defaultListener = true;\r\n    });\r\n\r\n    mBus.addListener('hyperty://hyper-2', (msg) => {\r\n      msgResult = msg;\r\n      hyper2Listener = true;\r\n    });\r\n\r\n    mBus.addListener('resource://fake-url', (msg) => {\r\n      msgResult = msg;\r\n      objListener = true;\r\n    });\r\n\r\n    //simulate message from MessageBus core\r\n    mBus._onMessage({\r\n      id: 1, type: 'send', from: 'hyperty://hyper-1', to: 'hyperty://hyper-2',\r\n      body: {value: 'x'}\r\n    });\r\n\r\n    setTimeout(() => {\r\n      //should be only received in the hyperty listener\r\n      expect(defaultListener).to.eql(false);\r\n      expect(hyper2Listener).to.eql(true);\r\n      expect(msgResult).to.eql({\r\n        id: 1, type: 'send', from: 'hyperty://hyper-1', to: 'hyperty://hyper-2',\r\n        body: {value: 'x'}\r\n      });\r\n\r\n      //simulate message from MessageBus core\r\n      mBus._onMessage({\r\n        id: 2, type: 'publish', from: 'hyperty://hyper-1', to: 'resource://fake-url',\r\n        body: {value: 'x'}\r\n      });\r\n\r\n      setTimeout(() => {\r\n        //should be received in default and object listener\r\n        expect(defaultListener).to.eql(true);\r\n        expect(objListener).to.eql(true);\r\n        expect(msgResult).to.eql({\r\n          id: 2, type: 'publish', from: 'hyperty://hyper-1', to: 'resource://fake-url',\r\n          body: {value: 'x'}\r\n        });\r\n        done();\r\n      });\r\n    });\r\n  });\r\n});\r\n",
    "static": true,
    "longname": "test/MiniBus.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 894,
    "kind": "testDescribe",
    "name": "describe42",
    "testId": 42,
    "memberof": "test/MiniBus.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/MiniBus.spec.js~describe42",
    "access": null,
    "description": "MiniBus",
    "lineNumber": 6
  },
  {
    "__docId__": 895,
    "kind": "testIt",
    "name": "it43",
    "testId": 43,
    "memberof": "test/MiniBus.spec.js~describe42",
    "testDepth": 1,
    "static": true,
    "longname": "test/MiniBus.spec.js~describe42.it43",
    "access": null,
    "description": "simple sending message",
    "lineNumber": 7
  },
  {
    "__docId__": 896,
    "kind": "testIt",
    "name": "it44",
    "testId": 44,
    "memberof": "test/MiniBus.spec.js~describe42",
    "testDepth": 1,
    "static": true,
    "longname": "test/MiniBus.spec.js~describe42.it44",
    "access": null,
    "description": "send with external response",
    "lineNumber": 24
  },
  {
    "__docId__": 897,
    "kind": "testIt",
    "name": "it45",
    "testId": 45,
    "memberof": "test/MiniBus.spec.js~describe42",
    "testDepth": 1,
    "static": true,
    "longname": "test/MiniBus.spec.js~describe42.it45",
    "access": null,
    "description": "send and publish",
    "lineNumber": 62
  },
  {
    "__docId__": 898,
    "kind": "testFile",
    "name": "test/PersistenceManager.spec.js",
    "content": "import chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\nimport PersistenceManager from 'service-framework/dist/PersistenceManager';\r\n\r\nlet expect = chai.expect;\r\nlet localStorage = window.localStorage\r\n\r\ndescribe('PersistenceManager', function() {\r\n  let persistenceManager = new PersistenceManager(localStorage);\r\n\r\n    describe('set', function(){\r\n        it('should set the value for a given key-version tuple', function(){\r\n            persistenceManager.set('key', 'v1.0.0', {})\r\n\r\n            expect(localStorage.getItem('key')).to.exist\r\n        })\r\n    })\r\n\r\n    describe('get', function(){\r\n        it('should get the value for a given key', function(){\r\n            persistenceManager.set('key', 'v1.0.0', {})\r\n\r\n            expect(persistenceManager.get('key')).to.be.eql({})\r\n        })\r\n    })\r\n\r\n    describe('getVersion', function(){\r\n        it('should get the value version for a given key', function(){\r\n            persistenceManager.set('key', 'v1.0.0', {})\r\n\r\n            expect(persistenceManager.getVersion('key')).to.be.equal('v1.0.0')\r\n        })\r\n    })\r\n\r\n    describe('delete', function(){\r\n        it('should remove a value from PersistenceManager for a given key', function(){\r\n            localStorage.setItem('key', '{}')\r\n\r\n            persistenceManager.delete('key')\r\n\r\n            expect(localStorage.getItem('key')).to.be.a('null')\r\n        })\r\n    })\r\n})\r\n",
    "static": true,
    "longname": "test/PersistenceManager.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 899,
    "kind": "testDescribe",
    "name": "describe46",
    "testId": 46,
    "memberof": "test/PersistenceManager.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/PersistenceManager.spec.js~describe46",
    "access": null,
    "description": "PersistenceManager",
    "lineNumber": 8
  },
  {
    "__docId__": 900,
    "kind": "testDescribe",
    "name": "describe47",
    "testId": 47,
    "memberof": "test/PersistenceManager.spec.js~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "test/PersistenceManager.spec.js~describe46.describe47",
    "access": null,
    "description": "set",
    "lineNumber": 11
  },
  {
    "__docId__": 901,
    "kind": "testIt",
    "name": "it48",
    "testId": 48,
    "memberof": "test/PersistenceManager.spec.js~describe46.describe47",
    "testDepth": 2,
    "static": true,
    "longname": "test/PersistenceManager.spec.js~describe46.describe47.it48",
    "access": null,
    "description": "should set the value for a given key-version tuple",
    "lineNumber": 12
  },
  {
    "__docId__": 902,
    "kind": "testDescribe",
    "name": "describe49",
    "testId": 49,
    "memberof": "test/PersistenceManager.spec.js~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "test/PersistenceManager.spec.js~describe46.describe49",
    "access": null,
    "description": "get",
    "lineNumber": 19
  },
  {
    "__docId__": 903,
    "kind": "testIt",
    "name": "it50",
    "testId": 50,
    "memberof": "test/PersistenceManager.spec.js~describe46.describe49",
    "testDepth": 2,
    "static": true,
    "longname": "test/PersistenceManager.spec.js~describe46.describe49.it50",
    "access": null,
    "description": "should get the value for a given key",
    "lineNumber": 20
  },
  {
    "__docId__": 904,
    "kind": "testDescribe",
    "name": "describe51",
    "testId": 51,
    "memberof": "test/PersistenceManager.spec.js~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "test/PersistenceManager.spec.js~describe46.describe51",
    "access": null,
    "description": "getVersion",
    "lineNumber": 27
  },
  {
    "__docId__": 905,
    "kind": "testIt",
    "name": "it52",
    "testId": 52,
    "memberof": "test/PersistenceManager.spec.js~describe46.describe51",
    "testDepth": 2,
    "static": true,
    "longname": "test/PersistenceManager.spec.js~describe46.describe51.it52",
    "access": null,
    "description": "should get the value version for a given key",
    "lineNumber": 28
  },
  {
    "__docId__": 906,
    "kind": "testDescribe",
    "name": "describe53",
    "testId": 53,
    "memberof": "test/PersistenceManager.spec.js~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "test/PersistenceManager.spec.js~describe46.describe53",
    "access": null,
    "description": "delete",
    "lineNumber": 35
  },
  {
    "__docId__": 907,
    "kind": "testIt",
    "name": "it54",
    "testId": 54,
    "memberof": "test/PersistenceManager.spec.js~describe46.describe53",
    "testDepth": 2,
    "static": true,
    "longname": "test/PersistenceManager.spec.js~describe46.describe53.it54",
    "access": null,
    "description": "should remove a value from PersistenceManager for a given key",
    "lineNumber": 36
  },
  {
    "__docId__": 908,
    "kind": "testFile",
    "name": "test/Pipeline.spec.js",
    "content": "import chai from 'chai';\r\nimport Pipeline from '../src/bus/Pipeline';\r\n\r\nlet expect = chai.expect;\r\n\r\ndescribe('Pipeline', function() {\r\n  it('fail detected', function() {\r\n    var errorResult = 'none';\r\n    var msgResult;\r\n\r\n    let pipeline = new Pipeline((error) => {\r\n      errorResult = error;\r\n    });\r\n\r\n    pipeline.handlers = [\r\n      function(ctx) {\r\n        ctx.msg.value++;\r\n        msgResult = ctx.msg;\r\n        ctx.fail('error-msg');\r\n      },\r\n\r\n      function(ctx) {\r\n        ctx.msg.value++;\r\n        ctx.next();\r\n      }\r\n    ];\r\n\r\n    pipeline.process({id: 1, value: 0}, (msg) => {\r\n      msg.result = 'OK';\r\n      msgResult = msg;\r\n    });\r\n\r\n    expect({id: 1, value: 1}).to.eql(msgResult);\r\n    expect('error-msg').to.eql(errorResult);\r\n  });\r\n\r\n  it('deliver detected', function() {\r\n    var errorResult = 'none';\r\n    var msgResult;\r\n\r\n    let pipeline = new Pipeline((error) => {\r\n      errorResult = error;\r\n    });\r\n\r\n    pipeline.handlers = [\r\n      function(ctx) {\r\n        ctx.msg.value++;\r\n        ctx.deliver();\r\n      },\r\n\r\n      function(ctx) {\r\n        ctx.msg.value++;\r\n        ctx.next();\r\n      }\r\n    ];\r\n\r\n    pipeline.process({id: 1, value: 0}, (msg) => {\r\n      msg.result = 'OK';\r\n      msgResult = msg;\r\n    });\r\n\r\n    expect({id: 1, value: 1, result: 'OK'}).to.eql(msgResult);\r\n    expect('none').to.eql(errorResult);\r\n  });\r\n\r\n  it('sequence processor', function() {\r\n    var errorResult = 'none';\r\n    var msgResult;\r\n\r\n    let pipeline = new Pipeline((error) => {\r\n      errorResult = error;\r\n    });\r\n\r\n    pipeline.handlers = [\r\n      function(ctx) {\r\n        ctx.msg.value++;\r\n        ctx.next();\r\n      },\r\n\r\n      function(ctx) {\r\n        ctx.msg.value++;\r\n        ctx.next();\r\n      }\r\n    ];\r\n\r\n    pipeline.process({id: 1, value: 0}, (msg) => {\r\n      msg.result = 'OK';\r\n      msgResult = msg;\r\n    });\r\n\r\n    expect({id: 1, value: 2, result: 'OK'}).to.eql(msgResult);\r\n    expect('none').to.eql(errorResult);\r\n  });\r\n\r\n});\r\n",
    "static": true,
    "longname": "test/Pipeline.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 909,
    "kind": "testDescribe",
    "name": "describe55",
    "testId": 55,
    "memberof": "test/Pipeline.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/Pipeline.spec.js~describe55",
    "access": null,
    "description": "Pipeline",
    "lineNumber": 6
  },
  {
    "__docId__": 910,
    "kind": "testIt",
    "name": "it56",
    "testId": 56,
    "memberof": "test/Pipeline.spec.js~describe55",
    "testDepth": 1,
    "static": true,
    "longname": "test/Pipeline.spec.js~describe55.it56",
    "access": null,
    "description": "fail detected",
    "lineNumber": 7
  },
  {
    "__docId__": 911,
    "kind": "testIt",
    "name": "it57",
    "testId": 57,
    "memberof": "test/Pipeline.spec.js~describe55",
    "testDepth": 1,
    "static": true,
    "longname": "test/Pipeline.spec.js~describe55.it57",
    "access": null,
    "description": "deliver detected",
    "lineNumber": 37
  },
  {
    "__docId__": 912,
    "kind": "testIt",
    "name": "it58",
    "testId": 58,
    "memberof": "test/Pipeline.spec.js~describe55",
    "testDepth": 1,
    "static": true,
    "longname": "test/Pipeline.spec.js~describe55.it58",
    "access": null,
    "description": "sequence processor",
    "lineNumber": 66
  },
  {
    "__docId__": 913,
    "kind": "testFile",
    "name": "test/PolicyEngine.spec.js",
    "content": "import chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\n\r\nchai.config.truncateThreshold = 0;\r\n\r\nlet expect = chai.expect;\r\nchai.use(chaiAsPromised);\r\n\r\nimport AdvancedCondition from '../src/policy/conditions/AdvancedCondition';\r\nimport AllowOverrides from '../src/policy/combiningAlgorithms/AllowOverrides';\r\nimport Condition from '../src/policy/conditions/Condition';\r\nimport PEP from '../src/policy/PEP';\r\nimport Rule from '../src/policy/Rule';\r\nimport RuntimeCoreCtx from '../src/policy/context/RuntimeCoreCtx';\r\nimport Policy from '../src/policy/Policy';\r\nimport SubscriptionCondition from '../src/policy/conditions/SubscriptionCondition';\r\nimport { runtimeFactory } from './resources/runtimeFactory';\r\n\r\n/********** CONDITIONS **********/\r\nlet simpleCondition = new Condition('source', 'equals', 'user1@domain1');\r\nlet andCondition = new AdvancedCondition(['and', new Condition('source', 'equals', 'user1@domain1'), new Condition('domain', 'equals', 'domain1')]);\r\nlet orCondition = new AdvancedCondition(['or', new Condition('source', 'equals', 'user1@domain1'), new Condition('domain', 'equals', 'domain1')]);\r\nlet notCondition = new AdvancedCondition(['not', new Condition('source', 'equals', 'user2@domain2')]);\r\nlet andNotCondition = new AdvancedCondition(['and', new Condition('source', 'equals', 'user1@domain1'), ['not', new Condition('domain', 'equals', 'domain1')]]);\r\nlet orNotCondition = new AdvancedCondition(['or', ['not', new Condition('domain', 'equals', 'domain1')], new Condition('source', 'equals', 'user1@domain1')]);\r\n\r\n/********** RULES **********/\r\nlet simpleRule = new Rule(false, simpleCondition, 'global', 'global', 0);\r\nlet acceptAnySubscriptionRule = new Rule(true, new SubscriptionCondition('subscription', 'equals', '*'), 'global', 'global', 0);\r\nlet acceptPreAuthSubscriptionRule = new Rule(true, new SubscriptionCondition('subscription', 'in', 'preauthorised'), 'global', 'global', 0);\r\nlet blockAnySubscriptionRule = new Rule(false, new SubscriptionCondition('subscription', 'equals', '*'), 'global', 'global', 0);\r\nlet blockPreAuthSubscriptionRule = new Rule(false, new AdvancedCondition(['not', new SubscriptionCondition('subscription', 'in', 'preauthorised')]), 'global', 'global', 0);\r\nlet schemeRule = new Rule(false, new Condition('scheme', 'equals', 'comm'), 'global', 'global', 0);\r\nlet dateRule = new Rule(false, new Condition('date', 'equals', '01/01/2016'), 'global', 'global', 0);\r\nlet domainRule = new Rule(false, new Condition('domain', 'equals', 'blockedDomain'), 'global', 'global', 0);\r\nlet sourceRule = new Rule(false, new Condition('source', 'equals', 'user@blockedDomain'), 'global', 'global', 0);\r\nlet sourceRuleForConn = new Rule(false, new Condition('source', 'equals', 'user@blockedDomain'), 'hyperty', 'Connector', 0);\r\nlet sourceRuleForUser1 = new Rule(false, new Condition('source', 'equals', 'user@blockedDomain'), 'identity', 'user1@work,', 0);\r\n\r\n/********** POLICIES **********/\r\nlet sourcePolicy = new Policy('HypertyChat', [simpleRule], [], 'allowOverrides');\r\n\r\n/********** MESSAGES **********/\r\nlet messageFromChat = { body: { identity: { userProfile: { username: 'user@blockedDomain' } } }, id: 1, type: 'subscribe', from: 'hyperty://domain/hyperty-123', to: 'hyperty://domain/hyperty-456' };\r\n\r\nlet messageFromConn = { body: { identity: { userProfile: { username: 'user@blockedDomain' } } }, id: 1, type: 'subscribe', from: 'hyperty://domain/hyperty-012', to: 'hyperty://domain/hyperty-789' };\r\n\r\nlet messageFromUser1 = { body: { identity: { userProfile: { username: 'user1@domain1' } } }, id: 1, type: 'subscribe', from: 'scheme://domain/data-object-instance', to: 'comm://domain/data-object-instance' };\r\n\r\nlet messageFromUser2 = { body: { identity: { userProfile: { username: 'user2@domain2' } } }, id: 1, type: 'subscribe', from: 'scheme://domain/data-object-instance', to: 'comm://domain/data-object-instance' };\r\n\r\nlet noIdMessage = { from: 'hyperty://domain/hyperty-url', id: 1, to: 'comm://domain/hyperty-instance', type: 'subscribe' };\r\n\r\nlet message = { body: { auth: false, identity: { userProfile: { username: 'user@domain' } } }, from: 'hyperty://domain/hyperty-url', id: 1, to: 'comm://domain/hyperty-instance', type: 'subscribe' };\r\n\r\nlet messageFromBlocked = { body: { identity: { userProfile: { username: 'user@blockedDomain' } } }, id: 1, type: 'subscribe', from: 'comm://domain/data-object-instance', to: 'comm://domain/hyperty-instance' };\r\n\r\nlet subscribeMessage = { body: { identity: { userProfile: { username: 'user@domain' } }, subscriber: 'hyperty://domain/hyperty-instance' }, id: 1, type: 'subscribe', from: 'runtime://localhost/7600/sm', to: 'comm://domain/data-object-url/subscription' };\r\n\r\nlet allowedSubscribeMessage = { body: { auth: true, identity: { userProfile: { username: 'user@domain' } }, subscriber: 'hyperty://domain/hyperty-instance' }, id: 1, type: 'subscribe', from: 'runtime://localhost/7600/sm', to: 'comm://domain/data-object-url/subscription' };\r\n\r\nlet badSubscribeMessage = { body: { identity: { userProfile: { username: 'user@domain' } }, subscriber: 'hyperty://domain/not-preauthorised-hyperty-instance' }, id: 1, type: 'subscribe', from: 'runtime://localhost/7600/sm', to: 'comm://domain/data-object-url/subscription' };\r\n\r\n/********** TESTS **********/\r\nlet runtimeCapabilities = {\r\n  isAvailable: () => {\r\n    return new Promise((resolve) => {\r\n      resolve(false);\r\n    });\r\n  }\r\n};\r\n\r\nlet runtimeCtx = new RuntimeCoreCtx();\r\n\r\ndescribe('Policies management', () => {\r\n  describe('conditions management', () => {\r\n    it('creates a simple condition', () => {\r\n      expect(simpleCondition.attribute).to.be.eql('source');\r\n      expect(simpleCondition.operator).to.be.eql('equals');\r\n      expect(simpleCondition.params).to.be.eql('user1@domain1');\r\n    });\r\n    it('returns condition is applicable', () => {\r\n      expect(simpleCondition.isApplicable(runtimeCtx, messageFromUser1)).to.be.eql(true);\r\n    });\r\n    it('returns condition is not applicable', () => {\r\n      expect(simpleCondition.isApplicable(runtimeCtx, messageFromUser2)).to.be.eql(false);\r\n    });\r\n\r\n    it('creates an advanced condition - \"and\"', () => {\r\n      expect(andCondition.condition).to.be.eql(['and', new Condition('source', 'equals', 'user1@domain1'), new Condition('domain', 'equals', 'domain1')]);\r\n      expect(andCondition.condition[0]).to.be.eql('and');\r\n      expect(andCondition.condition[1]).to.be.eql(new Condition('source', 'equals', 'user1@domain1'));\r\n      expect(andCondition.condition[2]).to.be.eql(new Condition('domain', 'equals', 'domain1'));\r\n    });\r\n\r\n    it('correctly returns \"and\" condition is applicable', () => {\r\n      expect(andCondition.isApplicable(runtimeCtx, messageFromUser1)).to.be.eql(true);\r\n    });\r\n\r\n    it('correctly returns \"and\" condition is not applicable', () => {\r\n      expect(andCondition.isApplicable(runtimeCtx, messageFromUser2)).to.be.eql(false);\r\n    });\r\n\r\n    it('creates an advanced condition - \"or\"', () => {\r\n      expect(orCondition.condition).to.be.eql(['or', new Condition('source', 'equals', 'user1@domain1'), new Condition('domain', 'equals', 'domain1')]);\r\n    });\r\n\r\n    it('correctly returns \"or\" condition is applicable', () => {\r\n      expect(orCondition.isApplicable(runtimeCtx, messageFromUser1)).to.be.eql(true);\r\n    });\r\n\r\n    it('correctly returns \"or\" condition is not applicable', () => {\r\n      expect(orCondition.isApplicable(runtimeCtx, messageFromUser2)).to.be.eql(false);\r\n    });\r\n\r\n    it('creates an advanced condition - \"not\"', () => {\r\n      expect(notCondition.condition).to.be.eql(['not', new Condition('source', 'equals', 'user2@domain2')]);\r\n    });\r\n\r\n    it('correctly returns \"not\" condition is applicable', () => {\r\n      expect(notCondition.isApplicable(runtimeCtx, messageFromUser1)).to.be.eql(true);\r\n    });\r\n\r\n    it('correctly returns \"not\" condition is not applicable', () => {\r\n      expect(notCondition.isApplicable(runtimeCtx, messageFromUser2)).to.be.eql(false);\r\n    });\r\n\r\n    it('correctly returns \"and not\" condition is not applicable', () => {\r\n      expect(andNotCondition.isApplicable(runtimeCtx, messageFromUser1)).to.be.eql(false);\r\n    });\r\n\r\n    it('correctly returns \"or not\" condition is applicable', () => {\r\n      expect(orNotCondition.isApplicable(runtimeCtx, messageFromUser1)).to.be.eql(true);\r\n    });\r\n  });\r\n\r\n  describe('rules management', () => {\r\n    it('creates a simple rule', () => {\r\n      expect(simpleRule.decision).to.be.eql(false);\r\n      expect(simpleRule.condition).to.be.eql(simpleCondition);\r\n      expect(simpleRule.scope).to.be.eql('global');\r\n      expect(simpleRule.target).to.be.eql('global');\r\n    });\r\n    it('evaluates a simple rule to false', () => {\r\n      expect(simpleRule.evaluate(runtimeCtx, messageFromUser1)).to.be.eql(false);\r\n    });\r\n    it('evaluates a simple rule to \"Not Applicable\"', () => {\r\n      expect(simpleRule.evaluate(runtimeCtx, messageFromUser2)).to.be.eql('Not Applicable');\r\n    });\r\n  });\r\n\r\n  describe('policies management', () => {\r\n    it('creates a service provider policy', () => {\r\n      expect(sourcePolicy.key).to.be.eql('HypertyChat');\r\n      expect(sourcePolicy.combiningAlgorithm).to.be.eql(new AllowOverrides());\r\n      expect(sourcePolicy.rules).to.be.eql([simpleRule]);\r\n    });\r\n    it('evaluates a service provider policy to false', () => {\r\n      expect(sourcePolicy.evaluateRules(runtimeCtx, messageFromUser1)).to.be.eql(false);\r\n    });\r\n    it('evaluates a service provider policy to \"Not Applicable\"', () => {\r\n      expect(sourcePolicy.evaluateRules(runtimeCtx, messageFromUser2)).to.be.eql('Not Applicable');\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('Policy Engine with Runtime Core context', () => {\r\n  let runtimeRegistry = {\r\n    isInterworkingProtoStub: () => {\r\n      return false;\r\n    },\r\n    isLocal: () => {\r\n      return true;\r\n    },\r\n    getPreAuthSubscribers: () => {\r\n      return ['hyperty://domain/hyperty-instance'];\r\n    },\r\n    getHypertyName: (hypertyURL) => {\r\n      if (hypertyURL === 'hyperty://domain/hyperty-123') {\r\n        return 'HypertyChat';\r\n      }\r\n      if (hypertyURL === 'hyperty://domain/hyperty-789') {\r\n        return 'Connector';\r\n      }\r\n    },\r\n    getHypertyOwner: () => {\r\n      return 'user://work/user2';\r\n    },\r\n    getReporterURLSynchonous: () => {\r\n      return 'hyperty://domain/hyperty-url';\r\n    },\r\n    getUserEmailFromURL: () => {\r\n      return 'user2@work';\r\n    },\r\n    isDataObjectURL: (dataObjectURL) => {\r\n      let splitURL = dataObjectURL.split('://');\r\n      return splitURL[0] === 'comm';\r\n    },\r\n    registerSubscribedDataObject: () => {},\r\n    registerSubscriber: () => {},\r\n    runtimeURL: 'runtime://localhost/7601'\r\n  };\r\n\r\n  let identityModule = {\r\n    decryptMessage: (message) => {\r\n      return new Promise((resolve) => {\r\n        resolve(message);\r\n      });\r\n    },\r\n    doMutualAuthentication: (message) => {\r\n      return new Promise((resolve) => {\r\n        resolve(message);\r\n      });\r\n    },\r\n    encryptMessage: (message) => {\r\n      return new Promise((resolve) => {\r\n        resolve(message);\r\n      });\r\n    },\r\n    getIdentity: () => {\r\n      return new Promise((resolve) => {\r\n        resolve({ userProfile: {username: 'user@domain' } });\r\n      });\r\n    },\r\n    getToken: () => {\r\n      return new Promise((resolve) => {\r\n        resolve({ userProfile: {username: 'user@domain' } });\r\n      });\r\n    },\r\n    _getHypertyFromDataObject: (dataObjectURL) => {\r\n      return new Promise((resolve) => {\r\n        if (dataObjectURL === 'comm://domain/data-object-url') {\r\n          resolve('hyperty://domain/hyperty-url');\r\n        }\r\n      });\r\n    }\r\n  };\r\n  let storageManager = runtimeFactory.storageManager();\r\n  let policyEngine = new PEP(new RuntimeCoreCtx(identityModule, runtimeRegistry, storageManager, runtimeCapabilities));\r\n\r\n  describe('initial filtering', () => {\r\n    it('message that loads an hyperty should not be validated by policies', () => {\r\n      let loadMessage = { id: 2, from: 'hyperty-runtime://sandbox/external', to: 'hyperty-runtime://sandbox/internal', type: 'create' };\r\n      expect(policyEngine._isToVerify(loadMessage)).to.be.eql(false);\r\n    });\r\n\r\n    /*it('message of the \"update\" type must have the data object\\'s reporter as source', (done) => {\r\n      let updateMessage = { body: { source: 'hyperty://domain/hyperty-url', identity: 'identityToken' }, from: 'comm://domain/data-object-url', id: 3, to: 'comm://domain/data-object-url/changes', type: 'update' };\r\n      expect(policyEngine.authorise(updateMessage).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(updateMessage).and.notify(done);\r\n\r\n      let badUpdateMessage = { body: { source: 'hyperty://domain/hyperty-url2', identity: 'identityToken' }, from: 'comm://domain/data-object-url', id: 3, to: 'comm://domain/data-object-url/changes', type: 'update' };\r\n      expect(policyEngine.authorise(badUpdateMessage).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.rejected.and.notify(done);\r\n    });*/\r\n  });\r\n\r\n  describe('identity obtention', () => {\r\n    it('should add an identity in the message body', (done) => {\r\n      expect(policyEngine.authorise(noIdMessage).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(message).and.notify(done);\r\n    });\r\n\r\n    it('should maintain the identity in the message body', (done) => {\r\n      expect(policyEngine.authorise(message).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(message).and.notify(done);\r\n    });\r\n  });\r\n\r\n  describe('policies management', () => {\r\n    policyEngine.removePolicy('*');\r\n\r\n    it('adds a service provider policy to the engine', () => {\r\n      policyEngine.context.activeUserPolicy = undefined;\r\n      policyEngine.addPolicy('SERVICE_PROVIDER', 'HypertyChat', sourcePolicy);\r\n      console.log('policyEngine.context.serviceProviderPolicy');\r\n      console.log(policyEngine.context.serviceProviderPolicy);\r\n      expect(policyEngine.context.serviceProviderPolicy).to.be.eql({HypertyChat: new Policy('HypertyChat', [simpleRule], [])});\r\n      expect(policyEngine.context.serviceProviderPolicy.HypertyChat).to.be.eql(new Policy('HypertyChat', [simpleRule], []));\r\n      expect(policyEngine.context.serviceProviderPolicy.HypertyChat.actions).to.be.eql([]);\r\n      expect(policyEngine.context.serviceProviderPolicy.HypertyChat.rules).to.be.eql([simpleRule]);\r\n    });\r\n\r\n    it('adds a user policy to the engine', () => {\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [dateRule], []));\r\n      expect(policyEngine.context.userPolicies).to.be.eql({'My policy': new Policy('My policy', [dateRule], [])});\r\n      expect(policyEngine.context.userPolicies['My policy']).to.be.eql(new Policy('My policy', [dateRule], []));\r\n      expect(policyEngine.context.userPolicies['My policy'].actions).to.be.eql([]);\r\n      expect(policyEngine.context.userPolicies['My policy'].rules).to.be.eql([dateRule]);\r\n    });\r\n\r\n    it('adds a second user policy to the engine', () => {\r\n      policyEngine.addPolicy('USER', 'My second policy', new Policy('My second policy', [simpleRule], []));\r\n      expect(policyEngine.context.userPolicies).to.be.eql({'My policy': new Policy('My policy', [dateRule], []), 'My second policy': new Policy('My second policy', [simpleRule], [])});\r\n      expect(policyEngine.context.serviceProviderPolicy).to.be.eql({HypertyChat: new Policy('HypertyChat', [simpleRule], [])});\r\n      expect(policyEngine.context.activeUserPolicy).to.be.eql(undefined);\r\n    });\r\n\r\n    it('removes an existing user policy', () => {\r\n      policyEngine.removePolicy('USER', 'My policy');\r\n      expect(policyEngine.context.serviceProviderPolicy).to.be.eql({HypertyChat: new Policy('HypertyChat', [simpleRule], [])});\r\n      expect(policyEngine.context.userPolicies).to.be.eql({'My second policy': new Policy('My second policy', [simpleRule], [])});\r\n      expect(policyEngine.context.activeUserPolicy).to.be.eql(undefined);\r\n    });\r\n\r\n    it('tries to remove a policy that does not exist', () => {\r\n      policyEngine.removePolicy('USER', 'Vacations');\r\n      expect(policyEngine.context.serviceProviderPolicy).to.be.eql({HypertyChat: new Policy('HypertyChat', [simpleRule], [])});\r\n      expect(policyEngine.context.userPolicies).to.be.eql({'My second policy': new Policy('My second policy', [simpleRule], [])});\r\n      expect(policyEngine.context.activeUserPolicy).to.be.eql(undefined);\r\n    });\r\n\r\n    it('removes all policies', () => {\r\n      policyEngine.removePolicy('*');\r\n      expect(policyEngine.context.serviceProviderPolicy).to.be.eql({});\r\n      expect(policyEngine.context.userPolicies).to.be.eql({});\r\n      expect(policyEngine.context.activeUserPolicy).to.be.eql(undefined);\r\n    });\r\n\r\n    it('does not apply rules as it is not its target', (done) => {\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [sourceRuleForConn], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(messageFromChat).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(messageFromChat).and.notify(done);\r\n\r\n      policyEngine.removePolicy('*');\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [sourceRuleForUser1], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(messageFromUser2).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(messageFromChat).and.notify(done);\r\n    });\r\n\r\n    it('applies a rule as it is its target', (done) => {\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [sourceRuleForConn], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(messageFromConn).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.rejected.and.notify(done);\r\n    });\r\n  });\r\n\r\n  describe('functionality: scheme', () => {\r\n    it('rejects the message as it is from a blocked scheme', (done) => {\r\n      policyEngine.removePolicy('*');\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [schemeRule], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(messageFromBlocked).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.rejected.and.notify(done);\r\n    });\r\n\r\n    it('allows the message as it comes from a scheme that is not blocked', (done) => {\r\n      expect(policyEngine.authorise(message).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(message).and.notify(done);\r\n    });\r\n  });\r\n\r\n  describe('functionality: source', () => {\r\n    let sourceRule2 = new Rule(false, new Condition('source', 'in', ['user@blockedDomain']));\r\n    it('rejects the message as it comes from a blocked source', (done) => {\r\n      policyEngine.removePolicy('*');\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [sourceRule2], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(messageFromBlocked).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.rejected.and.notify(done);\r\n    });\r\n\r\n    it('rejects the message as it comes from a blocked source', (done) => {\r\n      policyEngine.removePolicy('*');\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [sourceRule], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(messageFromBlocked).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.rejected.and.notify(done);\r\n    });\r\n\r\n    it('allows the message as it comes from a source that is not blocked', (done) => {\r\n      expect(policyEngine.authorise(message).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(message).and.notify(done);\r\n    });\r\n  });\r\n\r\n  describe('functionality: domain', () => {\r\n    it('rejects the message as it comes from a blocked domain', (done) => {\r\n      policyEngine.removePolicy('*');\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [domainRule], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(messageFromBlocked).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.rejected.and.notify(done);\r\n    });\r\n\r\n    it('allows the message as it comes from a domain that is not blocked', (done) => {\r\n      expect(policyEngine.authorise(message).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(message).and.notify(done);\r\n    });\r\n  });\r\n\r\n  describe('data objects management', () => {\r\n    it('rejects a subscription attempt, as the policy rejects all', (done) => {\r\n      policyEngine.removePolicy('*');\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [blockAnySubscriptionRule], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(subscribeMessage).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.rejected.and.notify(done);\r\n    });\r\n\r\n    it('accepts a subscription attempt, as the policy accepts all', (done) => {\r\n      policyEngine.removePolicy('*');\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [acceptAnySubscriptionRule], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(subscribeMessage).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(allowedSubscribeMessage).and.notify(done);\r\n    });\r\n\r\n    it('accepts a subscription attempt, as the policy accepts preauthorised subscribers and is preauthorised', (done) => {\r\n      policyEngine.removePolicy('*');\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [acceptPreAuthSubscriptionRule], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(subscribeMessage).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.fulfilled.and.eventually.eql(allowedSubscribeMessage).and.notify(done);\r\n    });\r\n\r\n    it('rejects a subscription attempt, as the policy rejects non-preauthorised subscriber and is not preauthorised', (done) => {\r\n      policyEngine.removePolicy('*');\r\n      policyEngine.addPolicy('USER', 'My policy', new Policy('My policy', [blockPreAuthSubscriptionRule], []));\r\n      policyEngine.context.activeUserPolicy = 'My policy';\r\n      expect(policyEngine.authorise(badSubscribeMessage).then((message) => {\r\n        return message;\r\n      }), (error) => {\r\n        return error;\r\n      }).to.be.rejected.and.notify(done);\r\n    });\r\n  });\r\n\r\n  describe('groups management', () => {\r\n    let groups = policyEngine.context.groups;\r\n    for (let i in groups) {\r\n      policyEngine.context.deleteGroup(i);\r\n    }\r\n\r\n    it('creates a group', () => {\r\n      policyEngine.context.createGroup('groupA');\r\n      expect(policyEngine.context.getGroupsNames()).to.be.eql(['groupA']);\r\n    });\r\n\r\n    it('creates a second group', () => {\r\n      policyEngine.context.createGroup('groupB');\r\n      expect(policyEngine.context.getGroupsNames()).to.be.eql(['groupA', 'groupB']);\r\n    });\r\n\r\n    it('adds an email to a group', () => {\r\n      policyEngine.context.addToGroup('groupA', 'user1@domain');\r\n      expect(policyEngine.context.getGroup('groupA')).to.be.eql(['user1@domain']);\r\n    });\r\n\r\n    it('adds a second email to a group', () => {\r\n      policyEngine.context.addToGroup('groupA', 'user2@domain');\r\n      expect(policyEngine.context.getGroup('groupA')).to.be.eql(['user1@domain', 'user2@domain']);\r\n    });\r\n\r\n    it('removes a user from a group', () => {\r\n      policyEngine.context.removeFromGroup('groupA', 'user1@domain');\r\n      expect(policyEngine.context.getGroup('groupA')).to.be.eql(['user2@domain']);\r\n    });\r\n\r\n    it('deletes a group', () => {\r\n      policyEngine.context.deleteGroup('groupA');\r\n      expect(policyEngine.context.getGroup('groupA')).to.be.eql([]);\r\n      expect(policyEngine.context.getGroupsNames()).to.be.eql(['groupB']);\r\n    });\r\n  });\r\n  policyEngine.removePolicy('*');\r\n\r\n});\r\n",
    "static": true,
    "longname": "test/PolicyEngine.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 914,
    "kind": "testDescribe",
    "name": "describe59",
    "testId": 59,
    "memberof": "test/PolicyEngine.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59",
    "access": null,
    "description": "Policies management",
    "lineNumber": 75
  },
  {
    "__docId__": 915,
    "kind": "testDescribe",
    "name": "describe60",
    "testId": 60,
    "memberof": "test/PolicyEngine.spec.js~describe59",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60",
    "access": null,
    "description": "conditions management",
    "lineNumber": 76
  },
  {
    "__docId__": 916,
    "kind": "testIt",
    "name": "it61",
    "testId": 61,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it61",
    "access": null,
    "description": "creates a simple condition",
    "lineNumber": 77
  },
  {
    "__docId__": 917,
    "kind": "testIt",
    "name": "it62",
    "testId": 62,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it62",
    "access": null,
    "description": "returns condition is applicable",
    "lineNumber": 82
  },
  {
    "__docId__": 918,
    "kind": "testIt",
    "name": "it63",
    "testId": 63,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it63",
    "access": null,
    "description": "returns condition is not applicable",
    "lineNumber": 85
  },
  {
    "__docId__": 919,
    "kind": "testIt",
    "name": "it64",
    "testId": 64,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it64",
    "access": null,
    "description": "creates an advanced condition - \"and\"",
    "lineNumber": 89
  },
  {
    "__docId__": 920,
    "kind": "testIt",
    "name": "it65",
    "testId": 65,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it65",
    "access": null,
    "description": "correctly returns \"and\" condition is applicable",
    "lineNumber": 96
  },
  {
    "__docId__": 921,
    "kind": "testIt",
    "name": "it66",
    "testId": 66,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it66",
    "access": null,
    "description": "correctly returns \"and\" condition is not applicable",
    "lineNumber": 100
  },
  {
    "__docId__": 922,
    "kind": "testIt",
    "name": "it67",
    "testId": 67,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it67",
    "access": null,
    "description": "creates an advanced condition - \"or\"",
    "lineNumber": 104
  },
  {
    "__docId__": 923,
    "kind": "testIt",
    "name": "it68",
    "testId": 68,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it68",
    "access": null,
    "description": "correctly returns \"or\" condition is applicable",
    "lineNumber": 108
  },
  {
    "__docId__": 924,
    "kind": "testIt",
    "name": "it69",
    "testId": 69,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it69",
    "access": null,
    "description": "correctly returns \"or\" condition is not applicable",
    "lineNumber": 112
  },
  {
    "__docId__": 925,
    "kind": "testIt",
    "name": "it70",
    "testId": 70,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it70",
    "access": null,
    "description": "creates an advanced condition - \"not\"",
    "lineNumber": 116
  },
  {
    "__docId__": 926,
    "kind": "testIt",
    "name": "it71",
    "testId": 71,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it71",
    "access": null,
    "description": "correctly returns \"not\" condition is applicable",
    "lineNumber": 120
  },
  {
    "__docId__": 927,
    "kind": "testIt",
    "name": "it72",
    "testId": 72,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it72",
    "access": null,
    "description": "correctly returns \"not\" condition is not applicable",
    "lineNumber": 124
  },
  {
    "__docId__": 928,
    "kind": "testIt",
    "name": "it73",
    "testId": 73,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it73",
    "access": null,
    "description": "correctly returns \"and not\" condition is not applicable",
    "lineNumber": 128
  },
  {
    "__docId__": 929,
    "kind": "testIt",
    "name": "it74",
    "testId": 74,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe60.it74",
    "access": null,
    "description": "correctly returns \"or not\" condition is applicable",
    "lineNumber": 132
  },
  {
    "__docId__": 930,
    "kind": "testDescribe",
    "name": "describe75",
    "testId": 75,
    "memberof": "test/PolicyEngine.spec.js~describe59",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe75",
    "access": null,
    "description": "rules management",
    "lineNumber": 137
  },
  {
    "__docId__": 931,
    "kind": "testIt",
    "name": "it76",
    "testId": 76,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe75",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe75.it76",
    "access": null,
    "description": "creates a simple rule",
    "lineNumber": 138
  },
  {
    "__docId__": 932,
    "kind": "testIt",
    "name": "it77",
    "testId": 77,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe75",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe75.it77",
    "access": null,
    "description": "evaluates a simple rule to false",
    "lineNumber": 144
  },
  {
    "__docId__": 933,
    "kind": "testIt",
    "name": "it78",
    "testId": 78,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe75",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe75.it78",
    "access": null,
    "description": "evaluates a simple rule to \"Not Applicable\"",
    "lineNumber": 147
  },
  {
    "__docId__": 934,
    "kind": "testDescribe",
    "name": "describe79",
    "testId": 79,
    "memberof": "test/PolicyEngine.spec.js~describe59",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe79",
    "access": null,
    "description": "policies management",
    "lineNumber": 152
  },
  {
    "__docId__": 935,
    "kind": "testIt",
    "name": "it80",
    "testId": 80,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe79",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe79.it80",
    "access": null,
    "description": "creates a service provider policy",
    "lineNumber": 153
  },
  {
    "__docId__": 936,
    "kind": "testIt",
    "name": "it81",
    "testId": 81,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe79",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe79.it81",
    "access": null,
    "description": "evaluates a service provider policy to false",
    "lineNumber": 158
  },
  {
    "__docId__": 937,
    "kind": "testIt",
    "name": "it82",
    "testId": 82,
    "memberof": "test/PolicyEngine.spec.js~describe59.describe79",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe59.describe79.it82",
    "access": null,
    "description": "evaluates a service provider policy to \"Not Applicable\"",
    "lineNumber": 161
  },
  {
    "__docId__": 938,
    "kind": "testDescribe",
    "name": "describe83",
    "testId": 83,
    "memberof": "test/PolicyEngine.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83",
    "access": null,
    "description": "Policy Engine with Runtime Core context",
    "lineNumber": 167
  },
  {
    "__docId__": 939,
    "kind": "testDescribe",
    "name": "describe84",
    "testId": 84,
    "memberof": "test/PolicyEngine.spec.js~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe84",
    "access": null,
    "description": "initial filtering",
    "lineNumber": 241
  },
  {
    "__docId__": 940,
    "kind": "testIt",
    "name": "it85",
    "testId": 85,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe84.it85",
    "access": null,
    "description": "message that loads an hyperty should not be validated by policies",
    "lineNumber": 242
  },
  {
    "__docId__": 941,
    "kind": "testDescribe",
    "name": "describe86",
    "testId": 86,
    "memberof": "test/PolicyEngine.spec.js~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe86",
    "access": null,
    "description": "identity obtention",
    "lineNumber": 264
  },
  {
    "__docId__": 942,
    "kind": "testIt",
    "name": "it87",
    "testId": 87,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe86",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe86.it87",
    "access": null,
    "description": "should add an identity in the message body",
    "lineNumber": 265
  },
  {
    "__docId__": 943,
    "kind": "testIt",
    "name": "it88",
    "testId": 88,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe86",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe86.it88",
    "access": null,
    "description": "should maintain the identity in the message body",
    "lineNumber": 273
  },
  {
    "__docId__": 944,
    "kind": "testDescribe",
    "name": "describe89",
    "testId": 89,
    "memberof": "test/PolicyEngine.spec.js~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe89",
    "access": null,
    "description": "policies management",
    "lineNumber": 282
  },
  {
    "__docId__": 945,
    "kind": "testIt",
    "name": "it90",
    "testId": 90,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe89",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe89.it90",
    "access": null,
    "description": "adds a service provider policy to the engine",
    "lineNumber": 285
  },
  {
    "__docId__": 946,
    "kind": "testIt",
    "name": "it91",
    "testId": 91,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe89",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe89.it91",
    "access": null,
    "description": "adds a user policy to the engine",
    "lineNumber": 296
  },
  {
    "__docId__": 947,
    "kind": "testIt",
    "name": "it92",
    "testId": 92,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe89",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe89.it92",
    "access": null,
    "description": "adds a second user policy to the engine",
    "lineNumber": 304
  },
  {
    "__docId__": 948,
    "kind": "testIt",
    "name": "it93",
    "testId": 93,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe89",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe89.it93",
    "access": null,
    "description": "removes an existing user policy",
    "lineNumber": 311
  },
  {
    "__docId__": 949,
    "kind": "testIt",
    "name": "it94",
    "testId": 94,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe89",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe89.it94",
    "access": null,
    "description": "tries to remove a policy that does not exist",
    "lineNumber": 318
  },
  {
    "__docId__": 950,
    "kind": "testIt",
    "name": "it95",
    "testId": 95,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe89",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe89.it95",
    "access": null,
    "description": "removes all policies",
    "lineNumber": 325
  },
  {
    "__docId__": 951,
    "kind": "testIt",
    "name": "it96",
    "testId": 96,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe89",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe89.it96",
    "access": null,
    "description": "does not apply rules as it is not its target",
    "lineNumber": 332
  },
  {
    "__docId__": 952,
    "kind": "testIt",
    "name": "it97",
    "testId": 97,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe89",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe89.it97",
    "access": null,
    "description": "applies a rule as it is its target",
    "lineNumber": 351
  },
  {
    "__docId__": 953,
    "kind": "testDescribe",
    "name": "describe98",
    "testId": 98,
    "memberof": "test/PolicyEngine.spec.js~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe98",
    "access": null,
    "description": "functionality: scheme",
    "lineNumber": 362
  },
  {
    "__docId__": 954,
    "kind": "testIt",
    "name": "it99",
    "testId": 99,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe98",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe98.it99",
    "access": null,
    "description": "rejects the message as it is from a blocked scheme",
    "lineNumber": 363
  },
  {
    "__docId__": 955,
    "kind": "testIt",
    "name": "it100",
    "testId": 100,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe98",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe98.it100",
    "access": null,
    "description": "allows the message as it comes from a scheme that is not blocked",
    "lineNumber": 374
  },
  {
    "__docId__": 956,
    "kind": "testDescribe",
    "name": "describe101",
    "testId": 101,
    "memberof": "test/PolicyEngine.spec.js~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe101",
    "access": null,
    "description": "functionality: source",
    "lineNumber": 383
  },
  {
    "__docId__": 957,
    "kind": "testIt",
    "name": "it102",
    "testId": 102,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe101",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe101.it102",
    "access": null,
    "description": "rejects the message as it comes from a blocked source",
    "lineNumber": 385
  },
  {
    "__docId__": 958,
    "kind": "testIt",
    "name": "it103",
    "testId": 103,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe101",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe101.it103",
    "access": null,
    "description": "rejects the message as it comes from a blocked source",
    "lineNumber": 396
  },
  {
    "__docId__": 959,
    "kind": "testIt",
    "name": "it104",
    "testId": 104,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe101",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe101.it104",
    "access": null,
    "description": "allows the message as it comes from a source that is not blocked",
    "lineNumber": 407
  },
  {
    "__docId__": 960,
    "kind": "testDescribe",
    "name": "describe105",
    "testId": 105,
    "memberof": "test/PolicyEngine.spec.js~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe105",
    "access": null,
    "description": "functionality: domain",
    "lineNumber": 416
  },
  {
    "__docId__": 961,
    "kind": "testIt",
    "name": "it106",
    "testId": 106,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe105",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe105.it106",
    "access": null,
    "description": "rejects the message as it comes from a blocked domain",
    "lineNumber": 417
  },
  {
    "__docId__": 962,
    "kind": "testIt",
    "name": "it107",
    "testId": 107,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe105",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe105.it107",
    "access": null,
    "description": "allows the message as it comes from a domain that is not blocked",
    "lineNumber": 428
  },
  {
    "__docId__": 963,
    "kind": "testDescribe",
    "name": "describe108",
    "testId": 108,
    "memberof": "test/PolicyEngine.spec.js~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe108",
    "access": null,
    "description": "data objects management",
    "lineNumber": 437
  },
  {
    "__docId__": 964,
    "kind": "testIt",
    "name": "it109",
    "testId": 109,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe108",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe108.it109",
    "access": null,
    "description": "rejects a subscription attempt, as the policy rejects all",
    "lineNumber": 438
  },
  {
    "__docId__": 965,
    "kind": "testIt",
    "name": "it110",
    "testId": 110,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe108",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe108.it110",
    "access": null,
    "description": "accepts a subscription attempt, as the policy accepts all",
    "lineNumber": 449
  },
  {
    "__docId__": 966,
    "kind": "testIt",
    "name": "it111",
    "testId": 111,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe108",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe108.it111",
    "access": null,
    "description": "accepts a subscription attempt, as the policy accepts preauthorised subscribers and is preauthorised",
    "lineNumber": 460
  },
  {
    "__docId__": 967,
    "kind": "testIt",
    "name": "it112",
    "testId": 112,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe108",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe108.it112",
    "access": null,
    "description": "rejects a subscription attempt, as the policy rejects non-preauthorised subscriber and is not preauthorised",
    "lineNumber": 471
  },
  {
    "__docId__": 968,
    "kind": "testDescribe",
    "name": "describe113",
    "testId": 113,
    "memberof": "test/PolicyEngine.spec.js~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe113",
    "access": null,
    "description": "groups management",
    "lineNumber": 483
  },
  {
    "__docId__": 969,
    "kind": "testIt",
    "name": "it114",
    "testId": 114,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe113",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe113.it114",
    "access": null,
    "description": "creates a group",
    "lineNumber": 489
  },
  {
    "__docId__": 970,
    "kind": "testIt",
    "name": "it115",
    "testId": 115,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe113",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe113.it115",
    "access": null,
    "description": "creates a second group",
    "lineNumber": 494
  },
  {
    "__docId__": 971,
    "kind": "testIt",
    "name": "it116",
    "testId": 116,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe113",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe113.it116",
    "access": null,
    "description": "adds an email to a group",
    "lineNumber": 499
  },
  {
    "__docId__": 972,
    "kind": "testIt",
    "name": "it117",
    "testId": 117,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe113",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe113.it117",
    "access": null,
    "description": "adds a second email to a group",
    "lineNumber": 504
  },
  {
    "__docId__": 973,
    "kind": "testIt",
    "name": "it118",
    "testId": 118,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe113",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe113.it118",
    "access": null,
    "description": "removes a user from a group",
    "lineNumber": 509
  },
  {
    "__docId__": 974,
    "kind": "testIt",
    "name": "it119",
    "testId": 119,
    "memberof": "test/PolicyEngine.spec.js~describe83.describe113",
    "testDepth": 2,
    "static": true,
    "longname": "test/PolicyEngine.spec.js~describe83.describe113.it119",
    "access": null,
    "description": "deletes a group",
    "lineNumber": 514
  },
  {
    "__docId__": 975,
    "kind": "testFile",
    "name": "test/Registry.spec.js",
    "content": "import chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\nimport sinonChai from 'sinon-chai';\r\n\r\nchai.config.truncateThreshold = 0;\r\n\r\nlet expect = chai.expect;\r\n\r\nchai.use(chaiAsPromised);\r\nchai.use(sinonChai);\r\n\r\n// Main dependecies\r\nimport Registry from '../src/registry/Registry';\r\nimport Sandbox from '../src/sandbox/Sandbox';\r\nimport MessageBus from '../src/bus/MessageBus';\r\nimport Loader from '../src/runtime/Loader';\r\nimport Descriptors from '../src/runtime/Descriptors';\r\nimport { descriptors } from './resources/descriptors';\r\nimport {divideURL} from '../src/utils/utils';\r\nimport { runtimeFactory } from './resources/runtimeFactory';\r\n\r\nimport AddressAllocation from '../src/allocation/AddressAllocation';\r\n\r\n// Testing Registry\r\nlet runtimeURL = 'hyperty-runtime://ua.pt/123';\r\n\r\nlet storageManager = runtimeFactory.storageManager();\r\nlet appSandbox = runtimeFactory.createAppSandbox();\r\nlet sandboxDummy = {sandbox: 'sandbox', type: 'normal'};\r\nlet protostubURL = 'url';\r\n\r\n//registry = new Registry(msgbus, runtimeURL, appSandbox);\r\ndescribe('Registry', function() {\r\n\r\n  let registry;\r\n\r\n  before(() => {\r\n    let identityModule = {\r\n      getIdentityAssertion: () => {\r\n        let identityBundle = {userProfile: {email: 'openidtest10@gmail.com', token: 'idToken', userURL: 'user://gmail.com/openidtest10'}};\r\n        return new Promise(function(resolve) {\r\n          resolve(identityBundle);\r\n        });\r\n      }\r\n    };\r\n\r\n    let runtimeCatalogue = {\r\n      getDataSchemaDescriptor: () => {\r\n        return new Promise(function(resolve) {\r\n          let dataschema = {sourcePackage: {sourceCode: {properties: {scheme: {constant: 'value'}}}}};\r\n          resolve(dataschema);\r\n        });\r\n      }\r\n    };\r\n\r\n    let msgbus = new MessageBus(registry);\r\n\r\n    new AddressAllocation(runtimeURL, msgbus);\r\n\r\n    registry = new Registry(runtimeURL, appSandbox, identityModule, runtimeCatalogue, 'runtimeCapabilities', storageManager);\r\n\r\n    // Prepare the on instance to handle with the fallbacks and runtimeCatalogue;\r\n    let descriptorInstance = new Descriptors(runtimeURL, runtimeCatalogue, {});\r\n\r\n    // Prepare the loader to load the hyperties, protostubs and idpproxy;\r\n    let loader = new Loader(runtimeURL, {}, descriptorInstance);\r\n    loader.runtimeURL = runtimeURL;\r\n    loader.runtimeCatalogue = runtimeCatalogue;\r\n    loader.registry = registry;\r\n    loader.runtimeFactory = runtimeFactory;\r\n\r\n    loader.messageBus = msgbus;\r\n\r\n    registry._runtimeURL = runtimeURL;\r\n    registry._loader = loader;\r\n    registry.messageBus = msgbus;\r\n\r\n    registry.messageBus.addListener('domain://registry.ua.pt/', (msg) => {\r\n      console.log('MSG BUS LISTENER: ', msg);\r\n      let responseMessage = {id: msg.id, type: 'response', to: msg.from, from: msg.to, body: {code: 200}};\r\n\r\n      msgbus.postMessage(responseMessage);\r\n    });\r\n\r\n    let getDescriptor = (url) => {\r\n\r\n      return new Promise(function(resolve, reject) {\r\n\r\n        let dividedURL = divideURL(url);\r\n        let identity = dividedURL.identity;\r\n\r\n        if (!identity) {\r\n          identity = 'default';\r\n        } else {\r\n          identity = identity.substring(identity.lastIndexOf('/') + 1);\r\n        }\r\n\r\n        let result;\r\n\r\n        if (url.includes('Hyperties') || url.includes('Hyperty')) {\r\n          try {\r\n            result = descriptors.Hyperties[identity];\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n\r\n        } else if (!(url.includes('Hyperties') || url.includes('Hyperty')) || url.includes('ProtoStubs') || url.includes('protostub')) {\r\n          try {\r\n            result = descriptors.ProtoStubs[identity];\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        } else if (url.includes('idp-proxy')) {\r\n          try {\r\n            result = descriptors.IdpProxies[identity];\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        }\r\n\r\n        console.log(result);\r\n        resolve(result);\r\n\r\n      });\r\n    };\r\n\r\n    console.log('registry ', descriptorInstance);\r\n    sinon.stub(descriptorInstance, 'getHypertyDescriptor', (hypertyURL) => {\r\n      return getDescriptor(hypertyURL);\r\n    });\r\n\r\n    sinon.stub(descriptorInstance, 'getStubDescriptor', (stubURL) => {\r\n      //console.log('get descriptor for:', stubURL);\r\n      return getDescriptor('https://catalogue.ua.pt/.well-known/protocolstub/' + stubURL);\r\n    });\r\n\r\n    sinon.stub(descriptorInstance, 'getIdpProxyDescriptor', (idpProxyURL) => {\r\n      return getDescriptor(idpProxyURL);\r\n    });\r\n\r\n  });\r\n\r\n  describe('constructor()', function() {\r\n\r\n    it('depends of the MessageBus', function() {\r\n      expect(registry.messageBus).to.be.instanceof(MessageBus);\r\n    });\r\n  });\r\n\r\n  describe('getAppSandbox()', function() {\r\n    it('return AppSandbox()', function() {\r\n      let sandbox = registry.getAppSandbox();\r\n      expect(sandbox).to.be.instanceof(Sandbox);\r\n    });\r\n  });\r\n\r\n  describe('registerStub(sandBox, domainURL)', function() {\r\n\r\n    let domainURL = 'ua.pt';\r\n\r\n    it('should register a stub', function(done) {\r\n      expect(registry.registerStub(sandboxDummy, domainURL).then((deployed) => {\r\n        console.log('Depoyed->', deployed);\r\n        return deployed.url;\r\n      })).to.be.fulfilled.and.eventually.to.contain('msg-node.ua.pt/protostub/').and.notify(done);\r\n\r\n    });\r\n\r\n    it('should register a P2P Handler Stub', (done) => {\r\n      let p2pConfig = {\r\n        isHandlerStub: true\r\n      };\r\n\r\n      expect(registry.registerStub(sandboxDummy, domainURL, p2pConfig).then((deployed) => {\r\n        return deployed.url;\r\n      })).to.be.fulfilled.and.eventually.to.contain('msg-node.ua.pt/protostub/').and.notify(done);\r\n    });\r\n\r\n    it('should register a P2P Requester Stub', (done) => {\r\n\r\n      let p2pConfig = {\r\n        p2pRequesterStub: 'https://localhost/.well-known/protocolstub/P2PRequesterStub'\r\n      };\r\n\r\n      expect(registry.registerStub(sandboxDummy, domainURL, p2pConfig).then((deployed) => {\r\n        return deployed.url;\r\n      })).to.be.fulfilled.and.eventually.to.contain('msg-node.ua.pt/protostub/').and.notify(done);\r\n    });\r\n\r\n    it('should discover P2PHandlerStub', (done) => {\r\n      expect(registry.discoverP2PStub().then((discovered) => {\r\n        return discovered.url;\r\n      })).to.be.fulfilled\r\n      .and.eventually.to.contain('msg-node.ua.pt/protostub/').and.notify(done);\r\n    });\r\n\r\n  });\r\n\r\n  describe('discoverProtostub(url)', function() {\r\n\r\n    it('should discover a ProtocolStub', function(done) {\r\n      let url = 'ua.pt';\r\n      expect(registry.discoverProtostub(url).then((result) => {\r\n        expect(result).to.have.property('url').include('msg-node.ua.pt/protostub/');\r\n        expect(result).to.have.property('status', 'deployed');\r\n        protostubURL = result.url;\r\n        return result;\r\n      }))\r\n      .and.eventually.to.have.all.keys('url', 'status')\r\n      .and.to.be.fulfilled\r\n      .and.notify(done);\r\n    });\r\n  });\r\n\r\n  describe('registerPEP(postMessage, hyperty)', function() {\r\n\r\n    it('should register PEP', function(done) {\r\n      let postMessage = {};\r\n      let hyperty = 'hyperty-catalogue://ua.pt/HelloHyperty';\r\n\r\n      expect(registry.registerPEP(postMessage, hyperty).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.equal('PEP registered with success').and.notify(done);\r\n\r\n    });\r\n  });\r\n\r\n  describe('unregisterPEP(HypertyRuntimeURL)', function() {\r\n\r\n    it('should unregister PEP', function(done) {\r\n      let HypertyRuntimeURL = 'hyperty-catalogue://ua.pt/HelloHyperty';\r\n\r\n      expect(registry.unregisterPEP(HypertyRuntimeURL).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.equal('PEP successfully removed.').and.notify(done);\r\n\r\n    });\r\n  });\r\n\r\n  describe('registerHyperty(sandbox, descriptorURL, descriptor)', function() {\r\n\r\n    it('should register an Hyperty', function(done) {\r\n\r\n      let descriptorURL = 'hyperty-catalogue://ua.pt/<catalogue-object-identifier>';\r\n      let descriptor = {\r\n        _objectName: 'hyperty-chat',\r\n        dataObjects: ['url'],\r\n        hypertyType: ['comm']\r\n      };\r\n      let addressURL = {newAddress: true, address: ['hyperty://ua.pt/1']};\r\n      expect(registry.registerHyperty(sandboxDummy, descriptorURL, descriptor, addressURL)).to.be.fulfilled.and.eventually.equal('hyperty://ua.pt/1').and.notify(done);\r\n\r\n    });\r\n  });\r\n\r\n  describe('getSandbox(url)', function() {\r\n\r\n    it('should get a sandbox from a domain', function(done) {\r\n      let domain = 'ua.pt';\r\n\r\n      expect(registry.getSandbox(domain).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.to.be.eql(sandboxDummy).and.notify(done);\r\n\r\n    });\r\n\r\n    it('should get a sandbox from a specific hypertyIstance', function(done) {\r\n      let hypertyInstance = 'hyperty://ua.pt/1';\r\n\r\n      expect(registry.getSandbox(hypertyInstance).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.to.be.eql(sandboxDummy).and.notify(done);\r\n    });\r\n\r\n    it('should get a sandbox from a specific protostubURL', function(done) {\r\n\r\n      expect(registry.getSandbox(protostubURL))\r\n      .to.be.fulfilled\r\n      .and.eventually.to.be.eql(sandboxDummy)\r\n      .and.notify(done);\r\n    });\r\n\r\n    it('should get a sandbox from a protoStub URL containing the domain', function(done) {\r\n      let domainURL = 'anotherDomain.pt';\r\n\r\n      registry.registerStub(sandboxDummy, domainURL).then(function() {\r\n        expect(registry.getSandbox('anotherDomain.pt').then(function(response) {\r\n          return response;\r\n        })).to.be.fulfilled.and.eventually.equal(sandboxDummy).and.notify(done);\r\n      });\r\n\r\n    });\r\n\r\n  });\r\n\r\n  describe('resolve(url)', function() {\r\n\r\n    it('should return a protostub url', function(done) {\r\n      let url = 'hyperty-runtime://ua.pt/protostub/123';\r\n\r\n      expect(registry.resolve(url).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.to.contain('msg-node.ua.pt/protostub/').and.notify(done);\r\n\r\n    });\r\n  });\r\n\r\n  describe('unregisterStub(url)', function() {\r\n\r\n    it('should unregister a ProtocolStub', function(done) {\r\n      let url = 'ua.pt';\r\n\r\n      expect(registry.unregisterStub(url).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.equal('ProtostubURL removed').and.notify(done);\r\n\r\n    });\r\n  });\r\n\r\n  describe('getHypertyOwner(hypertyURL)', function() {\r\n    it('should return the user associated to the hyperty URL', function() {\r\n      let url = 'hyperty://ua.pt/1';\r\n      expect(registry.getHypertyOwner(url)).to.be.eql('user://gmail.com/openidtest10');\r\n    });\r\n  });\r\n\r\n  describe('getHypertyName(hypertyURL)', function() {\r\n    it('should return the hyperty Name from a given hypertyURL', function() {\r\n      let url = 'hyperty://ua.pt/1';\r\n\r\n      expect(registry.getHypertyName(url)).to.be.equal('hyperty-chat');\r\n    });\r\n  });\r\n\r\n  describe('registerDataObject(identifier, dataObjectschema, dataObjectUrl, dataObjectReporter, authorise)', function() {\r\n    it('should register a new Data Object in the runtime registry', function(done) {\r\n      let identifier = 'hello-chat';\r\n      let dataObjectschema = 'hyperty-catalogue://catalogue.localhost/.well-known/dataschema/Communication';\r\n      let dataObjectUrl = 'comm://localhost/9303b707-f301-4929-ad7d-65a89a356871';\r\n      let dataObjectReporter = 'hyperty://localhost/d692091f-192c-420c-a763-a180f13e626a';\r\n      let authorise = ['user://gmail.com/user15'];\r\n      let addressURL = {newAddress: true, address: ['comm://localhost/9303b707-f301-4929-ad7d-65a89a356871']};\r\n\r\n      expect(registry.registerDataObject(identifier, dataObjectschema, dataObjectUrl, dataObjectReporter, ['fake'], addressURL, authorise).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.equal('ok').and.notify(done);\r\n    });\r\n  });\r\n\r\n  describe('checkRegisteredURLs(info)', function() {\r\n\r\n    it('should return a previously registered Hyperty URL', function(done) {\r\n\r\n      let descriptor = {\r\n        _objectName: 'hyperty-chat',\r\n        dataObjects: ['url'],\r\n        hypertyType: ['comm']\r\n      };\r\n\r\n      expect(registry.checkRegisteredURLs(descriptor).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.to.be.eql(['hyperty://ua.pt/1']).and.notify(done);\r\n\r\n    });\r\n\r\n    it('should return a undefined value if the Hyperty is not previously registered', function(done) {\r\n\r\n      let fakeDescriptor = {\r\n        _objectName: 'hyperty-fake',\r\n        dataObjects: ['url2'],\r\n        hypertyType: ['comm2']\r\n      };\r\n      expect(registry.checkRegisteredURLs(fakeDescriptor).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.to.be.equal(undefined).and.notify(done);\r\n    });\r\n\r\n    it('should return a previously registered Data Object URL', function(done) {\r\n\r\n      let info = {\r\n        name: 'hello-chat',\r\n        schema: 'hyperty-catalogue://catalogue.localhost/.well-known/dataschema/Communication',\r\n        resources: ['fake'],\r\n        reporter: 'hyperty://localhost/d692091f-192c-420c-a763-a180f13e626a'\r\n      };\r\n\r\n      expect(registry.checkRegisteredURLs(info).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.to.be.eql(['comm://localhost/9303b707-f301-4929-ad7d-65a89a356871']).and.notify(done);\r\n\r\n    });\r\n\r\n    it('should return a undefined value if the dataObjectURL is not previously registered', function(done) {\r\n      let fakeInfo = {\r\n        name: 'fake',\r\n        schema: 'hyperty-catalogue://catalogue.localhost/.well-known/dataschema/unknown',\r\n        resources: ['fake'],\r\n        reporter: 'hyperty://localhost/anotherURL123'\r\n      };\r\n      expect(registry.checkRegisteredURLs(fakeInfo).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.to.be.equal(undefined).and.notify(done);\r\n    });\r\n\r\n    it('should return an hyperty url based on given address', function(done) {\r\n\r\n      let descriptor = {\r\n        _objectName: 'hyperty-chat',\r\n        dataObjects: ['url'],\r\n        hypertyType: ['comm']\r\n      };\r\n\r\n      let reuseURL = 'hyperty://ua.pt/1';\r\n\r\n      expect(registry.checkRegisteredURLs(descriptor, reuseURL)).to.eventually\r\n      .to.be.eql(['hyperty://ua.pt/1'])\r\n      .and.to.be.fulfilled\r\n      .and.notify(done);\r\n\r\n    });\r\n\r\n  });\r\n\r\n  describe('getReporterURL(dataObjectURL)', function() {\r\n\r\n    it('should return the reporterURL associated with the dataobject URL', function(done) {\r\n      let dataObjectURL = 'comm://localhost/9303b707-f301-4929-ad7d-65a89a356871';\r\n\r\n      expect(registry.getReporterURL(dataObjectURL).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.equal('hyperty://localhost/d692091f-192c-420c-a763-a180f13e626a').and.notify(done);\r\n    });\r\n\r\n    it('should not found the reporter the reporterURL associated with the dataobject URL', function(done) {\r\n      let fakedataObjectURL = 'comm://fake';\r\n      expect(registry.getReporterURL(fakedataObjectURL).then(function(response) {\r\n        return response;\r\n      })).eventually.equal('No reporter was found').and.to.be.rejected.and.notify(done);\r\n\r\n    });\r\n\r\n  });\r\n\r\n  describe('getPreAuthSubscribers(dataObjectURL)', function() {\r\n    it('should return the list of pre authorised users', function() {\r\n      let dataObjectURL = 'comm://localhost/9303b707-f301-4929-ad7d-65a89a356871';\r\n      let fakedataObjectURL = 'comm://fake';\r\n\r\n      expect(registry.getPreAuthSubscribers(dataObjectURL)).to.be.eql(['user://gmail.com/user15']);\r\n\r\n      expect(registry.getPreAuthSubscribers(fakedataObjectURL)).to.be.eql([]);\r\n    });\r\n  });\r\n\r\n  describe('getDataObjectSubscribers(dataObjectURL)', function() {\r\n    it('should return the list of pre authorised users', function() {\r\n      let dataObjectURL = 'comm://localhost/9303b707-f301-4929-ad7d-65a89a356871';\r\n      let subscriberURL = 'hyperty://localhost/00-00-sub1';\r\n\r\n      registry.registerSubscriber(dataObjectURL, subscriberURL);\r\n\r\n      expect(registry.getDataObjectSubscribers(dataObjectURL)).to.be.eql(['hyperty://localhost/00-00-sub1']);\r\n    });\r\n  });\r\n\r\n  describe('unregisterHyperty(url)', function() {\r\n    it('should unregister an Hyperty', function(done) {\r\n      let url = 'hyperty://ua.pt/1';\r\n\r\n      expect(registry.unregisterHyperty(url).then(function(response) {\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.equal('Hyperty successfully deleted').and.notify(done);\r\n    });\r\n  });\r\n\r\n  describe('isLegacy(url)', function() {\r\n\r\n    it('should return a protostub', function(done) {\r\n      let url = 'slack://user@team.slack.com';\r\n\r\n      expect(registry.isLegacy(url).then(function(response) {\r\n        console.log('ProtoSTUB->', response);\r\n        return response;\r\n      })).to.be.fulfilled.and.eventually.to.equal(true).and.notify(done);\r\n\r\n    });\r\n  });\r\n\r\n});\r\n",
    "static": true,
    "longname": "test/Registry.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 976,
    "kind": "testDescribe",
    "name": "describe120",
    "testId": 120,
    "memberof": "test/Registry.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/Registry.spec.js~describe120",
    "access": null,
    "description": "Registry",
    "lineNumber": 33
  },
  {
    "__docId__": 977,
    "kind": "testDescribe",
    "name": "describe121",
    "testId": 121,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe121",
    "access": null,
    "description": "constructor()",
    "lineNumber": 143
  },
  {
    "__docId__": 978,
    "kind": "testIt",
    "name": "it122",
    "testId": 122,
    "memberof": "test/Registry.spec.js~describe120.describe121",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe121.it122",
    "access": null,
    "description": "depends of the MessageBus",
    "lineNumber": 145
  },
  {
    "__docId__": 979,
    "kind": "testDescribe",
    "name": "describe123",
    "testId": 123,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe123",
    "access": null,
    "description": "getAppSandbox()",
    "lineNumber": 150
  },
  {
    "__docId__": 980,
    "kind": "testIt",
    "name": "it124",
    "testId": 124,
    "memberof": "test/Registry.spec.js~describe120.describe123",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe123.it124",
    "access": null,
    "description": "return AppSandbox()",
    "lineNumber": 151
  },
  {
    "__docId__": 981,
    "kind": "testDescribe",
    "name": "describe125",
    "testId": 125,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe125",
    "access": null,
    "description": "registerStub(sandBox, domainURL)",
    "lineNumber": 157
  },
  {
    "__docId__": 982,
    "kind": "testIt",
    "name": "it126",
    "testId": 126,
    "memberof": "test/Registry.spec.js~describe120.describe125",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe125.it126",
    "access": null,
    "description": "should register a stub",
    "lineNumber": 161
  },
  {
    "__docId__": 983,
    "kind": "testIt",
    "name": "it127",
    "testId": 127,
    "memberof": "test/Registry.spec.js~describe120.describe125",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe125.it127",
    "access": null,
    "description": "should register a P2P Handler Stub",
    "lineNumber": 169
  },
  {
    "__docId__": 984,
    "kind": "testIt",
    "name": "it128",
    "testId": 128,
    "memberof": "test/Registry.spec.js~describe120.describe125",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe125.it128",
    "access": null,
    "description": "should register a P2P Requester Stub",
    "lineNumber": 179
  },
  {
    "__docId__": 985,
    "kind": "testIt",
    "name": "it129",
    "testId": 129,
    "memberof": "test/Registry.spec.js~describe120.describe125",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe125.it129",
    "access": null,
    "description": "should discover P2PHandlerStub",
    "lineNumber": 190
  },
  {
    "__docId__": 986,
    "kind": "testDescribe",
    "name": "describe130",
    "testId": 130,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe130",
    "access": null,
    "description": "discoverProtostub(url)",
    "lineNumber": 199
  },
  {
    "__docId__": 987,
    "kind": "testIt",
    "name": "it131",
    "testId": 131,
    "memberof": "test/Registry.spec.js~describe120.describe130",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe130.it131",
    "access": null,
    "description": "should discover a ProtocolStub",
    "lineNumber": 201
  },
  {
    "__docId__": 988,
    "kind": "testDescribe",
    "name": "describe132",
    "testId": 132,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe132",
    "access": null,
    "description": "registerPEP(postMessage, hyperty)",
    "lineNumber": 215
  },
  {
    "__docId__": 989,
    "kind": "testIt",
    "name": "it133",
    "testId": 133,
    "memberof": "test/Registry.spec.js~describe120.describe132",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe132.it133",
    "access": null,
    "description": "should register PEP",
    "lineNumber": 217
  },
  {
    "__docId__": 990,
    "kind": "testDescribe",
    "name": "describe134",
    "testId": 134,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe134",
    "access": null,
    "description": "unregisterPEP(HypertyRuntimeURL)",
    "lineNumber": 228
  },
  {
    "__docId__": 991,
    "kind": "testIt",
    "name": "it135",
    "testId": 135,
    "memberof": "test/Registry.spec.js~describe120.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe134.it135",
    "access": null,
    "description": "should unregister PEP",
    "lineNumber": 230
  },
  {
    "__docId__": 992,
    "kind": "testDescribe",
    "name": "describe136",
    "testId": 136,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe136",
    "access": null,
    "description": "registerHyperty(sandbox, descriptorURL, descriptor)",
    "lineNumber": 240
  },
  {
    "__docId__": 993,
    "kind": "testIt",
    "name": "it137",
    "testId": 137,
    "memberof": "test/Registry.spec.js~describe120.describe136",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe136.it137",
    "access": null,
    "description": "should register an Hyperty",
    "lineNumber": 242
  },
  {
    "__docId__": 994,
    "kind": "testDescribe",
    "name": "describe138",
    "testId": 138,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe138",
    "access": null,
    "description": "getSandbox(url)",
    "lineNumber": 256
  },
  {
    "__docId__": 995,
    "kind": "testIt",
    "name": "it139",
    "testId": 139,
    "memberof": "test/Registry.spec.js~describe120.describe138",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe138.it139",
    "access": null,
    "description": "should get a sandbox from a domain",
    "lineNumber": 258
  },
  {
    "__docId__": 996,
    "kind": "testIt",
    "name": "it140",
    "testId": 140,
    "memberof": "test/Registry.spec.js~describe120.describe138",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe138.it140",
    "access": null,
    "description": "should get a sandbox from a specific hypertyIstance",
    "lineNumber": 267
  },
  {
    "__docId__": 997,
    "kind": "testIt",
    "name": "it141",
    "testId": 141,
    "memberof": "test/Registry.spec.js~describe120.describe138",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe138.it141",
    "access": null,
    "description": "should get a sandbox from a specific protostubURL",
    "lineNumber": 275
  },
  {
    "__docId__": 998,
    "kind": "testIt",
    "name": "it142",
    "testId": 142,
    "memberof": "test/Registry.spec.js~describe120.describe138",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe138.it142",
    "access": null,
    "description": "should get a sandbox from a protoStub URL containing the domain",
    "lineNumber": 283
  },
  {
    "__docId__": 999,
    "kind": "testDescribe",
    "name": "describe143",
    "testId": 143,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe143",
    "access": null,
    "description": "resolve(url)",
    "lineNumber": 296
  },
  {
    "__docId__": 1000,
    "kind": "testIt",
    "name": "it144",
    "testId": 144,
    "memberof": "test/Registry.spec.js~describe120.describe143",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe143.it144",
    "access": null,
    "description": "should return a protostub url",
    "lineNumber": 298
  },
  {
    "__docId__": 1001,
    "kind": "testDescribe",
    "name": "describe145",
    "testId": 145,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe145",
    "access": null,
    "description": "unregisterStub(url)",
    "lineNumber": 308
  },
  {
    "__docId__": 1002,
    "kind": "testIt",
    "name": "it146",
    "testId": 146,
    "memberof": "test/Registry.spec.js~describe120.describe145",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe145.it146",
    "access": null,
    "description": "should unregister a ProtocolStub",
    "lineNumber": 310
  },
  {
    "__docId__": 1003,
    "kind": "testDescribe",
    "name": "describe147",
    "testId": 147,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe147",
    "access": null,
    "description": "getHypertyOwner(hypertyURL)",
    "lineNumber": 320
  },
  {
    "__docId__": 1004,
    "kind": "testIt",
    "name": "it148",
    "testId": 148,
    "memberof": "test/Registry.spec.js~describe120.describe147",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe147.it148",
    "access": null,
    "description": "should return the user associated to the hyperty URL",
    "lineNumber": 321
  },
  {
    "__docId__": 1005,
    "kind": "testDescribe",
    "name": "describe149",
    "testId": 149,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe149",
    "access": null,
    "description": "getHypertyName(hypertyURL)",
    "lineNumber": 327
  },
  {
    "__docId__": 1006,
    "kind": "testIt",
    "name": "it150",
    "testId": 150,
    "memberof": "test/Registry.spec.js~describe120.describe149",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe149.it150",
    "access": null,
    "description": "should return the hyperty Name from a given hypertyURL",
    "lineNumber": 328
  },
  {
    "__docId__": 1007,
    "kind": "testDescribe",
    "name": "describe151",
    "testId": 151,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe151",
    "access": null,
    "description": "registerDataObject(identifier, dataObjectschema, dataObjectUrl, dataObjectReporter, authorise)",
    "lineNumber": 335
  },
  {
    "__docId__": 1008,
    "kind": "testIt",
    "name": "it152",
    "testId": 152,
    "memberof": "test/Registry.spec.js~describe120.describe151",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe151.it152",
    "access": null,
    "description": "should register a new Data Object in the runtime registry",
    "lineNumber": 336
  },
  {
    "__docId__": 1009,
    "kind": "testDescribe",
    "name": "describe153",
    "testId": 153,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe153",
    "access": null,
    "description": "checkRegisteredURLs(info)",
    "lineNumber": 350
  },
  {
    "__docId__": 1010,
    "kind": "testIt",
    "name": "it154",
    "testId": 154,
    "memberof": "test/Registry.spec.js~describe120.describe153",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe153.it154",
    "access": null,
    "description": "should return a previously registered Hyperty URL",
    "lineNumber": 352
  },
  {
    "__docId__": 1011,
    "kind": "testIt",
    "name": "it155",
    "testId": 155,
    "memberof": "test/Registry.spec.js~describe120.describe153",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe153.it155",
    "access": null,
    "description": "should return a undefined value if the Hyperty is not previously registered",
    "lineNumber": 366
  },
  {
    "__docId__": 1012,
    "kind": "testIt",
    "name": "it156",
    "testId": 156,
    "memberof": "test/Registry.spec.js~describe120.describe153",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe153.it156",
    "access": null,
    "description": "should return a previously registered Data Object URL",
    "lineNumber": 378
  },
  {
    "__docId__": 1013,
    "kind": "testIt",
    "name": "it157",
    "testId": 157,
    "memberof": "test/Registry.spec.js~describe120.describe153",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe153.it157",
    "access": null,
    "description": "should return a undefined value if the dataObjectURL is not previously registered",
    "lineNumber": 393
  },
  {
    "__docId__": 1014,
    "kind": "testIt",
    "name": "it158",
    "testId": 158,
    "memberof": "test/Registry.spec.js~describe120.describe153",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe153.it158",
    "access": null,
    "description": "should return an hyperty url based on given address",
    "lineNumber": 405
  },
  {
    "__docId__": 1015,
    "kind": "testDescribe",
    "name": "describe159",
    "testId": 159,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe159",
    "access": null,
    "description": "getReporterURL(dataObjectURL)",
    "lineNumber": 424
  },
  {
    "__docId__": 1016,
    "kind": "testIt",
    "name": "it160",
    "testId": 160,
    "memberof": "test/Registry.spec.js~describe120.describe159",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe159.it160",
    "access": null,
    "description": "should return the reporterURL associated with the dataobject URL",
    "lineNumber": 426
  },
  {
    "__docId__": 1017,
    "kind": "testIt",
    "name": "it161",
    "testId": 161,
    "memberof": "test/Registry.spec.js~describe120.describe159",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe159.it161",
    "access": null,
    "description": "should not found the reporter the reporterURL associated with the dataobject URL",
    "lineNumber": 434
  },
  {
    "__docId__": 1018,
    "kind": "testDescribe",
    "name": "describe162",
    "testId": 162,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe162",
    "access": null,
    "description": "getPreAuthSubscribers(dataObjectURL)",
    "lineNumber": 444
  },
  {
    "__docId__": 1019,
    "kind": "testIt",
    "name": "it163",
    "testId": 163,
    "memberof": "test/Registry.spec.js~describe120.describe162",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe162.it163",
    "access": null,
    "description": "should return the list of pre authorised users",
    "lineNumber": 445
  },
  {
    "__docId__": 1020,
    "kind": "testDescribe",
    "name": "describe164",
    "testId": 164,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe164",
    "access": null,
    "description": "getDataObjectSubscribers(dataObjectURL)",
    "lineNumber": 455
  },
  {
    "__docId__": 1021,
    "kind": "testIt",
    "name": "it165",
    "testId": 165,
    "memberof": "test/Registry.spec.js~describe120.describe164",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe164.it165",
    "access": null,
    "description": "should return the list of pre authorised users",
    "lineNumber": 456
  },
  {
    "__docId__": 1022,
    "kind": "testDescribe",
    "name": "describe166",
    "testId": 166,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe166",
    "access": null,
    "description": "unregisterHyperty(url)",
    "lineNumber": 466
  },
  {
    "__docId__": 1023,
    "kind": "testIt",
    "name": "it167",
    "testId": 167,
    "memberof": "test/Registry.spec.js~describe120.describe166",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe166.it167",
    "access": null,
    "description": "should unregister an Hyperty",
    "lineNumber": 467
  },
  {
    "__docId__": 1024,
    "kind": "testDescribe",
    "name": "describe168",
    "testId": 168,
    "memberof": "test/Registry.spec.js~describe120",
    "testDepth": 1,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe168",
    "access": null,
    "description": "isLegacy(url)",
    "lineNumber": 476
  },
  {
    "__docId__": 1025,
    "kind": "testIt",
    "name": "it169",
    "testId": 169,
    "memberof": "test/Registry.spec.js~describe120.describe168",
    "testDepth": 2,
    "static": true,
    "longname": "test/Registry.spec.js~describe120.describe168.it169",
    "access": null,
    "description": "should return a protostub",
    "lineNumber": 478
  },
  {
    "__docId__": 1026,
    "kind": "testFile",
    "name": "test/RuntimeUA.spec.js",
    "content": "import chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\nimport sinonChai from 'sinon-chai';\r\n\r\nchai.config.truncateThreshold = 0;\r\n\r\nlet expect = chai.expect;\r\n\r\nchai.use(chaiAsPromised);\r\nchai.use(sinonChai);\r\n\r\nimport { descriptors } from './resources/descriptors.js';\r\n\r\n// Testing Module\r\nimport RuntimeUA from  '../src/runtime/RuntimeUA';\r\n\r\n// Main dependecies\r\nimport Registry from '../src/registry/Registry';\r\nimport IdentityModule from '../src/identity/IdentityModule';\r\nimport PEP from '../src/policy/PEP';\r\nimport MessageBus from '../src/bus/MessageBus';\r\n\r\nimport { divideURL } from '../src/utils/utils';\r\n\r\nimport { runtimeFactory } from './resources/runtimeFactory';\r\n\r\n/// import { runtimeConfiguration } from './resources/runtimeConfiguration';\r\n\r\n// Testing runtimeUA;\r\nlet domain = 'localhost';\r\ndescribe('RuntimeUA', function() {\r\n\r\n  let runtime = new RuntimeUA(descriptors.Runtimes.Runtime, runtimeFactory, domain);\r\n  let getDescriptor;\r\n\r\n  before(function() {\r\n\r\n    getDescriptor = (url) => {\r\n\r\n      return new Promise(function(resolve, reject) {\r\n\r\n        let dividedURL = divideURL(url);\r\n        let identity = dividedURL.identity;\r\n\r\n        if (!identity) {\r\n          identity = 'default';\r\n        } else {\r\n          identity = identity.substring(identity.lastIndexOf('/') + 1);\r\n        }\r\n\r\n        let result;\r\n\r\n        if (url.includes('hyperty')) {\r\n          try {\r\n            result = descriptors.Hyperties[identity];\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n\r\n        } else if (url.includes('protocolstub') || url === dividedURL.domain) {\r\n          try {\r\n            result = descriptors.ProtoStubs[identity];\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        } else if (url.includes('idp-proxy')) {\r\n          try {\r\n            result = descriptors.IdpProxies[identity];\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        } else if (url.includes('dataschema')) {\r\n          try {\r\n            result = descriptors.DataSchemas[identity];\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n\r\n        }\r\n\r\n        resolve(result);\r\n\r\n      });\r\n    };\r\n  });\r\n\r\n  after(function() {\r\n    runtime.descriptorInstance.getHypertyDescriptor.restore();\r\n    runtime.descriptorInstance.getStubDescriptor.restore();\r\n    runtime.descriptorInstance.getIdpProxyDescriptor.restore();\r\n  });\r\n\r\n  describe('constructor()', function() {\r\n\r\n    it('expects the runtime was ready', (done) => {\r\n\r\n      expect(runtime.init().then((result) => {\r\n\r\n        sinon.stub(runtime.messageBus, 'postMessage', function(msg, replyCallback) {\r\n          replyCallback({\r\n            id: 1, type: 'response', from: 'domain://msg-node.sp.domain/address-allocation', to: 'local://fake.url',\r\n            body: {code: 200, value: {allocated: msg.body.scheme + '://sp.domain/9c8c1949-e08e-4554-b201-bab201bdb21d'}}\r\n          });\r\n        });\r\n\r\n        sinon.stub(runtime.descriptorInstance, 'getHypertyDescriptor', (hypertyURL) => {\r\n          return getDescriptor(hypertyURL);\r\n        });\r\n\r\n        sinon.stub(runtime.descriptorInstance, 'getStubDescriptor', (stubURL) => {\r\n          return getDescriptor(stubURL);\r\n        });\r\n\r\n        sinon.stub(runtime.descriptorInstance, 'getIdpProxyDescriptor', (idpProxyURL) => {\r\n          return getDescriptor(idpProxyURL);\r\n        });\r\n\r\n        sinon.stub(runtime.runtimeCatalogue, 'getDataSchemaDescriptor', (dataSchemaURL) => {\r\n          return getDescriptor(dataSchemaURL);\r\n        });\r\n\r\n        sinon.stub(runtime.registry, 'registerHyperty', (sandbox, descriptorURL, descriptor, addressURL) => {\r\n          return new Promise(function(resolve) {\r\n            console.log('AQIO:', addressURL);\r\n            if (addressURL.newAddress) {\r\n              resolve('hyperty://sp.domain/9c8c1949-e08e-4554-b201-bab201bdb21d');\r\n            } else {\r\n              resolve(addressURL.address);\r\n            }\r\n          });\r\n\r\n        });\r\n\r\n        sinon.stub(runtime.registry, 'checkRegisteredURLs', (info, reuseURL) => {\r\n\r\n          return new Promise((resolve) => {\r\n            console.log('checkRegisteredURLs:', typeof(reuseURL), reuseURL);\r\n            if (typeof(reuseURL) === 'boolean') {\r\n              resolve('hyperty://sp.domain/9c8c1949-e08e-4554-b201-bab201bdb21d');\r\n            } else if (typeof(reuseURL) === 'string') {\r\n              console.log('checkRegisteredURLs is string:', reuseURL);\r\n              resolve(reuseURL);\r\n            } else {\r\n              resolve('hyperty://sp.domain/9c8c1949-e08e-4554-b201-bab201bdb21d');\r\n            }\r\n\r\n          });\r\n\r\n        });\r\n\r\n        return result;\r\n      }))\r\n      .to.be.fulfilled\r\n      .and.to.eventually.be.true\r\n      .and.notify(done);\r\n\r\n    });\r\n\r\n    it('depends of the Registry', function() {\r\n      expect(runtime.registry).to.be.instanceof(Registry);\r\n    });\r\n\r\n    it('depends of the Identity Module', function() {\r\n      expect(runtime.identityModule).to.be.instanceof(IdentityModule);\r\n    });\r\n\r\n    it('depends of the Policy Engine', function() {\r\n      expect(runtime.policyEngine).to.be.instanceof(PEP);\r\n    });\r\n\r\n    it('depends of the MessageBus', function() {\r\n      expect(runtime.messageBus).to.be.instanceof(MessageBus);\r\n    });\r\n\r\n    it('should throw when given no arguments', function() {\r\n      expect(runtime).to.have.property('runtimeFactory');\r\n      expect(runtime.runtimeFactory).to.have.property('atob');\r\n      expect(runtime.runtimeFactory).to.have.property('persistenceManager');\r\n      expect(runtime.runtimeFactory).to.have.property('runtimeCapabilities');\r\n      expect(runtime.runtimeFactory).to.have.property('storageManager');\r\n      expect(runtime.runtimeFactory).to.have.property('createSandbox');\r\n      expect(runtime.runtimeFactory).to.have.property('createAppSandbox');\r\n      expect(runtime.runtimeFactory).to.have.property('createHttpRequest');\r\n      expect(runtime.runtimeFactory).to.have.property('createRuntimeCatalogue');\r\n    });\r\n\r\n  });\r\n\r\n  describe('loadHyperty(hypertyDescriptorURL)', function() {\r\n\r\n    it('should throw when given no arguments', function(done) {\r\n      let hypertyDescriptorURL = 'hyperty-catalogue://catalogue.sp.domain/.well-known/hyperty/HelloHyperty';\r\n      let loadHyperty = runtime.loadHyperty(hypertyDescriptorURL);\r\n\r\n      expect(loadHyperty)\r\n      .to.be.fulfilled\r\n      .and.notify(done);\r\n    });\r\n\r\n    it('should be a Promise', function(done) {\r\n\r\n      let hypertyDescriptorURL = 'hyperty-catalogue://catalogue.sp.domain/.well-known/hyperty/HelloHyperty';\r\n      let loadHyperty = runtime.loadHyperty(hypertyDescriptorURL);\r\n\r\n      expect(loadHyperty)\r\n      .to.be.fulfilled\r\n      .and.to.be.instanceof(Promise)\r\n      .and.notify(done);\r\n\r\n    });\r\n\r\n    it('should be deployed', function(done) {\r\n\r\n      let hypertyDescriptorURL = 'hyperty-catalogue://catalogue.sp.domain/.well-known/hyperty/HelloHyperty';\r\n      let loadHyperty = runtime.loadHyperty(hypertyDescriptorURL);\r\n      let hypertyResolved = ['runtimeHypertyURL', 'status'];\r\n\r\n      expect(loadHyperty).to.eventually.to.have.all.keys(hypertyResolved)\r\n      .and.to.be.fulfilled\r\n      .and.notify(done);\r\n\r\n    });\r\n\r\n    it('should load an hyperty based on given true value for the reuse', function(done) {\r\n\r\n      let hypertyDescriptorURL = 'hyperty-catalogue://catalogue.sp.domain/.well-known/hyperty/HelloHyperty';\r\n      let loadHyperty = runtime.loadHyperty(hypertyDescriptorURL, true);\r\n      let hypertyResolved = ['runtimeHypertyURL', 'status'];\r\n\r\n      expect(loadHyperty).to.be.fulfilled\r\n      .and.eventually.to.have.all.keys(hypertyResolved)\r\n      .and.notify(done);\r\n\r\n    });\r\n\r\n    it('should load an hyperty based on given reuse URL address', function(done) {\r\n\r\n      let hypertyDescriptorURL = 'hyperty-catalogue://catalogue.sp.domain/.well-known/hyperty/HelloHyperty';\r\n      let loadHyperty = runtime.loadHyperty(hypertyDescriptorURL, 'hyperty://sp.domain/1');\r\n      let hypertyResolved = {\r\n        runtimeHypertyURL: 'hyperty://sp.domain/1',\r\n        status: 'deployed'\r\n      };\r\n\r\n      expect(loadHyperty).to.eventually.to.deep.equal(hypertyResolved)\r\n      .and.to.be.fulfilled\r\n      .and.notify(done);\r\n\r\n    });\r\n\r\n\r\n  });\r\n\r\n  describe('loadStub(sp-domain)', function() {\r\n\r\n    it('should throw when given no arguments', function(done) {\r\n      let spDomain = 'sp.domain';\r\n      let loadStubPromise = runtime.loadStub(spDomain);\r\n\r\n      loadStubPromise.then(function(a) {\r\n        console.log(a);\r\n      }).catch(function(reason) {\r\n        console.error(reason);\r\n      });\r\n\r\n      expect(loadStubPromise).to.be.fulfilled.and.notify(done);\r\n    });\r\n\r\n    it('should be a Promise', function(done) {\r\n      let spDomain = 'sp.domain';\r\n      let loadStubPromise = runtime.loadStub(spDomain);\r\n\r\n      expect(loadStubPromise).to.be.fulfilled\r\n      .to.be.instanceof(Promise)\r\n      .and.notify(done);\r\n    });\r\n\r\n    it('should be deployed', function(done) {\r\n      let spDomain = 'sp.domain';\r\n      let loadStubPromise = runtime.loadStub(spDomain);\r\n      let stubResolved = ['url', 'status'];\r\n\r\n      expect(loadStubPromise).to.be.fulfilled\r\n      .and.eventually.to.have.all.keys(stubResolved)\r\n      .and.notify(done);\r\n    });\r\n\r\n  });\r\n\r\n  describe('loadIdpProxy(google.com)', function() {\r\n\r\n    it('should throw when given no arguments', function(done) {\r\n      let domain = 'google.com';\r\n      let loadIdpPromise = runtime.loadIdpProxy(domain);\r\n\r\n      expect(loadIdpPromise).to.be.fulfilled.and.notify(done);\r\n    });\r\n\r\n    it('should be a Promise', function(done) {\r\n      let domain = 'google.com';\r\n      let loadIdpPromise = runtime.loadIdpProxy(domain);\r\n\r\n      expect(loadIdpPromise).to.be.fulfilled\r\n      .to.be.instanceof(Promise)\r\n      .and.notify(done);\r\n    });\r\n\r\n    it('should be deployed', function(done) {\r\n      let domain = 'google.com';\r\n      let loadIdpPromise = runtime.loadIdpProxy(domain);\r\n      let stubResolved = ['url', 'status'];\r\n\r\n      expect(loadIdpPromise).to.be.fulfilled\r\n      .and.eventually.to.have.all.keys(stubResolved)\r\n      .and.notify(done);\r\n    });\r\n\r\n  });\r\n\r\n});\r\n",
    "static": true,
    "longname": "test/RuntimeUA.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1027,
    "kind": "testDescribe",
    "name": "describe170",
    "testId": 170,
    "memberof": "test/RuntimeUA.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170",
    "access": null,
    "description": "RuntimeUA",
    "lineNumber": 31
  },
  {
    "__docId__": 1028,
    "kind": "testDescribe",
    "name": "describe171",
    "testId": 171,
    "memberof": "test/RuntimeUA.spec.js~describe170",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe171",
    "access": null,
    "description": "constructor()",
    "lineNumber": 93
  },
  {
    "__docId__": 1029,
    "kind": "testIt",
    "name": "it172",
    "testId": 172,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe171",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe171.it172",
    "access": null,
    "description": "expects the runtime was ready",
    "lineNumber": 95
  },
  {
    "__docId__": 1030,
    "kind": "testIt",
    "name": "it173",
    "testId": 173,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe171",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe171.it173",
    "access": null,
    "description": "depends of the Registry",
    "lineNumber": 159
  },
  {
    "__docId__": 1031,
    "kind": "testIt",
    "name": "it174",
    "testId": 174,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe171",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe171.it174",
    "access": null,
    "description": "depends of the Identity Module",
    "lineNumber": 163
  },
  {
    "__docId__": 1032,
    "kind": "testIt",
    "name": "it175",
    "testId": 175,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe171",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe171.it175",
    "access": null,
    "description": "depends of the Policy Engine",
    "lineNumber": 167
  },
  {
    "__docId__": 1033,
    "kind": "testIt",
    "name": "it176",
    "testId": 176,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe171",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe171.it176",
    "access": null,
    "description": "depends of the MessageBus",
    "lineNumber": 171
  },
  {
    "__docId__": 1034,
    "kind": "testIt",
    "name": "it177",
    "testId": 177,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe171",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe171.it177",
    "access": null,
    "description": "should throw when given no arguments",
    "lineNumber": 175
  },
  {
    "__docId__": 1035,
    "kind": "testDescribe",
    "name": "describe178",
    "testId": 178,
    "memberof": "test/RuntimeUA.spec.js~describe170",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe178",
    "access": null,
    "description": "loadHyperty(hypertyDescriptorURL)",
    "lineNumber": 189
  },
  {
    "__docId__": 1036,
    "kind": "testIt",
    "name": "it179",
    "testId": 179,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe178",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe178.it179",
    "access": null,
    "description": "should throw when given no arguments",
    "lineNumber": 191
  },
  {
    "__docId__": 1037,
    "kind": "testIt",
    "name": "it180",
    "testId": 180,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe178",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe178.it180",
    "access": null,
    "description": "should be a Promise",
    "lineNumber": 200
  },
  {
    "__docId__": 1038,
    "kind": "testIt",
    "name": "it181",
    "testId": 181,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe178",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe178.it181",
    "access": null,
    "description": "should be deployed",
    "lineNumber": 212
  },
  {
    "__docId__": 1039,
    "kind": "testIt",
    "name": "it182",
    "testId": 182,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe178",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe178.it182",
    "access": null,
    "description": "should load an hyperty based on given true value for the reuse",
    "lineNumber": 224
  },
  {
    "__docId__": 1040,
    "kind": "testIt",
    "name": "it183",
    "testId": 183,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe178",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe178.it183",
    "access": null,
    "description": "should load an hyperty based on given reuse URL address",
    "lineNumber": 236
  },
  {
    "__docId__": 1041,
    "kind": "testDescribe",
    "name": "describe184",
    "testId": 184,
    "memberof": "test/RuntimeUA.spec.js~describe170",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe184",
    "access": null,
    "description": "loadStub(sp-domain)",
    "lineNumber": 254
  },
  {
    "__docId__": 1042,
    "kind": "testIt",
    "name": "it185",
    "testId": 185,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe184",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe184.it185",
    "access": null,
    "description": "should throw when given no arguments",
    "lineNumber": 256
  },
  {
    "__docId__": 1043,
    "kind": "testIt",
    "name": "it186",
    "testId": 186,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe184",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe184.it186",
    "access": null,
    "description": "should be a Promise",
    "lineNumber": 269
  },
  {
    "__docId__": 1044,
    "kind": "testIt",
    "name": "it187",
    "testId": 187,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe184",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe184.it187",
    "access": null,
    "description": "should be deployed",
    "lineNumber": 278
  },
  {
    "__docId__": 1045,
    "kind": "testDescribe",
    "name": "describe188",
    "testId": 188,
    "memberof": "test/RuntimeUA.spec.js~describe170",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe188",
    "access": null,
    "description": "loadIdpProxy(google.com)",
    "lineNumber": 290
  },
  {
    "__docId__": 1046,
    "kind": "testIt",
    "name": "it189",
    "testId": 189,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe188",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe188.it189",
    "access": null,
    "description": "should throw when given no arguments",
    "lineNumber": 292
  },
  {
    "__docId__": 1047,
    "kind": "testIt",
    "name": "it190",
    "testId": 190,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe188",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe188.it190",
    "access": null,
    "description": "should be a Promise",
    "lineNumber": 299
  },
  {
    "__docId__": 1048,
    "kind": "testIt",
    "name": "it191",
    "testId": 191,
    "memberof": "test/RuntimeUA.spec.js~describe170.describe188",
    "testDepth": 2,
    "static": true,
    "longname": "test/RuntimeUA.spec.js~describe170.describe188.it191",
    "access": null,
    "description": "should be deployed",
    "lineNumber": 308
  },
  {
    "__docId__": 1049,
    "kind": "testFile",
    "name": "test/Sandbox.spec.js",
    "content": "import SandboxRegistry from '../src/sandbox/SandboxRegistry';\r\nimport Sandbox from '../src/sandbox/Sandbox';\r\n\r\nimport chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\n\r\nlet expect = chai.expect;\r\nchai.use(chaiAsPromised);\r\n\r\ndescribe('Sandbox', function() {\r\n  let externalURL = 'hyperty-runtime://sandbox/external';\r\n  let internalURL = 'hyperty-runtime://sandbox/internal';\r\n\r\n  it('deploy and undeploy', function(done) {\r\n    let deploySend;\r\n\r\n    let sb = new Sandbox();\r\n    sb._onPostMessage = (msg) => {\r\n      console.log(msg);\r\n      if (msg.id === 1) {\r\n        expect(msg).to.eql({\r\n          id: 1, type: 'create', from: externalURL, to: internalURL,\r\n          body: { url: 'hyperty://fake-url', sourceCode: '<source code>', config: {init: '<init>'} }\r\n        });\r\n      }\r\n\r\n      if (msg.id  === 2) {\r\n        expect(msg).to.eql({\r\n          id: 2, type: 'delete', from: externalURL, to: internalURL,\r\n          body: { url: 'hyperty://fake-url' }\r\n        });\r\n      }\r\n\r\n      deploySend(msg);\r\n    };\r\n\r\n    let bus = {\r\n      addListener: (url, callback) => {\r\n        expect(url).to.eql(internalURL);\r\n        deploySend = callback;\r\n      },\r\n\r\n      postMessage: (msg) => {\r\n        expect(msg).to.eql({\r\n          id: msg.id, type: 'response', from: internalURL, to: externalURL,\r\n          body: { code: 200 }\r\n        });\r\n\r\n        sb._onMessage(msg);\r\n      },\r\n\r\n      removeAllListenersOf: (url) => {\r\n        expect(url).to.eql('hyperty://fake-url');\r\n      }\r\n    };\r\n\r\n    let sbr = new SandboxRegistry(bus);\r\n    sbr._create = (url, sourceCode, config) => {\r\n      expect(url).to.eql('hyperty://fake-url');\r\n      expect(sourceCode).to.eql('<source code>');\r\n      expect(config).to.eql({init: '<init>'});\r\n      return '<instance>';\r\n    };\r\n\r\n    expect(sb.deployComponent('<source code>', 'hyperty://fake-url', {init: '<init>'}).then((deployReply) => {\r\n      expect(deployReply).to.eql('deployed');\r\n      expect(sbr.components).to.eql({'hyperty://fake-url': '<instance>'});\r\n\r\n      return sb.removeComponent('hyperty://fake-url').then((unDeployReply) => {\r\n        expect(unDeployReply).to.eql('undeployed');\r\n        expect(sbr.components).to.eql({});\r\n      });\r\n    })).notify(done);\r\n  });\r\n\r\n  it('deploy url duplication rejected', function(done) {\r\n    let deploySend;\r\n\r\n    let sb = new Sandbox();\r\n    sb._onPostMessage = (msg) => { deploySend(msg); };\r\n\r\n    let bus = {\r\n      addListener: (url, callback) => {\r\n        deploySend = callback;\r\n      },\r\n\r\n      postMessage: (msg) => {\r\n        sb._onMessage(msg);\r\n      }\r\n    };\r\n\r\n    let sbr = new SandboxRegistry(bus);\r\n    sbr._create = (url, sourceCode, config) => {\r\n      return '<instance>';\r\n    };\r\n\r\n    expect(sb.deployComponent('<source code>', 'hyperty://fake-url', {init: '<init>'}).then((deployReply) => {\r\n      expect(deployReply).to.eql('deployed');\r\n      expect(sbr.components).to.eql({'hyperty://fake-url': '<instance>'});\r\n      return expect(sb.deployComponent('<source code>', 'hyperty://fake-url', {init: '<init>'})).to.be.rejectedWith('Instance hyperty://fake-url already exist!');\r\n    })).notify(done);\r\n  });\r\n});\r\n",
    "static": true,
    "longname": "test/Sandbox.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1050,
    "kind": "testDescribe",
    "name": "describe192",
    "testId": 192,
    "memberof": "test/Sandbox.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/Sandbox.spec.js~describe192",
    "access": null,
    "description": "Sandbox",
    "lineNumber": 10
  },
  {
    "__docId__": 1051,
    "kind": "testIt",
    "name": "it193",
    "testId": 193,
    "memberof": "test/Sandbox.spec.js~describe192",
    "testDepth": 1,
    "static": true,
    "longname": "test/Sandbox.spec.js~describe192.it193",
    "access": null,
    "description": "deploy and undeploy",
    "lineNumber": 14
  },
  {
    "__docId__": 1052,
    "kind": "testIt",
    "name": "it194",
    "testId": 194,
    "memberof": "test/Sandbox.spec.js~describe192",
    "testDepth": 1,
    "static": true,
    "longname": "test/Sandbox.spec.js~describe192.it194",
    "access": null,
    "description": "deploy url duplication rejected",
    "lineNumber": 76
  },
  {
    "__docId__": 1053,
    "kind": "testFile",
    "name": "test/StoreDataObjects.spec.js",
    "content": "import chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\n\r\nimport {generateGUID} from '../src/utils/utils';\r\n\r\nimport StoreDataObjects from '../src/syncher/StoreDataObjects';\r\nimport { runtimeFactory } from './resources/runtimeFactory';\r\n\r\nchai.config.truncateThreshold = 0;\r\n\r\nlet expect = chai.expect;\r\nchai.use(chaiAsPromised);\r\n\r\ndescribe('StoreDataObjects', function() {\r\n\r\n  let storageManager;\r\n  let storeDataObjects;\r\n  let runtimeURL = 'hyperty-runtime://fake-runtime';\r\n  let syncherManagerURL = runtimeURL + '/sm';\r\n\r\n  let resource = 'resource://obj1';\r\n  let userURL = 'user://<domain>/<my-name>';\r\n  let schema = 'schema://fake-schema-url';\r\n  let schemaList = ['schema://fake-schema-url/Communication', 'schema://fake-schema-url/Context', 'schema://fake-schema-url/Connection'];\r\n\r\n  before(() => {\r\n\r\n    storageManager = runtimeFactory.storageManager();\r\n    storeDataObjects = new StoreDataObjects(storageManager);\r\n\r\n  });\r\n\r\n  it('should set dataObject information to be saved on storage', (done) => {\r\n\r\n    let status = 'on';\r\n    let isReporter = true;\r\n    let data = {\r\n      x: 1,\r\n      y: 2,\r\n      name: 'WebRTC'\r\n    };\r\n    let owner = 'hyperty://<domain>/id-3';\r\n    let subscription = 'hyperty://<domain>/id-2';\r\n\r\n    storeDataObjects.set(resource, isReporter, schema, status, data, owner);\r\n    storeDataObjects.update(resource, 'subscriptions', subscription, isReporter);\r\n\r\n    expect(storeDataObjects._storeDataObject.reporters[resource]).have.any.keys('resource', 'isReporter', 'schema');\r\n    done();\r\n\r\n  });\r\n\r\n  it('should set a bundle of information to be saved on storage like reporter', (done) => {\r\n\r\n    let num = 4;\r\n\r\n    for (let i = 0; i < num; i++) {\r\n\r\n      let status = 'on';\r\n      let isReporter = true;\r\n      let data = {x: 1, y: 2};\r\n      let resource = '<scheme>://<domain>/id-' + i;\r\n      let rand = Math.round(Math.random() * 2);\r\n      let randomSchema = schemaList[rand];\r\n      let owner = 'hyperty://<domain>/id-' + (num - i);\r\n      let subscription = 'hyperty://<domain>/id-' + ((num - i) * 2);\r\n\r\n      let type = isReporter ? 'reporters' : 'observers';\r\n\r\n      // resource, isReporter, schema, status, data, subscription, children, childrenResources, subscriberUser\r\n      storeDataObjects.set(resource, isReporter, randomSchema, status, data, owner);\r\n      storeDataObjects.update(resource, 'subscriptions', subscription, isReporter);\r\n\r\n      expect(storeDataObjects._storeDataObject[type][resource]).have.any.keys('resource', 'isReporter', 'schema');\r\n\r\n      if (i === num - 1) {\r\n        console.log('DONE', i);\r\n        done();\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  it('should set a bundle of information to be saved on storage like observers', (done) => {\r\n\r\n    let num = 4;\r\n    let letters = ['A', 'B', 'C', 'D'];\r\n\r\n    for (let i = 0; i < num; i++) {\r\n\r\n      let status = 'on';\r\n      let isReporter = false;\r\n      let data = {x: 1, y: 2};\r\n      let resource = '<scheme>://<domain>/id-' + letters[i];\r\n      let rand = Math.round(Math.random() * 2);\r\n      let randomSchema = schemaList[rand];\r\n      let subscription = 'hyperty://<domain>/id-' + letters[(num - i)];\r\n\r\n      let type = isReporter ? 'reporters' : 'observers';\r\n\r\n      // resource, isReporter, schema, status, data, subscription, children, childrenResources, subscriberUser\r\n      storeDataObjects.set(resource, isReporter, randomSchema, status, data, subscription);\r\n\r\n      expect(storeDataObjects._storeDataObject[type][resource]).have.any.keys('resource', 'isReporter', 'schema');\r\n\r\n      if (i === num - 1) {\r\n        done();\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  it('should update a resource with new Subscription', (done) => {\r\n    let resource = '<scheme>://<domain>/id-2';\r\n    let subscriptions = ['hyperty://<domain>/id-3', 'hyperty://<domain>/id-2'];\r\n    let isReporter = true;\r\n    let type = isReporter ? 'reporters' : 'observers';\r\n\r\n    storeDataObjects.update(resource, 'subscriptions', subscriptions[0], isReporter);\r\n    storeDataObjects.update(resource, 'subscriptions', subscriptions[1], isReporter);\r\n\r\n    console.log('AQUI: ', storeDataObjects._storeDataObject[type][resource]);\r\n\r\n    expect(storeDataObjects._storeDataObject[type][resource].subscriptions).to.contains(subscriptions[0], subscriptions[1]);\r\n    done();\r\n  });\r\n\r\n  it('should update a resource with new Subscriber Users', (done) => {\r\n    let resource = '<scheme>://<domain>/id-2';\r\n    let isReporter = true;\r\n    storeDataObjects.update(resource, 'subscriberUsers', userURL, isReporter);\r\n\r\n    let type = isReporter ? 'reporters' : 'observers';\r\n\r\n    expect(storeDataObjects._storeDataObject[type][resource].subscriberUsers).to.contains(userURL);\r\n    done();\r\n  });\r\n\r\n  // it('should update the data resource', (done) => {\r\n  //   let resource = '<scheme>://<domain>/id-2';\r\n  //   let isReporter = true;\r\n  //   storeDataObjects.updateData(resource, 'subscriberUsers', userURL, isReporter);\r\n  //\r\n  //   let type = isReporter ? 'reporters' : 'observers';\r\n  //\r\n  //   expect(storeDataObjects._storeDataObject[type][resource].subscriberUsers).to.contains(userURL);\r\n  //   done();\r\n  // });\r\n\r\n  it('should get specific dataObject by hypertyURL', (done) => {\r\n\r\n    let msg = {\r\n      type: 'create',\r\n      from: 'hyperty://<domain>/id-2',\r\n      to: syncherManagerURL\r\n    };\r\n\r\n    expect(storeDataObjects.getResourcesByCriteria(msg, true))\r\n    .to.be.fulfilled\r\n    .and.eventually.to.include.keys('<scheme>://<domain>/id-3', 'resource://obj1')\r\n    .and.notify(done);\r\n\r\n  });\r\n\r\n  it('should get specific dataObject by identity', (done) => {\r\n\r\n    let msg = {\r\n      type: 'create',\r\n      from: 'hyperty://<domain>/id-3',\r\n      to: syncherManagerURL,\r\n      body: {\r\n        identity: userURL\r\n      }\r\n\r\n    };\r\n\r\n    expect(storeDataObjects.getResourcesByCriteria(msg, true))\r\n    .to.be.fulfilled\r\n    .and.eventually.to.include.keys('<scheme>://<domain>/id-2')\r\n    .and.notify(done);\r\n\r\n  });\r\n\r\n  it('should get specific dataObject by schema', (done) => {\r\n\r\n    let msg = {\r\n      type: 'create',\r\n      from: 'hyperty://<domain>/id-3',\r\n      to: syncherManagerURL,\r\n      body: {\r\n        schema: schema\r\n      }\r\n\r\n    };\r\n\r\n    expect(storeDataObjects.getResourcesByCriteria(msg, true))\r\n    .to.be.fulfilled\r\n    .and.eventually.to.include.keys(resource)\r\n    .and.notify(done);\r\n\r\n  });\r\n\r\n  it('should get specific dataObject by some data', (done) => {\r\n\r\n    let msg = {\r\n      type: 'create',\r\n      from: 'hyperty://<domain>/id-3',\r\n      to: syncherManagerURL,\r\n      body: {\r\n        value: {\r\n          name: 'WebRTC'\r\n        }\r\n      }\r\n\r\n    };\r\n\r\n    expect(storeDataObjects.getResourcesByCriteria(msg, true))\r\n    .to.be.fulfilled\r\n    .and.eventually.to.include.keys(resource)\r\n    .and.notify(done);\r\n\r\n  });\r\n\r\n  it('should delete a specific value from specific resource', (done) => {\r\n    let resource = '<scheme>://<domain>/id-3';\r\n    let subscription = 'hyperty://<domain>/id-1';\r\n    expect(storeDataObjects.delete(resource, 'subscriptions', subscription)).to.be.fulfilled.and.notify(done);\r\n  });\r\n\r\n  it('should delete a resource', (done) => {\r\n    let resource = '<scheme>://<domain>/id-3';\r\n    expect(storeDataObjects.deleteResource(resource)).to.be.fulfilled.and.notify(done);\r\n  });\r\n\r\n});\r\n",
    "static": true,
    "longname": "test/StoreDataObjects.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1054,
    "kind": "testDescribe",
    "name": "describe195",
    "testId": 195,
    "memberof": "test/StoreDataObjects.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195",
    "access": null,
    "description": "StoreDataObjects",
    "lineNumber": 14
  },
  {
    "__docId__": 1055,
    "kind": "testIt",
    "name": "it196",
    "testId": 196,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it196",
    "access": null,
    "description": "should set dataObject information to be saved on storage",
    "lineNumber": 33
  },
  {
    "__docId__": 1056,
    "kind": "testIt",
    "name": "it197",
    "testId": 197,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it197",
    "access": null,
    "description": "should set a bundle of information to be saved on storage like reporter",
    "lineNumber": 53
  },
  {
    "__docId__": 1057,
    "kind": "testIt",
    "name": "it198",
    "testId": 198,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it198",
    "access": null,
    "description": "should set a bundle of information to be saved on storage like observers",
    "lineNumber": 84
  },
  {
    "__docId__": 1058,
    "kind": "testIt",
    "name": "it199",
    "testId": 199,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it199",
    "access": null,
    "description": "should update a resource with new Subscription",
    "lineNumber": 113
  },
  {
    "__docId__": 1059,
    "kind": "testIt",
    "name": "it200",
    "testId": 200,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it200",
    "access": null,
    "description": "should update a resource with new Subscriber Users",
    "lineNumber": 128
  },
  {
    "__docId__": 1060,
    "kind": "testIt",
    "name": "it201",
    "testId": 201,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it201",
    "access": null,
    "description": "should get specific dataObject by hypertyURL",
    "lineNumber": 150
  },
  {
    "__docId__": 1061,
    "kind": "testIt",
    "name": "it202",
    "testId": 202,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it202",
    "access": null,
    "description": "should get specific dataObject by identity",
    "lineNumber": 165
  },
  {
    "__docId__": 1062,
    "kind": "testIt",
    "name": "it203",
    "testId": 203,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it203",
    "access": null,
    "description": "should get specific dataObject by schema",
    "lineNumber": 184
  },
  {
    "__docId__": 1063,
    "kind": "testIt",
    "name": "it204",
    "testId": 204,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it204",
    "access": null,
    "description": "should get specific dataObject by some data",
    "lineNumber": 203
  },
  {
    "__docId__": 1064,
    "kind": "testIt",
    "name": "it205",
    "testId": 205,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it205",
    "access": null,
    "description": "should delete a specific value from specific resource",
    "lineNumber": 224
  },
  {
    "__docId__": 1065,
    "kind": "testIt",
    "name": "it206",
    "testId": 206,
    "memberof": "test/StoreDataObjects.spec.js~describe195",
    "testDepth": 1,
    "static": true,
    "longname": "test/StoreDataObjects.spec.js~describe195.it206",
    "access": null,
    "description": "should delete a resource",
    "lineNumber": 230
  },
  {
    "__docId__": 1066,
    "kind": "testFile",
    "name": "test/SyncherManager.spec.js",
    "content": "import { runtimeFactory } from './resources/runtimeFactory';\r\nimport {Syncher, DataObjectReporter, DataObjectObserver} from 'service-framework/dist/Syncher';\r\nimport SyncherManager from '../src/syncher/SyncherManager';\r\nimport MessageBus from '../src/bus/MessageBus';\r\n\r\nimport PEP from '../src/policy/PEP';\r\nimport RuntimeCoreCtx from '../src/policy/context/RuntimeCoreCtx';\r\n\r\nimport chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\n\r\nchai.config.truncateThreshold = 0;\r\n\r\nlet expect = chai.expect;\r\nchai.use(chaiAsPromised);\r\n\r\ndescribe('SyncherManager', function() {\r\n  let storageManager = runtimeFactory.storageManager();\r\n\r\n  let schemaURL = 'schema://fake-schema-url';\r\n  let runtimeURL = 'hyperty-runtime://fake-runtime';\r\n\r\n  let objURL = 'resource://obj1';\r\n  let objURLChanges = objURL + '/changes';\r\n\r\n  let hyperURL1 = 'hyperty://h1.domain/h1';\r\n  let hyperURL2 = 'hyperty://h2.domain/h2';\r\n\r\n  let initialData = {\r\n    communication: { name: 'chat-x' },\r\n    x: 10, y: 10\r\n  };\r\n\r\n  let msgNodeResponseFunc = (bus, msg) => {\r\n    if (msg.type === 'subscribe') {\r\n      if (msg.id === 2) {\r\n        //reporter subscribe\r\n        expect(msg).to.contain.all.keys({\r\n          id: 2, type: 'subscribe', from: 'hyperty-runtime://fake-runtime/sm', to: 'domain://msg-node.h1.domain/sm',\r\n          body: { subscribe: [objURL + '/children/children1', objURL + '/children/children2'], source: hyperURL1 }\r\n        });\r\n      } else {\r\n        //observer subscribe\r\n        expect(msg).to.contain.all.keys({\r\n          id: 5, type: 'subscribe', from: 'hyperty-runtime://fake-runtime/sm', to: 'domain://msg-node.obj1/sm',\r\n          body: { subscribe: [objURL + '/changes', objURL + '/children/children1', objURL + '/children/children2'], source: hyperURL2 }\r\n        });\r\n      }\r\n\r\n      //simulate msg-node response\r\n      bus.postMessage({\r\n        id: msg.id, type: 'response', from: msg.to, to: msg.from,\r\n        body: { code: 200 }\r\n      });\r\n    }\r\n  };\r\n\r\n  //fake object allocator -> always return the same URL\r\n  let allocator = {\r\n    create: () => {\r\n      return new Promise((resolve) => {\r\n        resolve({address: [objURL]});\r\n      });\r\n    }\r\n  };\r\n\r\n  let registry = {\r\n    registerDataObject: (identifier, dataObjectschema, dataObjectUrl, dataObjectReporter) => {\r\n      console.log('REGISTRY-OBJECT: ', identifier, dataObjectschema, dataObjectUrl, dataObjectReporter);\r\n      return new Promise((resolve) => {\r\n        resolve('ok');\r\n      });\r\n    }\r\n  };\r\n\r\n  let runtimeRegistry = {\r\n    getPreAuthSubscribers: () => {\r\n      return ['hyperty://domain/hyperty-instance'];\r\n    },\r\n    getHypertyName: () => {\r\n      return 'HypertyChat';\r\n    },\r\n    isDataObjectURL: (dataObjectURL) => {\r\n      let splitURL = dataObjectURL.split('://');\r\n      return splitURL[0] === 'comm';\r\n    },\r\n    registerSubscribedDataObject: () => {},\r\n    registerSubscriber: () => {},\r\n    runtimeURL: 'runtime://localhost/7601'\r\n  };\r\n\r\n  let identityModule = {\r\n    decryptMessage: (message) => {\r\n      return new Promise((resolve) => {\r\n        resolve(message);\r\n      });\r\n    },\r\n    encryptMessage: (message) => {\r\n      return new Promise((resolve) => {\r\n        resolve(message);\r\n      });\r\n    },\r\n    getToken: () => {\r\n      return new Promise((resolve) => {\r\n        resolve({ userProfile: {username: 'user@domain' } });\r\n      });\r\n    }\r\n  };\r\n\r\n  let catalog = {\r\n    getDataSchemaDescriptor: (schema) => {\r\n      console.log('REQUEST-SCHEMA: ', schema);\r\n      return new Promise((resolve, reject) => {\r\n        if (schema) {\r\n          resolve({ sourcePackage: { sourceCode: {\r\n            properties: {\r\n              scheme: { constant: 'resource' },\r\n              children: { constant: ['children1', 'children2'] }\r\n            }\r\n          }}});\r\n        } else {\r\n          reject('No schema provided');\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  let policyEngine = new PEP(new RuntimeCoreCtx(identityModule, runtimeRegistry, storageManager, runtimeFactory.runtimeCapabilities()));\r\n\r\n  let handlers = [\r\n\r\n    // Policy message authorise\r\n    function(ctx) {\r\n      policyEngine.authorise(ctx.msg).then(function(changedMgs) {\r\n        ctx.msg = changedMgs;\r\n        ctx.next();\r\n      }).catch(function(reason) {\r\n        console.error(reason);\r\n        ctx.fail(reason);\r\n      });\r\n    }\r\n  ];\r\n\r\n  it('reporter read', function(done) {\r\n    let bus = new MessageBus();\r\n    bus._onPostMessage = (msg) => {\r\n      console.log('_onPostMessage: ', msg);\r\n      msgNodeResponseFunc(bus, msg);\r\n    };\r\n\r\n    new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n    let sync2 = new Syncher(hyperURL2, bus, { runtimeURL: runtimeURL });\r\n    let sync1 = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    sync1.create(schemaURL, [], initialData).then((dor) => {\r\n      console.log('on-create-reply', dor.onRead);\r\n      dor.onRead((event) => {\r\n        console.log('on-read');\r\n        event.accept();\r\n      });\r\n\r\n      sync2.read(dor.url).then((data) => {\r\n        console.log('on-read-reply', data);\r\n        expect(data).to.contain.all.keys({ communication: { name: 'chat-x' }, x: 10, y: 10 });\r\n        done();\r\n      });\r\n    });\r\n  });\r\n\r\n  it('reporter observer integration', function(done) {\r\n    let bus = new MessageBus();\r\n    bus._onPostMessage = (msg) => {\r\n      console.log('_onPostMessage: ', msg);\r\n      msgNodeResponseFunc(bus, msg);\r\n    };\r\n\r\n    new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n    let sync2 = new Syncher(hyperURL2, bus, { runtimeURL: runtimeURL });\r\n    sync2.onNotification((notifyEvent) => {\r\n      console.log('on-create-notify: ', notifyEvent);\r\n\r\n      notifyEvent.ack();\r\n\r\n      sync2.subscribe(schemaURL, notifyEvent.url, true, false).then((doo) => {\r\n        console.log('on-subscribe-reply', doo, doo.data);\r\n\r\n        doo.onChange('*', (changeEvent) => {\r\n          console.log('on-change: ', JSON.stringify(changeEvent));\r\n          expect(changeEvent).to.contain.all.keys({ cType: 'add', oType: 'object', field: 'test', data: ['a', 'b', 'c'] });\r\n          expect(doo.data).to.contain.all.keys({ communication: { name: 'chat-x' }, x: 10, y: 10, test: ['a', 'b', 'c'] });\r\n          done();\r\n        });\r\n      });\r\n    });\r\n\r\n    let sync1 = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    sync1.create(schemaURL, [], initialData, true, false).then((dor) => {\r\n      console.log('on-create-reply', dor);\r\n      dor.inviteObservers([hyperURL2]);\r\n\r\n      dor.onSubscription((subscribeEvent) => {\r\n        console.log('on-subscribe: ', subscribeEvent);\r\n\r\n        //we may have some problems in the time sequence here.\r\n        //change-msg can reach the observer first\r\n        subscribeEvent.accept();\r\n\r\n        // TODO: We had the settimeout because when the proxyobserve trigger will trigger with this version of object..\r\n        // this hack should make it trigger in next cycle;\r\n        setTimeout(() => {\r\n          dor.data.test = ['a', 'b', 'c'];\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  it('should resume observers', function(done) {\r\n\r\n    let bus = new MessageBus();\r\n    bus._onMessage((a) => {\r\n      console.log(a);\r\n    });\r\n\r\n    bus._onPostMessage = (msg) => {\r\n      console.log('_onPostMessage: ', msg);\r\n      msgNodeResponseFunc(bus, msg);\r\n    };\r\n\r\n    new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n    let sync2 = new Syncher(hyperURL2, bus, { runtimeURL: runtimeURL });\r\n    sync2.resumeObservers({}).then((doo) => {\r\n\r\n      console.log('on-subscribe-resume-reply', doo, doo.data);\r\n\r\n      doo.onChange('*', (changeEvent) => {\r\n        console.log('on-change: ', JSON.stringify(changeEvent), doo.data);\r\n        expect(changeEvent).to.contain.all.keys({ cType: 'add', oType: 'object', field: 'test', data: ['a', 'b', 'c'] });\r\n        expect(doo.data).to.contain.all.keys({ communication: { name: 'chat-x' }, x: 10, y: 10, test: ['a', 'b', 'c'] });\r\n\r\n        done();\r\n      });\r\n\r\n    });\r\n\r\n    let sync1 = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    sync1.create(schemaURL, [], initialData).then((dor) => {\r\n      console.log('on-create-resume-reply', dor);\r\n      dor.inviteObservers([hyperURL2]);\r\n\r\n      dor.onRead((readEvent) => {\r\n        readEvent.accept();\r\n      });\r\n\r\n      dor.onSubscription((subscribeEvent) => {\r\n        console.log('on-resume-subscribe: ', subscribeEvent);\r\n\r\n        //we may have some problems in the time sequence here.\r\n        //change-msg can reach the observer first\r\n        subscribeEvent.accept();\r\n\r\n        setTimeout(() => {\r\n          dor.data.test = ['a', 'b', 'c'];\r\n        });\r\n\r\n      });\r\n    });\r\n\r\n  });\r\n\r\n  it('should resume reporters', function(done) {\r\n\r\n    let bus = new MessageBus();\r\n    bus._onMessage((a) => {\r\n      console.log('AQUI:', a);\r\n    });\r\n\r\n    bus._onPostMessage = (msg) => {\r\n      console.log('_onPostMessage: ', msg);\r\n      msgNodeResponseFunc(bus, msg);\r\n    };\r\n\r\n    new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n    let sync1 = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n\r\n    sync1.resumeReporters({}).then((dor) => {\r\n      dor.data.newTest = ['a', 'b', 'c'];\r\n      expect(dor.data).to.contain.all.keys({ communication: { name: 'chat-x' }, x: 10, y: 10, test: ['a', 'b', 'c'], newTest: ['a', 'b', 'c'] });\r\n      done();\r\n    });\r\n\r\n    // sync1.create(schemaURL, [], initialData).then((dor) => {\r\n    //   console.log('on-create-resume-reply', dor);\r\n    //   dor.inviteObservers([hyperURL2]);\r\n    //\r\n    //   dor.onRead((readEvent) => {\r\n    //     readEvent.accept();\r\n    //   });\r\n    //\r\n    //   dor.onSubscription((subscribeEvent) => {\r\n    //     console.log('on-resume-subscribe: ', subscribeEvent);\r\n    //\r\n    //     //we may have some problems in the time sequence here.\r\n    //     //change-msg can reach the observer first\r\n    //     subscribeEvent.accept();\r\n    //     dor.data.test = ['a', 'b', 'c'];\r\n    //   });\r\n    // });\r\n\r\n  });\r\n\r\n  // TODO we should update the ProxyObject on service-framework to make test pass\r\n  // TODO or we should update the tests messages, because the order;\r\n  it.skip('verify produced sync messages', function(done) {\r\n    this.timeout(10000);\r\n\r\n    let seq = 0;\r\n    let data;\r\n\r\n    let bus = {\r\n      postMessage: (msg, replyCallback) => {\r\n        seq++;\r\n        console.log('3-postMessage: (seq === ' + seq + ')', JSON.stringify(msg));\r\n\r\n        if (seq === 1) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 1, source: hyperURL1, attribute: '1',\r\n              value: {\r\n                name: 'Micael',\r\n                birthdate: '28-02-1981',\r\n                email: 'micael-xxx@gmail.com',\r\n                phone: 911000000,\r\n                obj1: { name: 'xpto'}\r\n              }\r\n            }\r\n          });\r\n        }\r\n\r\n        if (seq === 2) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 2, source: hyperURL1, attribute: '2',\r\n              value: {\r\n                name: 'Luis Duarte',\r\n                birthdate: '02-12-1991',\r\n                email: 'luis-xxx@gmail.com',\r\n                phone: 910000000,\r\n                obj1: { name: 'xpto' }\r\n              }\r\n            }\r\n          });\r\n\r\n          //apply changes...\r\n          data['1'].name = 'Micael Pedrosa';\r\n          data['1'].birthdate = new Date(1982, 1, 28);\r\n          data['1'].obj1.name = 'XPTO';\r\n          delete data['2'];\r\n        }\r\n\r\n        if (seq === 3) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 3, source: hyperURL1, attribute: '2' }\r\n          });\r\n        }\r\n\r\n        if (seq === 4) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 4, source: hyperURL1, attribute: '1.name', value: 'Micael Pedrosa' }\r\n          });\r\n        }\r\n\r\n        if (seq === 5) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 5, source: hyperURL1, attribute: '1.birthdate', value: '1982-02-28T00:00:00.000Z' }\r\n          });\r\n        }\r\n\r\n        if (seq === 6) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 6, source: hyperURL1, attribute: '1.obj1.name', value: 'XPTO' }\r\n          });\r\n\r\n          //apply changes...\r\n          data['1'].arr = [1, 0, { x: 10, y: 20 }];\r\n        }\r\n\r\n        if (seq === 7) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 7, source: hyperURL1, attribute: '1.arr', value: [1, 0, {x: 10, y: 20}] }\r\n          });\r\n\r\n          //apply changes...\r\n          // data['1'].arr[1] = 2;\r\n          data['1'].arr[1] = 2;\r\n        }\r\n\r\n        if (seq === 8) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 8, source: hyperURL1, attributeType: 'array', attribute: '1.arr.1', value: 2 }\r\n          });\r\n\r\n          //apply changes...\r\n          data['1'].arr.push(3);\r\n          data['1'].arr.push({ x: 1, y: 2 });\r\n        }\r\n\r\n        if (seq === 9) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 9, source: hyperURL1, attributeType: 'array', operation: 'add', attribute: '1.arr.3', value: [3] }\r\n          });\r\n        }\r\n\r\n        if (seq === 10) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 10, source: hyperURL1, attributeType: 'array', operation: 'add', attribute: '1.arr.4', value: [{x: 1, y: 2}] }\r\n          });\r\n\r\n          //apply changes...\r\n          data['1'].arr.splice(1, 2, 10, 11, 12);\r\n          data['1'].arr[5].x = 10;\r\n        }\r\n\r\n        if (seq === 11) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 11, source: hyperURL1, attributeType: 'array', operation: 'remove', attribute: '1.arr.1', value: 2 }\r\n          });\r\n        }\r\n\r\n        if (seq === 12) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 12, source: hyperURL1, attributeType: 'array', operation: 'add', attribute: '1.arr.1', value: [10, 11, 12] }\r\n          });\r\n        }\r\n\r\n        if (seq === 13) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 13, source: hyperURL1, attribute: '1.arr.5.x', value: 10 }\r\n          });\r\n\r\n          //apply changes...\r\n          data['1'].arr.pop();\r\n        }\r\n\r\n        if (seq === 14) {\r\n          expect(msg).to.contain.all.keys({\r\n            type: 'update', from: objURL, to: objURLChanges,\r\n            body: { version: 14, source: hyperURL1, attributeType: 'array', operation: 'remove', attribute: '1.arr.5', value: 1 }\r\n          });\r\n\r\n          done();\r\n        }\r\n      },\r\n\r\n      addListener: (url, callback) => {\r\n        console.log('3-addListener', url);\r\n      }\r\n    };\r\n\r\n    //BEGIN: skip message system (already tested in previous units) and manually create a reporter and subscription, this should not be done in real code.\r\n    let sync = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    let reporter = new DataObjectReporter(sync, objURL, schemaURL, 'on', {}, []);\r\n    reporter.subscriptions[hyperURL2] = { status: 'on' };\r\n    sync.reporters[objURL] = reporter;\r\n\r\n    //END\r\n    data = reporter.data;\r\n\r\n    //apply changes...\r\n    data['1'] = { name: 'Micael', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, arr: []};\r\n    data['1'].obj1 = { name: 'xpto' };\r\n    data['2'] = { name: 'Luis Duarte', birthdate: '02-12-1991', email: 'luis-xxx@gmail.com', phone: 910000000, obj1: { name: 'xpto' } };\r\n  });\r\n\r\n  // TODO we should update the ProxyObject on service-framework to make test pass\r\n  // TODO or we should update the tests messages, because the order;\r\n  it.skip('verify consumed sync messages', function(done) {\r\n    this.timeout(10000);\r\n\r\n    let post;\r\n    let bus = {\r\n      addListener: (url, callback) => {\r\n        console.log('4-addListener', url);\r\n\r\n        if (url === objURLChanges) {\r\n          post = callback;\r\n        }\r\n      }\r\n    };\r\n\r\n    //BEGIN: skip message system (already tested in previous units) and manually create an observer, this should not be done in real code.\r\n    let seq = 0;\r\n    let data;\r\n    let compacted = false;\r\n\r\n    let sync = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    let observer = new DataObjectObserver(sync, objURL, schemaURL, 'on', { data: {}, childrens: {} }, [], 0);\r\n    sync.observers[objURL] = observer;\r\n\r\n    observer.onChange('*', (event) => {\r\n      seq++;\r\n      console.log('4-onChange: (seq === ' + seq + ')', JSON.stringify(event));\r\n\r\n      if (seq === 1) {\r\n        expect(event).to.contain.all.keys({ cType: 'add', oType: 'object', field: '1', data: { name: 'Micael', birthdate: '28-01-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: { name: 'xpto' } } });\r\n      }\r\n\r\n      if (seq === 2) {\r\n        expect(event).to.contain.all.keys({ cType: 'add', oType: 'object', field: '2', data: { name: 'Luis Duarte', birthdate: '02-12-1991', email: 'luis-xxx@gmail.com', phone: 910000000, obj1: { name: 'xpto' } } });\r\n\r\n        //verify changes...\r\n        expect(data).to.contain.all.keys({\r\n          1: { name: 'Micael', birthdate: '28-01-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: { name: 'xpto' } },\r\n          2: { name: 'Luis Duarte', birthdate: '02-12-1991', email: 'luis-xxx@gmail.com', phone: 910000000, obj1: { name: 'xpto' } }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 3, attribute: '2' }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 4, attribute: '1.name', value: 'Micael Pedrosa' }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 5, attribute: '1.birthdate', value: '28-02-1981' }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 6, attribute: '1.obj1.name', value: 'XPTO' }\r\n        });\r\n      }\r\n\r\n      if (seq === 3) {\r\n        expect(event).to.contain.all.keys({ cType: 'remove', oType: 'object', field: '2' });\r\n      }\r\n\r\n      if (seq === 4) {\r\n        expect(event).to.contain.all.keys({ cType: 'update', oType: 'object', field: '1.name', data: 'Micael Pedrosa' });\r\n      }\r\n\r\n      if (seq === 5) {\r\n        expect(event).to.contain.all.keys({ cType: 'update', oType: 'object', field: '1.birthdate', data: '28-02-1981' });\r\n      }\r\n\r\n      if (seq === 6) {\r\n        expect(event).to.contain.all.keys({ cType: 'update', oType: 'object', field: '1.obj1.name', data: 'XPTO' });\r\n\r\n        //verify changes...\r\n        expect(data).to.contain.all.keys({\r\n          1: { name: 'Micael Pedrosa', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: { name: 'XPTO' } }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 7, attribute: '1.arr', value: [1, 0, { x: 10, y: 20 }] }\r\n        });\r\n      }\r\n\r\n      if (seq === 7) {\r\n        expect(event).to.contain.all.keys({ cType: 'add', oType: 'object', field: '1.arr', data: [1, 0, { x: 10, y: 20 }] });\r\n\r\n        //verify changes...\r\n        expect(data).to.contain.all.keys({\r\n          1: { name: 'Micael Pedrosa', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'XPTO'}, arr: [1, 0, { x: 10, y: 20 }] }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 8, attributeType: 'array', attribute: '1.arr.1', value: 2 }\r\n        });\r\n      }\r\n\r\n      if (seq === 8) {\r\n        expect(event).to.contain.all.keys({ cType: 'update', oType: 'array', field: '1.arr.1', data: 2 });\r\n\r\n        //verify changes...\r\n        expect(data).to.contain.all.keys({\r\n          1: { name: 'Micael Pedrosa', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'XPTO'}, arr: [1, 2, { x: 10, y: 20 }] }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 9, attributeType: 'array', operation: 'add', attribute: '1.arr.3', value: [3] }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 10, attributeType: 'array', operation: 'add', attribute: '1.arr.4', value: [{ x: 1, y: 2 }] }\r\n        });\r\n      }\r\n\r\n      if (seq === 9) {\r\n        if (event.data.length === 1) {\r\n          expect(event).to.contain.all.keys({ cType: 'add', oType: 'array', field: '1.arr.3', data: [3] });\r\n        } else {\r\n          //it's OK to compact 2 messages...\r\n          expect(event).to.contain.all.keys({ cType: 'add', oType: 'array', field: '1.arr.3', data: [3, { x: 1, y: 2 }]});\r\n          compacted = true;\r\n        }\r\n      }\r\n\r\n      if (seq === 10) {\r\n        if (!compacted) {\r\n          expect(event).to.contain.all.keys({ cType: 'add', oType: 'array', field: '1.arr.4', data: [{ x: 1, y: 2 }] });\r\n        }\r\n\r\n        compacted = false;\r\n\r\n        //verify changes...\r\n        expect(data).to.contain.all.keys({\r\n          1: { name: 'Micael Pedrosa', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: { name: 'XPTO' }, arr: [1, 2, { x: 10, y: 20 }, 3, { x: 1, y: 2 }]}\r\n        });\r\n\r\n        done();\r\n\r\n        /*\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 11, attributeType: 'array', operation: 'remove', attribute: '1.arr.1', value: 2 }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 12, attributeType: 'array', operation: 'add', attribute: '1.arr.1', value: [10, 11, 12] }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 13, attribute: '1.arr.5.x', value: 10 }\r\n        });\r\n        */\r\n      }\r\n\r\n      /*\r\n      if (seq === 11) {\r\n        expect(event).to.contain.all.keys({ cType: 'remove', oType: 'array', field: '1.arr.1', data: 2 });\r\n      }\r\n\r\n      if (seq === 12) {\r\n        expect(event).to.contain.all.keys({ cType: 'add', oType: 'array', field: '1.arr.1', data: [10, 11, 12] });\r\n      }\r\n\r\n      if (seq === 13) {\r\n        expect(event).to.contain.all.keys({ cType: 'update', oType: 'object', field: '1.arr.5.x', data: 10 });\r\n\r\n        //verify changes...\r\n        expect(data).to.contain.all.keys({\r\n          1: { name: 'Micael Pedrosa', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: { name: 'XPTO' }, arr: [1, 10, 11, 12, 3, { x: 10, y: 2 }] }\r\n        });\r\n\r\n        post({\r\n          type: 'update', from: objURL, to: objURLChanges,\r\n          body: { version: 14, attributeType: 'array', operation: 'remove', attribute: '1.arr.5', value: 1 }\r\n        });\r\n      }\r\n\r\n      if (seq === 14) {\r\n        expect(event).to.contain.all.keys({ cType: 'remove', oType: 'array', field: '1.arr.5', data: 1 });\r\n\r\n        //verify changes...\r\n        expect(data).to.contain.all.keys({\r\n          1: { name: 'Micael Pedrosa', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: { name: 'XPTO' }, arr: [1, 10, 11, 12, 3] }\r\n        });\r\n\r\n        done();\r\n      }\r\n      */\r\n    });\r\n\r\n    //END\r\n    data = observer.data;\r\n\r\n    post({\r\n      type: 'update', from: objURL, to: objURLChanges,\r\n      body: { version: 1, attribute: '1',\r\n        value: {\r\n          name: 'Micael',\r\n          birthdate: '28-01-1981',\r\n          email: 'micael-xxx@gmail.com',\r\n          phone: 911000000,\r\n          obj1: { name: 'xpto'}\r\n        }\r\n      }\r\n    });\r\n\r\n    post({\r\n      type: 'update', from: objURL, to: objURLChanges,\r\n      body: { version: 2, attribute: '2',\r\n        value: {\r\n          name: 'Luis Duarte',\r\n          birthdate: '02-12-1991',\r\n          email: 'luis-xxx@gmail.com',\r\n          phone: 910000000,\r\n          obj1: { name: 'xpto' }\r\n        }\r\n      }\r\n    });\r\n  });\r\n\r\n  it('reporter addChild', function(done) {\r\n    let bus = new MessageBus();\r\n    bus._onPostMessage = (msg) => {\r\n      console.log('5-_onPostMessage: ', msg);\r\n      msgNodeResponseFunc(bus, msg);\r\n    };\r\n\r\n    new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n    let sync1 = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    sync1.create(schemaURL, [], initialData).then((dor) => {\r\n      console.log('on-create-reply');\r\n      dor.addChild('children1', {message: 'my message'}).then((doc) => {\r\n        console.log('on-addChild-reply', doc);\r\n        done();\r\n      });\r\n    });\r\n  });\r\n\r\n  it('observer addChild', function(done) {\r\n    let bus = new MessageBus();\r\n    bus._onPostMessage = (msg) => {\r\n      console.log('6-_onPostMessage: ', msg);\r\n      msgNodeResponseFunc(bus, msg);\r\n    };\r\n\r\n    new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n    let sync2 = new Syncher(hyperURL2, bus, { runtimeURL: runtimeURL });\r\n    sync2.onNotification((notifyEvent) => {\r\n      console.log('on-create-notify: ', notifyEvent);\r\n      notifyEvent.ack();\r\n\r\n      sync2.subscribe(schemaURL, notifyEvent.url).then((doo) => {\r\n        console.log('on-subscribe-reply');\r\n        doo.addChild('children1', { message: 'Hello World!' }).then((doc) => {\r\n          console.log('on-local-addChild');\r\n          doc.onResponse((event) => {\r\n            console.log('on-remote-addChild-reply', event);\r\n            expect(event).to.contain.all.keys({ type: 'response', url: hyperURL1, code: 200 });\r\n            done();\r\n          });\r\n        });\r\n      });\r\n    });\r\n\r\n    let sync1 = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    sync1.create(schemaURL, [hyperURL2], initialData).then((dor) => {\r\n      console.log('on-create-reply');\r\n      dor.onSubscription((subscribeEvent) => {\r\n        dor.onAddChild((event) => {\r\n          console.log('on-remote-addChild', event);\r\n          expect(event).to.contain.all.keys({ type: 'create', from: hyperURL2, url: 'resource://obj1/children/children1', childId: hyperURL2 + '#1', value: { message: 'Hello World!' } });\r\n        });\r\n\r\n        console.log('on-subscribe: ', subscribeEvent);\r\n        subscribeEvent.accept();\r\n      });\r\n    });\r\n  });\r\n\r\n  it('children deltas generate and process', function(done) {\r\n    let bus = new MessageBus();\r\n    bus.pipeline.handlers = handlers;\r\n\r\n    bus._onPostMessage = (msg) => {\r\n      console.log('7-_onPostMessage: ', msg);\r\n      msgNodeResponseFunc(bus, msg);\r\n    };\r\n\r\n    new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n    let sync2 = new Syncher(hyperURL2, bus, { runtimeURL: runtimeURL });\r\n    sync2.onNotification((notifyEvent) => {\r\n      notifyEvent.ack();\r\n\r\n      sync2.subscribe(schemaURL, notifyEvent.url).then((doo) => {\r\n        doo.addChild('children1', { message: 'Hello Micael!' }).then((doc) => {\r\n          doc.data.message = 'Hello Luis!';\r\n        });\r\n      });\r\n    });\r\n\r\n    let sync1 = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    sync1.create(schemaURL, [hyperURL2], initialData).then((dor) => {\r\n      dor.onSubscription((subscribeEvent) => {\r\n        dor.onAddChild((event) => {\r\n          let children1 = dor.childrens[event.childId];\r\n          children1.onChange((changeEvent) => {\r\n            console.log('onChange: ', changeEvent);\r\n            expect(changeEvent).to.contain.all.keys({ cType: 'update', oType: 'object', field: 'message', data: 'Hello Luis!' });\r\n            expect(children1.data).to.contain.all.keys({ message: 'Hello Luis!' });\r\n            done();\r\n          });\r\n        });\r\n\r\n        subscribeEvent.accept();\r\n      });\r\n    });\r\n  });\r\n\r\n  it('create and delete', function(done) {\r\n    let deleted = false;\r\n\r\n    let bus = new MessageBus();\r\n    bus.pipeline.handlers = handlers;\r\n\r\n    bus._onPostMessage = (msg) => {\r\n      console.log('8-_onPostMessage: ', msg);\r\n      if (msg.type === 'subscribe') {\r\n        bus.postMessage({\r\n          id: msg.id, type: 'response', from: msg.to, to: msg.from,\r\n          body: { code: 200 }\r\n        });\r\n      } else if (msg.type === 'delete') {\r\n        //expect delete message to msg-node\r\n        if (msg.from === runtimeURL + '/sm') {\r\n          expect(msg.to).to.eql('domain://msg-node.h1.domain/object-address-allocation');\r\n          expect(msg.body.resource).to.eql(objURL);\r\n        }\r\n\r\n        if (msg.from === objURL + '/subscription') {\r\n          deleted = true;\r\n        }\r\n      }\r\n    };\r\n\r\n    new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n    let sync2 = new Syncher(hyperURL2, bus, { runtimeURL: runtimeURL });\r\n    sync2.onNotification((notifyEvent) => {\r\n      console.log('onNotification: ', notifyEvent);\r\n      if (notifyEvent.type === 'create') {\r\n        notifyEvent.ack(100);\r\n        sync2.subscribe(schemaURL, notifyEvent.url).then((doo) => {\r\n          console.log('subscribe: ', doo.url);\r\n        });\r\n      } else if (notifyEvent.type === 'delete') {\r\n        notifyEvent.ack(100);\r\n        expect(deleted).to.eql(true);\r\n        done();\r\n      }\r\n    });\r\n\r\n    let sync1 = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    sync1.create(schemaURL, [hyperURL2], initialData).then((dor) => {\r\n      console.log('create: ', dor.url);\r\n      dor.onSubscription((subscribeEvent) => {\r\n        console.log('onSubscription: ', subscribeEvent);\r\n        subscribeEvent.accept();\r\n\r\n        setTimeout(() => {\r\n          expect(sync1.reporters[dor.url]).to.eql(dor);\r\n          dor.delete();\r\n          delete sync1.reporters[dor.url];\r\n          expect(sync1.reporters[dor.url]).to.be.empty;\r\n          console.log('reporter-deleted');\r\n        }, 100);\r\n\r\n      });\r\n    });\r\n  });\r\n\r\n  it('subscribe and unsubscribe', function(done) {\r\n    let bus = new MessageBus();\r\n    bus.pipeline.handlers = handlers;\r\n\r\n    bus._onPostMessage = (msg) => {\r\n      console.log('8-_onPostMessage: ', msg);\r\n      if (msg.type === 'subscribe') {\r\n        bus.postMessage({\r\n          id: msg.id, type: 'response', from: msg.to, to: msg.from,\r\n          body: { code: 200 }\r\n        });\r\n      } else if (msg.type === 'unsubscribe') {\r\n        //expect delete message to msg-node\r\n        expect(msg.from).to.eql(runtimeURL + '/sm');\r\n        expect(msg.to).to.eql('domain://msg-node.h2.domain/sm');\r\n        expect(msg.body.resource).to.eql(objURL);\r\n        done();\r\n      }\r\n    };\r\n\r\n    new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n    let sync2 = new Syncher(hyperURL2, bus, { runtimeURL: runtimeURL });\r\n    sync2.onNotification((notifyEvent) => {\r\n      console.log('onNotification: ', notifyEvent);\r\n      sync2.subscribe(schemaURL, notifyEvent.url).then((doo) => {\r\n        console.log('subscribe: ', doo.url);\r\n        doo.unsubscribe();\r\n      });\r\n    });\r\n\r\n    let sync1 = new Syncher(hyperURL1, bus, { runtimeURL: runtimeURL });\r\n    sync1.create(schemaURL, [hyperURL2], initialData).then((dor) => {\r\n      console.log('create: ', dor.url);\r\n      dor.onSubscription((subscribeEvent) => {\r\n        console.log('onSubscription: ', subscribeEvent);\r\n        subscribeEvent.accept();\r\n      });\r\n    });\r\n  });\r\n\r\n  describe('should use the storageManager', function() {\r\n\r\n    let hyperties = {};\r\n\r\n    // let sync1DataObjectReporter;\r\n    // let sync2DataObjectObserver;\r\n    // let sync3DataObjectObserver;\r\n\r\n    it('should save the url on storageManager', function(done) {\r\n\r\n      let bus = new MessageBus();\r\n      bus.pipeline.handlers = handlers;\r\n\r\n      bus._onPostMessage = function(msg)  {\r\n        console.log('8-_onPostMessage: ', msg);\r\n        if (msg.type === 'subscribe') {\r\n          bus.postMessage({\r\n            id: msg.id, type: 'response', from: msg.to, to: msg.from,\r\n            body: { code: 200 }\r\n          });\r\n        }\r\n      };\r\n\r\n      function guid() {\r\n        function s4() {\r\n          return Math.floor((1 + Math.random()) * 0x10000)\r\n            .toString(16)\r\n            .substring(1);\r\n        }\r\n        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\r\n          s4() + '-' + s4() + s4() + s4();\r\n      }\r\n\r\n      let objURL = 'resource://domain/' + guid();\r\n\r\n      //fake object allocator -> always return the same URL\r\n      let allocator = {\r\n        create: () => {\r\n          return new Promise((resolve) => {\r\n            hyperties.object = objURL;\r\n            resolve({address: [objURL]});\r\n          });\r\n        }\r\n      };\r\n\r\n      new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n      let hypertyURL3 = 'hyperty://h1.domain/' + guid();\r\n      hyperties.h3 = hypertyURL3;\r\n      let sync3 = new Syncher(hypertyURL3, bus, { runtimeURL: runtimeURL });\r\n      sync3.onNotification((notifyEvent) => {\r\n        sync3.subscribe(schemaURL, notifyEvent.url).then((doo) => {\r\n          //sync3DataObjectObserver = doo;\r\n          console.log('sync3 subscribe: ', doo.url);\r\n          done();\r\n        });\r\n      });\r\n\r\n      let hypertyURL2 = 'hyperty://h1.domain/' + guid();\r\n      hyperties.h2 = hypertyURL2;\r\n      let sync2 = new Syncher(hypertyURL2, bus, { runtimeURL: runtimeURL });\r\n      sync2.onNotification((notifyEvent) => {\r\n        sync2.subscribe(schemaURL, notifyEvent.url).then((doo) => {\r\n          //sync2DataObjectObserver = doo;\r\n          console.log('sync2 subscribe:', doo.url);\r\n        });\r\n      });\r\n\r\n      let hypertyURL1 = 'hyperty://h1.domain/' + guid();\r\n      hyperties.h1 = hypertyURL1;\r\n      let sync1 = new Syncher(hypertyURL1, bus, { runtimeURL: runtimeURL });\r\n      sync1.create(schemaURL, [hypertyURL2, hypertyURL3], initialData).then((dor) => {\r\n        // sync1DataObjectReporter = dor;\r\n        dor.onSubscription((subscribeEvent) => {\r\n          subscribeEvent.accept();\r\n        });\r\n      });\r\n    });\r\n\r\n    it('should resume the url stored on storageManager', (done) => {\r\n\r\n      let bus = new MessageBus();\r\n      bus.pipeline.handlers = handlers;\r\n      bus._onPostMessage = (msg) => {\r\n        console.log('10-_onPostMessage: ', msg);\r\n\r\n        if (msg.type === 'subscribe') {\r\n          bus.postMessage({\r\n            id: msg.id, type: 'response', from: msg.to, to: msg.from,\r\n            body: { code: 200 }\r\n          });\r\n        }\r\n\r\n        if (msg.type === 'update') {\r\n          expect(msg.from).to.eql(hyperties.object);\r\n          expect(msg.to).to.eql(hyperties.object + '/changes');\r\n          done();\r\n        }\r\n\r\n      };\r\n\r\n      //fake object allocator -> always return the same URL\r\n      let allocator = {\r\n        create: function() {\r\n          return new Promise(function(resolve) {\r\n            resolve({address: [hyperties.object]});\r\n          });\r\n        }\r\n      };\r\n\r\n      new SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator);\r\n\r\n      let sync3 = new Syncher(hyperties.h3, bus, { runtimeURL: runtimeURL });\r\n      sync3.onNotification((notifyEvent) => {\r\n        sync3.subscribe(schemaURL, notifyEvent.url).then((doo) => {\r\n          doo.onChange('*', function(changes) {\r\n            console.log('Sync 3: ', changes);\r\n          });\r\n          console.log('sync3 subscribe: ', doo.url);\r\n        });\r\n      });\r\n\r\n      let sync2 = new Syncher(hyperties.h2, bus, { runtimeURL: runtimeURL });\r\n      sync2.onNotification((notifyEvent) => {\r\n        sync2.subscribe(schemaURL, notifyEvent.url).then((doo) => {\r\n          doo.onChange('*', function(changes) {\r\n            console.log('Sync 2: ', changes);\r\n          });\r\n          console.log('sync2 subscribe:', doo.url);\r\n        });\r\n      });\r\n\r\n      let sync1 = new Syncher(hyperties.h1, bus, { runtimeURL: runtimeURL });\r\n      sync1.create(schemaURL, [hyperties.h2, hyperties.h3], initialData).then((dor) => {\r\n\r\n        dor.onSubscription((subscribeEvent) => {\r\n          subscribeEvent.accept();\r\n\r\n          dor.data.x = 20;\r\n        });\r\n      });\r\n\r\n    });\r\n\r\n  });\r\n\r\n});\r\n",
    "static": true,
    "longname": "test/SyncherManager.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1067,
    "kind": "testDescribe",
    "name": "describe207",
    "testId": 207,
    "memberof": "test/SyncherManager.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207",
    "access": null,
    "description": "SyncherManager",
    "lineNumber": 17
  },
  {
    "__docId__": 1068,
    "kind": "testIt",
    "name": "it208",
    "testId": 208,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.it208",
    "access": null,
    "description": "reporter read",
    "lineNumber": 144
  },
  {
    "__docId__": 1069,
    "kind": "testIt",
    "name": "it209",
    "testId": 209,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.it209",
    "access": null,
    "description": "reporter observer integration",
    "lineNumber": 170
  },
  {
    "__docId__": 1070,
    "kind": "testIt",
    "name": "it210",
    "testId": 210,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.it210",
    "access": null,
    "description": "should resume observers",
    "lineNumber": 218
  },
  {
    "__docId__": 1071,
    "kind": "testIt",
    "name": "it211",
    "testId": 211,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.it211",
    "access": null,
    "description": "should resume reporters",
    "lineNumber": 272
  },
  {
    "__docId__": 1072,
    "kind": "testIt",
    "name": "it212",
    "testId": 212,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.it212",
    "access": null,
    "description": "reporter addChild",
    "lineNumber": 718
  },
  {
    "__docId__": 1073,
    "kind": "testIt",
    "name": "it213",
    "testId": 213,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.it213",
    "access": null,
    "description": "observer addChild",
    "lineNumber": 737
  },
  {
    "__docId__": 1074,
    "kind": "testIt",
    "name": "it214",
    "testId": 214,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.it214",
    "access": null,
    "description": "children deltas generate and process",
    "lineNumber": 779
  },
  {
    "__docId__": 1075,
    "kind": "testIt",
    "name": "it215",
    "testId": 215,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.it215",
    "access": null,
    "description": "create and delete",
    "lineNumber": 819
  },
  {
    "__docId__": 1076,
    "kind": "testIt",
    "name": "it216",
    "testId": 216,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.it216",
    "access": null,
    "description": "subscribe and unsubscribe",
    "lineNumber": 881
  },
  {
    "__docId__": 1077,
    "kind": "testDescribe",
    "name": "describe217",
    "testId": 217,
    "memberof": "test/SyncherManager.spec.js~describe207",
    "testDepth": 1,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.describe217",
    "access": null,
    "description": "should use the storageManager",
    "lineNumber": 922
  },
  {
    "__docId__": 1078,
    "kind": "testIt",
    "name": "it218",
    "testId": 218,
    "memberof": "test/SyncherManager.spec.js~describe207.describe217",
    "testDepth": 2,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.describe217.it218",
    "access": null,
    "description": "should save the url on storageManager",
    "lineNumber": 930
  },
  {
    "__docId__": 1079,
    "kind": "testIt",
    "name": "it219",
    "testId": 219,
    "memberof": "test/SyncherManager.spec.js~describe207.describe217",
    "testDepth": 2,
    "static": true,
    "longname": "test/SyncherManager.spec.js~describe207.describe217.it219",
    "access": null,
    "description": "should resume the url stored on storageManager",
    "lineNumber": 1001
  },
  {
    "__docId__": 1080,
    "kind": "testFile",
    "name": "test/utils.spec.js",
    "content": "// Unit test modules\r\nimport chai from 'chai';\r\nimport chaiAsPromised from 'chai-as-promised';\r\nimport sinonChai from 'sinon-chai';\r\n\r\n// internal modules to be tested\r\nimport {divideURL} from '../src/utils/utils';\r\n\r\nlet expect = chai.expect;\r\n\r\nchai.config.showDiff = true;\r\nchai.config.truncateThreshold = 0;\r\n\r\nchai.use(chaiAsPromised);\r\nchai.use(sinonChai);\r\n\r\ndescribe('Utils Module', function() {\r\n\r\n  it('should divide an url in 3 parts (type, domain, identity)', function() {\r\n\r\n    // http://localhost:9090/test\r\n    // hyperty://localhost:9090/test\r\n    // http://sp1.sp/test-testes\r\n    // hyperty-catalogue://sp1.sp/HelloHyperty\r\n    // runtime://sp1.sp/8456/sm\r\n    // domain://msg-node.sp1.sp/hyperty-address-allocation\r\n    // hyperty-runtime://sp1.sp\r\n\r\n    let url = 'runtime://sp.sp/8456/sm';\r\n    expect(divideURL(url)).to.deep.equal({'type' : 'runtime','domain': 'sp.sp', 'identity': '/8456/sm'});\r\n\r\n    url = 'domain://msg-node.sp1.sp/hyperty-address-allocation';\r\n    expect(divideURL(url)).to.deep.equal({'type' : 'domain','domain': 'msg-node.sp1.sp', 'identity': '/hyperty-address-allocation'});\r\n\r\n    url = 'hyperty://sp1.sp/HelloHyperty';\r\n    expect(divideURL(url)).to.deep.equal({'type' : 'hyperty','domain': 'sp1.sp', 'identity': '/HelloHyperty'});\r\n\r\n    url = 'hyperty://localhost:9090/test';\r\n    expect(divideURL(url)).to.deep.equal({'type' : 'hyperty','domain': 'localhost:9090', 'identity': '/test'});\r\n\r\n    url = 'runtime://sp1.sp';\r\n    expect(divideURL(url)).to.deep.equal({'type' : 'runtime','domain': 'sp1.sp', 'identity': ''});\r\n\r\n    url = 'http://localhost:9090/test';\r\n    expect(divideURL(url)).to.deep.equal({'type' : 'http','domain': 'localhost:9090', 'identity': '/test'});\r\n\r\n    url = 'https://localhost:9090/secure-test';\r\n    expect(divideURL(url)).to.deep.equal({'type' : 'https','domain': 'localhost:9090', 'identity': '/secure-test'});\r\n  })\r\n\r\n  \r\n\r\n})\r\n",
    "static": true,
    "longname": "test/utils.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1081,
    "kind": "testDescribe",
    "name": "describe220",
    "testId": 220,
    "memberof": "test/utils.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/utils.spec.js~describe220",
    "access": null,
    "description": "Utils Module",
    "lineNumber": 17
  },
  {
    "__docId__": 1082,
    "kind": "testIt",
    "name": "it221",
    "testId": 221,
    "memberof": "test/utils.spec.js~describe220",
    "testDepth": 1,
    "static": true,
    "longname": "test/utils.spec.js~describe220.it221",
    "access": null,
    "description": "should divide an url in 3 parts (type, domain, identity)",
    "lineNumber": 19
  }
]