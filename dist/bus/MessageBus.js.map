{"version":3,"sources":["bus/MessageBus.js"],"names":["_Bus2","require","_Pipeline","MessageBus","registry","_classCallCheck3","default","this","_this2","_possibleConstructorReturn3","_getPrototypeOf2","call","_registry","_forwards","_pipeline","_Pipeline2","error","console","log","_stringify2","inMsg","responseCallback","_this","_genId","process","msg","_responseCallback","_onResponse","itemList","_subscriptions","to","_publishOn","_onPostMessage","id","from","_this3","refCount","forwardListener","addListener","counter","fl","remove","forward","url","resolve","then","route","catch","e"],"mappings":"g3BAsBAA,MAAAC,QAAA,6CACAC,UAAAD,QAAA,2DAOME,uBAYJ,QAAAA,GAAYC,IAAU,EAAAC,iBAAAC,SAAAC,KAAAJ,EAAA,IAAAK,IAAA,EAAAC,4BAAAH,SAAAC,MAAA,EAAAG,iBAAAJ,SAAAH,GAAAQ,KAAAJ,MAAA,OAEpBC,GAAKI,UAAYR,EACjBI,EAAKK,aAELL,EAAKM,UAAY,GAAAC,YAAAT,QAAa,SAACU,GAC7BC,QAAQC,IAAI,oBAAoB,EAAAC,YAAAb,SAAeU,MAN7BR,mGAmBVY,EAAOC,GACjB,GAAIC,GAAQf,IAoBZ,OAlBAe,GAAMC,OAAOH,GAEbE,EAAMR,UAAUU,QAAQJ,EAAO,SAACK,GAI9B,GAFAH,EAAMI,kBAAkBN,EAAOC,IAE1BC,EAAMK,YAAYF,GAAM,CAC3B,GAAIG,GAAWN,EAAMO,eAAeJ,EAAIK,GACpCF,GAEFN,EAAMS,WAAWH,EAAUH,GAG3BH,EAAMU,eAAeP,MAKpBL,EAAMa,sCAQJC,GAAM,GAAAC,GAAA5B,KACXe,EAAQf,KAGR6B,EAAWd,EAAMT,UAAUqB,EAC/B,KAAKE,EAAU,CACb,GAAIC,GAAkBf,EAAMgB,YAAYJ,EAAM,SAACT,GAC7CR,QAAQC,IAAI,iBAAmBgB,EAAO,MACtCZ,EAAMU,eAAeP,IAGvBW,IACEG,QAAS,EACTC,GAAIH,EACJI,OAAQ,WACNN,EAAKI,UACgB,IAAjBJ,EAAKI,UACPJ,EAAKK,GAAGC,eACDnB,GAAMT,UAAUqB,MAK9BZ,EAAMT,UAAUqB,GAAQE,EAI1B,MADAA,GAASG,UACFH,qCAQIF,EAAMJ,GACf,GAAIR,GAAQf,IAEZ,OAAOe,GAAMgB,YAAYJ,EAAM,SAACT,GAC9BR,QAAQC,IAAI,iBAAmBgB,EAAO,OAASJ,EAAK,MACpDR,EAAMoB,QAAQZ,EAAIL,qCASdkB,EAAKlB,GACX,GAAIH,GAAQf,KAERqB,EAAWN,EAAMO,eAAec,EAChCf,IACFN,EAAMS,WAAWH,EAAUH,0CAKhBA,GACb,GAAIH,GAAQf,IAGZe,GAAMV,UAAUgC,QAAQnB,EAAIK,IAAIe,KAAK,SAACC,GACpCxB,EAAMoB,QAAQI,EAAOrB,KACpBsB,MAAM,SAASC,GAChB/B,QAAQC,IAAI,kBAAmB8B,sCAxGnB,MAAOzC,MAAKO,gDA6GhBX","file":"bus/MessageBus.js","sourcesContent":["/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\nimport Bus from './Bus';\nimport Pipeline from './Pipeline';\n\n/**\n* @author micaelpedrosa@gmail.com\n* Message BUS Interface is an extension of the Bus\n* It doesn't support the default '*' listener, instead it uses the registry.resolve(..)\n*/\nclass MessageBus extends Bus {\n  /* private\n  _registry: Registry\n  _forwards: { <from-url>: { fl: MsgListener, sandboxToUrls: Map(Sandbox, [to-url]), urlToSandbox: { to-url: Sandbox } } }\n\n  _pipeline: Pipeline\n  */\n\n  //TODO: future optimization\n  //1. message batch processing with setInterval\n  //2. resolve default gateway/protostub with register.resolve\n\n  constructor(registry) {\n    super();\n    this._registry = registry;\n    this._forwards = {};\n\n    this._pipeline = new Pipeline((error) => {\n      console.log('PIPELINE-ERROR: ', JSON.stringify(error));\n    });\n  }\n\n  get pipeline() { return this._pipeline; }\n\n  /**\n   * Post a message for routing. It will first search for a listener, if there is no one, it sends to a external routing using the _onPostMessage.\n   * External routing use the registry.resolve(..) method to decide the destination sandbox.\n   * @param  {Message} inMsg            JSON with mandatory Message structure {id, type, from, to}\n   * @param  {Callback} responseCallback Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\".\n   * @return {number}                  the Message id\n   */\n  postMessage(inMsg, responseCallback) {\n    let _this = this;\n\n    _this._genId(inMsg);\n\n    _this._pipeline.process(inMsg, (msg) => {\n\n      _this._responseCallback(inMsg, responseCallback);\n\n      if (!_this._onResponse(msg)) {\n        let itemList = _this._subscriptions[msg.to];\n        if (itemList) {\n          //do not publish on default address, because of loopback cycle\n          _this._publishOn(itemList, msg);\n        } else {\n          //if there is no listener, send to external interface\n          _this._onPostMessage(msg);\n        }\n      }\n    });\n\n    return inMsg.id;\n  }\n\n  /**\n   * Adds an external publish address listener. Every message for the address will be forwarded to the external routing by _onPostMessage.\n   * This means, even if there is a listener for the address, it will also send the message to the external routing.\n   * @param {URL} from Publish address.\n   */\n  addPublish(from) {\n    let _this = this;\n\n    //verify if forward exist\n    let refCount = _this._forwards[from];\n    if (!refCount) {\n      let forwardListener = _this.addListener(from, (msg) => {\n        console.log('MB-PUBLISH: ( ' + from + ' )');\n        _this._onPostMessage(msg);\n      });\n\n      refCount = {\n        counter: 0,\n        fl: forwardListener,\n        remove: () => {\n          this.counter--;\n          if (this.counter === 0) {\n            this.fl.remove();\n            delete _this._forwards[from];\n          }\n        }\n      };\n\n     _this._forwards[from] = refCount;\n   }\n\n   refCount.counter++;\n   return refCount;\n  }\n\n  /**\n   * Adds a forward listener for a message destination. Every message reaching an address will be also sent to the forward address.\n   * @param {URL} from Message destination, it's actually the field \"to\" of the message.\n   * @param {URL} to   Forward address.\n   */\n   addForward(from, to) {\n     let _this = this;\n\n     return _this.addListener(from, (msg) => {\n       console.log('MB-FORWARD: ( ' + from + ' to ' + to + ' )');\n       _this.forward(to, msg);\n     });\n   }\n\n   /**\n    * Just forward's a message to the forward address. Listeners should be available for the forward address.\n    * @param  {URL} url Forward address.\n    * @param  {Message} msg Message to forward\n    */\n   forward(url, msg) {\n     let _this = this;\n\n     let itemList = _this._subscriptions[url];\n     if (itemList) {\n       _this._publishOn(itemList, msg);\n     }\n   }\n\n   //default route, if there are no listeners available for a message destination.\n   _onPostMessage(msg) {\n     let _this = this;\n\n     //resolve external protostub...\n     _this._registry.resolve(msg.to).then((route) => {\n       _this.forward(route, msg);\n     }).catch(function(e) {\n       console.log('RESOLVE-ERROR: ', e);\n     });\n   }\n}\n\nexport default MessageBus;\n"],"sourceRoot":"/source/"}