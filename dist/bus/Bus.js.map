{"version":3,"sources":["bus/Bus.js"],"names":["Bus","_classCallCheck3","default","this","_this","_msgId","_subscriptions","_responseTimeOut","_responseCallbacks","_registerExternalListener","url","listener","item","MsgListener","itemList","push","msgId","responseListener","outUrl","inUrl","target","_this2","thisListn","addListener","msg","postMessage","targetListn","thisListener","targetListener","unbind","remove","_publishOn","forEach","sub","_callback","inMsg","responseCallback","responseId","from","id","setTimeout","responseFun","errorMsg","type","body","code","desc","value","to","_onResponse","_publishOnDefault","subscriptions","callback","_url","subs","index","indexOf","splice","length"],"mappings":"0XA6BMA,eAUJ,QAAAA,MAAc,EAAAC,iBAAAC,SAAAC,KAAAH,EACZ,IAAII,GAAQD,IACZC,GAAMC,OAAS,EACfD,EAAME,kBAENF,EAAMG,iBAAmB,IACzBH,EAAMI,sBAENJ,EAAMK,iGAUIC,EAAKC,GACf,GAAIP,GAAQD,KAERS,EAAO,GAAIC,aAAYT,EAAME,eA+CfI,EA/CoCC,GAClDG,EAAWV,EAAME,eAAeI,EAOpC,OA+DII,KApEFA,KAqFEV,EAAAE,eAAkBI,GACpBI,GAlFFA,EAASC,KAAKH,GACPA,8CAWWF,EAAKM,EAAOC,GAC9Bd,KAAKK,mBAAmBE,EAAMM,GAASC,iDAQlBP,EAAKM,SACnBb,MAAKK,mBAAmBE,EAAMM,gDAOlBN,SACZP,MAAKG,eAAeI,gCAUxBQ,EAAQC,EAAOC,GAAQ,GAAAC,GAAAlB,KACtBC,EAAQD,KAERmB,EAAYlB,EAAMmB,YAAYL,EAAQ,SAACM,GACzCJ,EAAOK,YAAYD,KAGjBE,EAAcN,EAAOG,YAAYJ,EAAO,SAACK,GAC3CpB,EAAMqB,YAAYD,IAGpB,QACEG,aAAcL,EACdM,eAAgBF,EAChBG,OAAQ,WACNR,EAAKM,aAAaG,SAClBT,EAAKO,eAAeE,qDAMRN,GAEhB,GAAIV,GAAWX,KAAKG,eAAe,IAC/BQ,IACFX,KAAK4B,WAAWjB,EAAUU,sCAKnBV,EAAUU,GACnBV,EAASkB,QAAQ,SAACC,GAChBA,EAAIC,UAAUV,+CAIAW,EAAOC,GACvB,GAAIhC,GAAQD,IAGRiC,KAAkB,WACpB,GAAIC,GAAaF,EAAMG,KAAOH,EAAMI,EACpCnC,GAAMI,mBAAmB6B,GAAcD,EAEvCI,WAAW,WACT,GAAIC,GAAcrC,EAAMI,mBAAmB6B,EAG3C,UAFOjC,GAAMI,mBAAmB6B,GAE5BI,EAAa,CACf,GAAIC,IACFH,GAAIJ,EAAMI,GAAII,KAAM,WACpBC,MAAQC,KAAM,IAAKC,KAAM,oBAAqBC,MAAOZ,GAGvDM,GAAYC,KAEbtC,EAAMG,yDAIDiB,GACV,GAAIpB,GAAQD,IAEZ,IAAiB,aAAbqB,EAAImB,KAAqB,CAC3B,GAAIN,GAAab,EAAIwB,GAAKxB,EAAIe,GAC1BE,EAAcrC,EAAMI,mBAAmB6B,EAO3C,IAJIb,EAAIoB,KAAKC,MAAQ,WACZzC,GAAMI,mBAAmB6B,GAG9BI,EAEF,MADAA,GAAYjB,IACL,EAIX,OAAO,qCAIEA,GACT,GAAIpB,GAAQD,IAEZ,KAAKC,EAAM6C,YAAYzB,GAAM,CAC3B,GAAIV,GAAWV,EAAME,eAAekB,EAAIwB,GACpClC,GACFV,EAAM2B,WAAWjB,EAAUU,GAE3BpB,EAAM8C,kBAAkB1B,mCAKvBW,GAKAA,EAAMI,IAAmB,IAAbJ,EAAMI,KACrBpC,KAAKE,SACL8B,EAAMI,GAAKpC,KAAKE,4CAYR8B,EAAOC,2CAOJZ,kEAYXX,uBAOJ,QAAAA,GAAYsC,EAAezC,EAAK0C,IAAU,EAAAnD,iBAAAC,SAAAC,KAAAU,EACxC,IAAIT,GAAQD,IAEZC,GAAME,eAAiB6C,EACvB/C,EAAMiD,KAAO3C,EACbN,EAAM8B,UAAYkB,oEASlB,GAAIhD,GAAQD,KAERmD,EAAOlD,EAAME,eAAeF,EAAMiD,KACtC,IAAIC,EAAM,CACR,GAAIC,GAAQD,EAAKE,QAAQpD,EACzBkD,GAAKG,OAAOF,EAAO,GAGC,IAAhBD,EAAKI,cACAtD,GAAME,eAAeF,EAAMiD,mCAf5B,MAAOlD,MAAKkD,8BAqBXrD","file":"bus/Bus.js","sourcesContent":["/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author micaelpedrosa@gmail.com\n* Minimal interface and implementation to send and receive messages. It can be reused in many type of components.\n* Components that need a message system should receive this class as a dependency or extend it.\n* Extensions should implement the following private methods: _onPostMessage and _registerExternalListener\n*/\nclass Bus {\n  /* private\n  _msgId: number;\n  _subscriptions: <url: MsgListener[]>\n\n  _responseTimeOut: number\n  _responseCallbacks: <url+id: (msg) => void>\n\n  */\n\n  constructor() {\n    let _this = this;\n    _this._msgId = 0;\n    _this._subscriptions = {};\n\n    _this._responseTimeOut = 5000; //default to 3s\n    _this._responseCallbacks = {};\n\n    _this._registerExternalListener();\n  }\n\n  /**\n  * Register listener to receive message when \"msg.to === url\".\n  * Special url \"*\" for default listener is accepted to intercept all messages.\n  * @param {URL} url Address to intercept, tha is in the message \"to\"\n  * @param {Listener} listener listener\n  * @return {MsgListener} instance of MsgListener\n  */\n  addListener(url, listener) {\n    let _this = this;\n\n    let item = new MsgListener(_this._subscriptions, url, listener);\n    let itemList = _this._subscriptions[url];\n    if (!itemList) {\n      itemList = [];\n      _this._subscriptions[url] = itemList;\n    }\n\n    itemList.push(item);\n    return item;\n  }\n\n  /**\n   * Manually add a response listener. Only one listener per message ID should exist.\n   * ATENTION, there is no timeout for this listener.\n   * The listener should be removed with a removeResponseListener, failing to do this will result in a unreleased memory problem.\n   * @param {URL} url Origin address of the message sent, \"msg.from\".\n   * @param {number} msgId Message ID that is returned from the postMessage.\n   * @param {Function} responseListener Callback function for the response\n   */\n  addResponseListener(url, msgId, responseListener) {\n    this._responseCallbacks[url + msgId] = responseListener;\n  }\n\n  /**\n   * Remove the response listener.\n   * @param {URL} url Origin address of the message sent, \"msg.from\".\n   * @param {number} msgId  Message ID that is returned from the postMessage\n   */\n  removeResponseListener(url, msgId) {\n    delete this._responseCallbacks[url + msgId];\n  }\n\n  /**\n   * Remove all existent listeners for the URL\n   * @param  {URL} url Address registered\n   */\n  removeAllListenersOf(url) {\n    delete this._subscriptions[url];\n  }\n\n  /**\n   * Helper method to bind listeners (in both directions) into other MiniBus target.\n   * @param  {URL} outUrl Outbound URL, register listener for url in direction \"this -> target\"\n   * @param  {URL} inUrl Inbound URL, register listener for url in direction \"target -> this\"\n   * @param  {MiniBus} target The other target MiniBus\n   * @return {Bound} an object that contains the properties [thisListener, targetListener] and the unbind method.\n   */\n  bind(outUrl, inUrl, target) {\n    let _this = this;\n\n    let thisListn = _this.addListener(outUrl, (msg) => {\n      target.postMessage(msg);\n    });\n\n    let targetListn = target.addListener(inUrl, (msg) => {\n      _this.postMessage(msg);\n    });\n\n    return {\n      thisListener: thisListn,\n      targetListener: targetListn,\n      unbind: () => {\n        this.thisListener.remove();\n        this.targetListener.remove();\n      }\n    };\n  }\n\n  //publish on default listeners\n  _publishOnDefault(msg) {\n    //is there any \"*\" (default) listeners?\n    let itemList = this._subscriptions['*'];\n    if (itemList) {\n      this._publishOn(itemList, msg);\n    }\n  }\n\n  //publish on a subscription list.\n  _publishOn(itemList, msg) {\n    itemList.forEach((sub) => {\n      sub._callback(msg);\n    });\n  }\n\n  _responseCallback(inMsg, responseCallback) {\n    let _this = this;\n\n    //automatic management of response handlers\n    if (responseCallback) {\n      let responseId = inMsg.from + inMsg.id;\n      _this._responseCallbacks[responseId] = responseCallback;\n\n      setTimeout(() => {\n        let responseFun = _this._responseCallbacks[responseId];\n        delete _this._responseCallbacks[responseId];\n\n        if (responseFun) {\n          let errorMsg = {\n            id: inMsg.id, type: 'response',\n            body: { code: 408, desc: 'Response timeout!', value: inMsg }\n          };\n\n          responseFun(errorMsg);\n        }\n      }, _this._responseTimeOut);\n    }\n  }\n\n  _onResponse(msg) {\n    let _this = this;\n\n    if (msg.type === 'response') {\n      let responseId = msg.to + msg.id;\n      let responseFun = _this._responseCallbacks[responseId];\n\n      //if it's a provisional response, don't delete response listener\n      if (msg.body.code >= 200) {\n        delete _this._responseCallbacks[responseId];\n      }\n\n      if (responseFun) {\n        responseFun(msg);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  //receive messages from external interface\n  _onMessage(msg) {\n    let _this = this;\n\n    if (!_this._onResponse(msg)) {\n      let itemList = _this._subscriptions[msg.to];\n      if (itemList) {\n        _this._publishOn(itemList, msg);\n      } else {\n        _this._publishOnDefault(msg);\n      }\n    }\n  }\n\n  _genId(inMsg) {\n    //TODO: how do we manage message ID's? Should it be a global runtime counter, or per URL address?\n    //Global counter will not work, because there will be multiple MiniBus instances!\n    //Per URL, can be a lot of data to maintain!\n    //Maybe a counter per MiniBus instance. This is the assumed solution for now.\n    if (!inMsg.id || inMsg.id === 0) {\n      this._msgId++;\n      inMsg.id = this._msgId;\n    }\n  }\n\n  /**\n  * Send messages to local listeners, or if not exists to external listeners.\n  * It's has an optional mechanism for automatic management of response handlers.\n  * The response handler will be unregistered after receiving the response, or after response timeout (default to 3s).\n  * @param  {Message} msg Message to send. Message ID is automatically added to the message.\n  * @param  {Function} responseCallback Optional parameter, if the developer what's automatic response management.\n  * @return {number} Returns the message ID, in case it should be needed for manual management of the response handler.\n  */\n  postMessage(inMsg, responseCallback) { }\n\n  /**\n   * Not public available, used by the class extension implementation, to process messages from the public \"postMessage\" without a registered listener.\n   * Used to send the message to an external interface, like a WebWorker, IFrame, etc.\n   * @param  {Message.Message} msg Message\n   */\n  _onPostMessage(msg) { /*implementation will send message to external system*/ }\n\n  /**\n   * Not public available, used by the class extension implementation, to process all messages that enter the MiniBus from an external interface, like a WebWorker, IFrame, etc.\n   * This method is called one time in the constructor to register external listeners.\n   * The implementation will probably call the \"_onMessage\" method to publish in the local listeners.\n   * DO NOT call \"postMessage\", there is a danger that the message enters in a cycle!\n   */\n  _registerExternalListener() { /*implementation will register external listener and call \"this._onMessage(msg)\" */ }\n\n}\n\nclass MsgListener {\n  /* private\n  _subscriptions: <string: MsgListener[]>;\n  _url: string;\n  _callback: (msg) => void;\n  */\n\n  constructor(subscriptions, url, callback) {\n    let _this = this;\n\n    _this._subscriptions = subscriptions;\n    _this._url = url;\n    _this._callback = callback;\n  }\n\n  get url() { return this._url; }\n\n  /**\n   * Remove this listener from the Bus\n   */\n  remove() {\n    let _this = this;\n\n    let subs = _this._subscriptions[_this._url];\n    if (subs) {\n      let index = subs.indexOf(_this);\n      subs.splice(index, 1);\n\n      //if there are no listeners, remove the subscription entirely.\n      if (subs.length === 0) {\n        delete _this._subscriptions[_this._url];\n      }\n    }\n  }\n}\n\nexport default Bus;\n"],"sourceRoot":"/source/"}