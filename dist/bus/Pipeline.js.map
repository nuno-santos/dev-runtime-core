{"version":3,"sources":["bus/Pipeline.js"],"names":["Pipeline","_onFail","_classCallCheck3","default","this","_this","handlers","onFail","msg","onDeliver","length","iter","Iterator","next","PipeContext","pipeline","_inStop","_pipeline","_iter","_msg","_onDeliver","hasNext","error","inMsg","array","_index","_array"],"mappings":"0XAkCEA,oBAAA,QAAAA,GAAYC,IAAS,EAAAC,iBAAAC,SAAAC,KAAAJ,EACnB,IAAIK,GAAQD,IAEZC,GAAMC,YACND,EAAME,OAASN,mEAQTO,EAAKC,GACX,GAAIJ,GAAQD,IAEZ,IAAIC,EAAMC,SAASI,OAAS,EAAG,CAC7B,GAAIC,GAAO,GAAIC,UAASP,EAAMC,SAC9BK,GAAKE,KAAK,GAAIC,aAAYT,EAAOM,EAAMH,EAAKC,QAE5CA,GAAUD,YAUVM,uBASJ,QAAAA,GAAYC,EAAUJ,EAAMH,EAAKC,IAAW,EAAAP,iBAAAC,SAAAC,KAAAU,EAC1C,IAAIT,GAAQD,IAEZC,GAAMW,SAAU,EAEhBX,EAAMY,UAAYF,EAClBV,EAAMa,MAAQP,EACdN,EAAMc,KAAOX,EACbH,EAAMe,WAAaX,kEAYnB,GAAIJ,GAAQD,IAEPC,GAAMW,UACLX,EAAMa,MAAMG,QACdhB,EAAMa,MAAML,KAAKR,GAEjBA,EAAMe,WAAWf,EAAMc,yCAS3B,GAAId,GAAQD,IACPC,GAAMW,UACTX,EAAMW,SAAU,EAChBX,EAAMe,WAAWf,EAAMc,oCAQtBG,GACH,GAAIjB,GAAQD,IAEPC,GAAMW,UACTX,EAAMW,SAAU,EACZX,EAAMY,UAAUV,QAClBF,EAAMY,UAAUV,OAAOe,qCAzCZ,MAAOlB,MAAKa,sCAEjB,MAAOb,MAAKe,mBAChBI,GAASnB,KAAKe,KAAOI,WA4CzBX,oBAMJ,QAAAA,GAAYY,IAAO,EAAAtB,iBAAAC,SAAAC,KAAAQ,GACjBR,KAAKqB,QAAS,EACdrB,KAAKsB,OAASF,mEAId,MAAOpB,MAAKqB,OAASrB,KAAKsB,OAAOhB,OAAS,+BAK1C,MADAN,MAAKqB,SACErB,KAAKsB,OAAOtB,KAAKqB,iCAIbzB","file":"bus/Pipeline.js","sourcesContent":["/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author micaelpedrosa@gmail.com\n* Sequencial processor of methods. Similar to how Sequential Promise's work, but better fit for message processing.\n* Normal use for this, is to intercept all messages with configured handlers, and act accordingly.\n*/\nclass Pipeline {\n  /* public\n    handlers: ((PipeContext) => void)[]\n    onFail: (error) => void\n  */\n\n  constructor(_onFail) {\n    let _this = this;\n\n    _this.handlers = [];\n    _this.onFail = _onFail;\n  }\n\n  /**\n   * Insert a message in the pipeline queue. All messages are wrapped with a PipeContext.\n   * @param  {Message} msg       Message for the queue\n   * @param  {Callback} onDeliver When message is finished processing from all handlers, it will be delivered in this callback.\n   */\n  process(msg, onDeliver) {\n    let _this = this;\n\n    if (_this.handlers.length > 0) {\n      let iter = new Iterator(_this.handlers);\n      iter.next(new PipeContext(_this, iter, msg, onDeliver));\n    } else {\n      onDeliver(msg);\n    }\n  }\n}\n\n/**\n* @author micaelpedrosa@gmail.com\n* Wrapper around a message that adds actions that can be fired by any interceptor handler.\n* The Pipeline is asynchronous, so an handler should always call an action, the default one is \"next()\"\n*/\nclass PipeContext {\n  /* private\n    _inStop: boolean\n\n    _pipeline: Pipeline\n    _iter: Iterator\n    _msg: Message\n  */\n\n  constructor(pipeline, iter, msg, onDeliver) {\n    let _this = this;\n\n    _this._inStop = false;\n\n    _this._pipeline = pipeline;\n    _this._iter = iter;\n    _this._msg = msg;\n    _this._onDeliver = onDeliver;\n  }\n\n  get pipeline() { return this._pipeline; }\n\n  get msg() { return this._msg; }\n  set msg(inMsg) { this._msg = inMsg; }\n\n  /**\n   * Proceed to the next interceptor handler, unless there was an error. If it's the last one, proceed to onDeliver handler.\n   */\n  next() {\n    let _this = this;\n\n    if (!_this._inStop) {\n      if (_this._iter.hasNext) {\n        _this._iter.next(_this);\n      } else {\n        _this._onDeliver(_this._msg);\n      }\n    }\n  }\n\n  /**\n   * Proceed directly to the onDeliver handler, unless there was an error.\n   */\n  deliver() {\n    let _this = this;\n    if (!_this._inStop) {\n      _this._inStop = true;\n      _this._onDeliver(_this._msg);\n    }\n  }\n\n  /**\n   * Mark the context with an error and proceed to the onFail handler.\n   * @param  {[type]} error [description]\n   */\n  fail(error) {\n    let _this = this;\n\n    if (!_this._inStop) {\n      _this._inStop = true;\n      if (_this._pipeline.onFail) {\n        _this._pipeline.onFail(error);\n      }\n    }\n  }\n}\n\nclass Iterator {\n  /* private\n    _index: number\n    _array: []\n  */\n\n  constructor(array) {\n    this._index = -1;\n    this._array = array;\n  }\n\n  get hasNext() {\n    return this._index < this._array.length - 1;\n  }\n\n  get next() {\n    this._index++;\n    return this._array[this._index];\n  }\n}\n\nexport default Pipeline;\n"],"sourceRoot":"/source/"}