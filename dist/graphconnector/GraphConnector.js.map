{"version":3,"sources":["graphconnector/GraphConnector.js"],"names":["_GraphConnectorContactData","require","_BloomFilter","_GlobalRegistryRecord","_bitcoinjsLib","_bip","_sjcl","_jsrsasign","_base64Url","_hex","_buffer","GraphConnector","hypertyRuntimeURL","messageBus","_classCallCheck3","default","this","contacts","lastCalculationBloomFilter1Hop","Date","toISOString","globalRegistryRecord","_GlobalRegistryRecord2","_prvKey","privateKey","groups","residenceLocation","firstName","lastName","_messageBus","_hypertyRuntimeURL","_buffer2","TYPED_ARRAY_SUPPORT","mnemonic","_bip2","generateMnemonic","saltWord","_createKeys","lastUpdate","timeout","setMonth","getMonth","active","revoked","rtn","mnemonicAndSalt","lastIndex","lastIndexOf","substring","length","_this","msg","type","from","to","body","guid","_promise2","resolve","reject","undefined","postMessage","reply","jwt","data","unwrappedJWT","KJUR","jws","JWS","parse","dataEncoded","payloadObj","dataDecoded","_base64Url2","decode","dataJSON","JSON","sameKey","publicKey","publicKeyObject","_jsrsasign2","KEYUTIL","getKey","encodedString","split","slice","join","sigValueHex","sigHex","sig","crypto","Signature","alg","init","updateString","isValid","verify","userIDs","salt","seed","mnemonicToSeed","hdnode","_bitcoinjsLib2","HDNode","fromSeedBuffer","ecparams","ECParameterDB","getByName","biPrv","keyPair","d","epPub","G","multiply","biX","getX","toBigInteger","biY","getY","charlen","keylen","hPrv","toString","hX","hY","hPub","ECDSA","curve","setPrivateKeyHex","isPrivate","isPublic","pubKey","getPEM","setPublicKeyHex","replace","saltHashedBitArray","_sjcl2","hash","sha256","codec","base64","fromBits","iterations","guidBitArray","misc","pbkdf2","base64url","record","getRecord","recordString","_stringify2","recordStringBase64","encode","jwtTemp","sign","signatureHex","signature","_hex2","toBase64","responseCode","queriedContact","_GraphConnectorContactData2","userID","found","i","push","splice","calculateBloomFilter1Hop","bf","_BloomFilter2","privateContact","add","contactsBloomFilter1Hop","name","rtnArray","directContactsArray","fofContactsArray","bf1hop","test"],"mappings":"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","file":"graphconnector/GraphConnector.js","sourcesContent":["/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\nimport GraphConnectorContactData from './GraphConnectorContactData';\nimport BloomFilter from './BloomFilter';\nimport GlobalRegistryRecord from './GlobalRegistryRecord';\nimport bitcoin from 'bitcoinjs-lib';\nimport bip39 from 'bip39';\nimport sjcl from 'sjcl';\nimport jsrsasign from 'jsrsasign';\nimport base64url from 'base64-url';\nimport hex64 from 'hex64';\nimport Buffer from 'buffer';\n\n/**\n* The Graph Connector contains the contact list/address book.\n* @author beierle@tu-berlin.de\n*/\nclass GraphConnector {\n\n  // TODO: import / export methods\n\n  /**\n   * Constructs a new and empty Graph Connector.\n   * @param {string}   HypertyRuntimeURL    The Hyperty Runtime URL.\n   * @param {messageBus}    MessageBus      The Message Bus.\n   */\n  constructor(hypertyRuntimeURL, messageBus) {\n    this.contacts = [];\n    this.lastCalculationBloomFilter1Hop = new Date(0).toISOString();\n\n    this.globalRegistryRecord = new GlobalRegistryRecord();\n    this._prvKey;\n    this.privateKey;\n\n    this.groups = [];\n    this.residenceLocation;\n    this.firstName;\n    this.lastName;\n\n    this._messageBus = messageBus;\n    this._hypertyRuntimeURL = hypertyRuntimeURL;\n  }\n\n  /**\n  * Returns the MessageBus.\n  * @param {MessageBus}           messageBus    The Message Bus.\n  */\n  get messageBus() {\n    return this._messageBus;\n  }\n\n  /**\n  * Sets the MessageBus.\n  * @param {MessageBus}           messageBus    The Message Bus.\n  */\n  set messageBus(messageBus) {\n    this._messageBus = messageBus;\n  }\n\n  /**\n   * Generates a GUID and returns a mnemonic from which the GUID can be re-created later.\n   * @returns  {string}    mnemonic      A string with 16 words.\n   */\n  generateGUID() {\n\n    // generate mnemonic and salt\n    Buffer.TYPED_ARRAY_SUPPORT = true;\n    let mnemonic = bip39.generateMnemonic(160);\n\n    let saltWord = bip39.generateMnemonic(8);\n    this._createKeys(mnemonic, saltWord);\n\n    // set lasUpdate date\n    this.globalRegistryRecord.lastUpdate = new Date().toISOString();\n\n    // set defualt timeout\n    let timeout = new Date();\n    timeout.setMonth(timeout.getMonth() + 120);\n    this.globalRegistryRecord.timeout = timeout.toISOString();\n\n    // set default values\n    this.globalRegistryRecord.active = 1;\n    this.globalRegistryRecord.revoked = 0;\n\n    // return mnemonic\n    let rtn = mnemonic + ' ' + saltWord;\n    return rtn;\n  }\n\n  /**\n   * Generates a public/private key pair from a given mnemonic (16 words).\n   * Expects a string containing 16 words seperated by single spaces.\n   * Retrieves data from the Global Registry.\n   * @param  {string}     mnemonicAndSalt     A string of 16 words.\n   * @returns  {Promise}  Promise          Global Registry Record.\n   */\n  useGUID(mnemonicAndSalt) {\n    // TODO: check if format is correct and if all words are from bip39 english wordlist\n    let lastIndex = mnemonicAndSalt.lastIndexOf(' ');\n    let mnemonic = mnemonicAndSalt.substring(0, lastIndex);\n    let saltWord = mnemonicAndSalt.substring(lastIndex + 1, mnemonicAndSalt.length);\n    this._createKeys(mnemonic, saltWord);\n\n    let _this = this;\n\n    // retrieve current info from Global Registry and fill this.globalRegistryRecord\n    let msg = {\n      type: 'READ',\n      from: this._hypertyRuntimeURL + '/graph-connector',\n      to: 'global://registry/',\n      body: { guid: this.globalRegistryRecord.guid }\n    };\n\n    return new Promise(function(resolve, reject) {\n\n      if (_this.messageBus === undefined) {\n        reject('MessageBus not found on GraphConnector');\n      } else {\n\n        _this.messageBus.postMessage(msg, (reply) => {\n\n          // reply should be the JSON returned from the Global Registry REST-interface\n          let jwt = reply.body.data;\n          let unwrappedJWT = KJUR.jws.JWS.parse(reply.body.data);\n          let dataEncoded = unwrappedJWT.payloadObj.data;\n          let dataDecoded = base64url.decode(dataEncoded);\n          let dataJSON = JSON.parse(dataDecoded);\n\n          // public key should match\n          let sameKey = (dataJSON.publicKey == _this.globalRegistryRecord.publicKey);\n          if (!sameKey) {\n            reject('Retrieved key does not match!');\n          } else {\n            let publicKeyObject = jsrsasign.KEYUTIL.getKey(dataJSON.publicKey);\n            let encodedString = jwt.split('.').slice(0, 2).join('.');\n            let sigValueHex = unwrappedJWT.sigHex;\n            let sig = new KJUR.crypto.Signature({alg: 'SHA256withECDSA'});\n            sig.init(publicKeyObject);\n            sig.updateString(encodedString);\n            let isValid = sig.verify(sigValueHex);\n\n            if (!isValid) {\n              reject('Retrieved Record not valid!');\n            } else {\n              if (typeof dataJSON.userIDs != 'undefined' && dataJSON.userIDs != null) {\n                _this.globalRegistryRecord.userIDs = dataJSON.userIDs;\n              }\n              _this.globalRegistryRecord.lastUpdate = dataJSON.lastUpdate;\n              _this.globalRegistryRecord.timeout = dataJSON.timeout;\n              _this.globalRegistryRecord.salt = dataJSON.salt;\n              _this.globalRegistryRecord.active = dataJSON.active;\n              _this.globalRegistryRecord.revoked = dataJSON.revoked;\n              resolve(_this.globalRegistryRecord);\n            }\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Creates the keys from mnemonic and salt. Also sets public key, guid, and salt for globalRegistryRecord.\n   * @param  {string}     mnemonic     A string with 15 words.\n   * @param  {string}     salt         A word.\n   */\n  _createKeys(mnemonic, saltWord) {\n\n    // generate key pair\n    let seed = bip39.mnemonicToSeed(mnemonic);\n    Buffer.TYPED_ARRAY_SUPPORT = false;\n    let hdnode = bitcoin.HDNode.fromSeedBuffer(seed);\n    let ecparams = KJUR.crypto.ECParameterDB.getByName('secp256k1');\n    let biPrv = hdnode.keyPair.d; // private key big integer\n    let epPub = ecparams.G.multiply(biPrv); // d*G\n    let biX = epPub.getX().toBigInteger(); // x from Q\n    let biY = epPub.getY().toBigInteger(); // y from Q\n    let charlen = ecparams.keylen / 4;\n    let hPrv = ('0000000000' + biPrv.toString(16)).slice(-charlen);\n    let hX   = ('0000000000' + biX.toString(16)).slice(-charlen);\n    let hY   = ('0000000000' + biY.toString(16)).slice(-charlen);\n    let hPub = '04' + hX + hY;\n    this._prvKey = new KJUR.crypto.ECDSA({curve: 'secp256k1'});\n    this._prvKey.setPrivateKeyHex(hPrv);\n    this._prvKey.isPrivate = true;\n    this._prvKey.isPublic = false;\n    let pubKey = new KJUR.crypto.ECDSA({curve: 'secp256k1'});\n    this.privateKey = jsrsasign.KEYUTIL.getPEM(this._prvKey, 'PKCS8PRV');\n    pubKey.setPublicKeyHex(hPub);\n    pubKey.isPrivate = false;\n    pubKey.isPublic = true;\n    let publicKey = jsrsasign.KEYUTIL.getPEM(pubKey, 'PKCS8PUB');\n    publicKey = publicKey.replace(/(\\r\\n|\\n|\\r)/gm, '');\n    this.globalRegistryRecord.publicKey = publicKey;\n\n    // generate salt\n    let saltHashedBitArray = sjcl.hash.sha256.hash(saltWord);\n    let salt = sjcl.codec.base64.fromBits(saltHashedBitArray);\n    this.globalRegistryRecord.salt = salt;\n\n    // generate GUID\n    let iterations = 10000;\n    let guidBitArray = sjcl.misc.pbkdf2(this.globalRegistryRecord.publicKey, salt, iterations);\n    let guid = sjcl.codec.base64url.fromBits(guidBitArray);\n    this.globalRegistryRecord.guid = guid;\n  }\n\n  /**\n   * SignGenerates a public/private key pair from a given mnemonic.\n   * @returns  {string}     JWT     JSON Web Token ready to commit to Global Registry.\n   */\n  signGlobalRegistryRecord() {\n\n    let record = this.globalRegistryRecord.getRecord();\n    let recordString = JSON.stringify(record);\n    let recordStringBase64 = base64url.encode(recordString);\n\n    let jwtTemp = KJUR.jws.JWS.sign(null, {alg: 'ES256'}, {data: recordStringBase64}, this._prvKey);\n    let encodedString = jwtTemp.split('.').slice(0, 2).join('.');\n\n    let sig = new KJUR.crypto.Signature({alg: 'SHA256withECDSA'});\n    sig.init(this.privateKey);\n    sig.updateString(encodedString);\n\n    let signatureHex = sig.sign();\n    let signature = hex64.toBase64(signatureHex);\n    let jwt = encodedString + '.' + signature;\n    return jwt;\n  }\n\n  /**\n   * Takes the Global Registry Record as a signed JWT and sends it to the Global Registry via the MessageBus.\n   * Returns the response code of the REST-interface of the Global Registry as a Promise.\n   * @param  {string}     jwt     The Global Registry Record as a signed JWT.\n   * @returns {Propmise}  Promise Response Code from Global Registry.\n   */\n  sendGlobalRegistryRecord(jwt) {\n\n    let payloadObj = KJUR.jws.JWS.parse(jwt).payloadObj;\n    let guid = payloadObj.guid;\n\n    let _this = this;\n\n    let msg = {\n      type: 'CREATE',\n      from: this._hypertyRuntimeURL + '/graph-connector',\n      to: 'global://registry/',\n      body: { guid: this.globalRegistryRecord.guid, jwt: jwt }\n    };\n\n    return new Promise(function(resolve, reject) {\n\n      if (_this.messageBus === undefined) {\n        reject('MessageBus not found on GraphConnector');\n      } else {\n\n        _this.messageBus.postMessage(msg, (reply) => {\n\n          let responseCode = reply.body.responseCode;\n          if (responseCode == 200) {\n            resolve(200);\n          } else {\n            reject(responseCode);\n          }\n\n        });\n      }\n    });\n  }\n\n  /**\n   * Queries the Global Registry for a given GUID.\n   * Returns a Graph Connector Contact Data as a Promise.\n   * @param  {string}   guid  The GUID to query the Global Registry for\n   * @returns   {Promise}   Promise   Graph Connector Contact Data containing UserIDs.\n   */\n   queryGlobalRegistry(guid) {\n\n     let _this = this;\n\n     let msg = {\n       type: 'READ',\n       from: this._hypertyRuntimeURL + '/graph-connector',\n       to: 'global://registry/',\n       body: { guid: guid }\n     };\n\n     return new Promise(function(resolve, reject) {\n\n       if (_this.messageBus === undefined) {\n         reject('MessageBus not found on GraphConnector');\n       } else {\n\n         _this.messageBus.postMessage(msg, (reply) => {\n\n           // reply should be the JSON returned from the Global Registry REST-interface\n           let jwt = reply.body.data;\n           let unwrappedJWT = KJUR.jws.JWS.parse(reply.body.data);\n           let dataEncoded = unwrappedJWT.payloadObj.data;\n           let dataDecoded = base64url.decode(dataEncoded);\n           let dataJSON = JSON.parse(dataDecoded);\n\n           let publicKeyObject = jsrsasign.KEYUTIL.getKey(dataJSON.publicKey);\n           let encodedString = jwt.split('.').slice(0, 2).join('.');\n           let sigValueHex = unwrappedJWT.sigHex;\n           let sig = new KJUR.crypto.Signature({alg: 'SHA256withECDSA'});\n           sig.init(publicKeyObject);\n           sig.updateString(encodedString);\n           let isValid = sig.verify(sigValueHex);\n\n           if (!isValid) {\n             reject('Retrieved Record not valid!');\n           } else {\n             let queriedContact = new GraphConnectorContactData(dataJSON.guid, '', '');\n             if (typeof dataJSON.userIDs != 'undefined' && dataJSON.userIDs != null) {\n               queriedContact.userIDs = dataJSON.userIDs;\n             }\n             resolve(queriedContact);\n           }\n         });\n       }\n     });\n\n   }\n\n  /**\n   * Adds a UserID for the user.\n   * @param  {string}     userID          The UserID for a Domain Registry to add for the user.\n   */\n  addUserID(userID) {\n    // check if already inside\n    let found = false;\n    for (let i = 0; i < this.globalRegistryRecord.userIDs.length; i++) {\n      if (this.globalRegistryRecord.userIDs == userID) {\n        found = true;\n      }\n    }\n    if (!found) {\n      this.globalRegistryRecord.userIDs.push(userID);\n    }\n  }\n\n  /**\n   * Removes a UserID for the user.\n   * @param  {string}     userID          The UserID to remove.\n   */\n  removeUserID(userID) {\n    for (let i = 0; i < this.globalRegistryRecord.userIDs.length; i++) {\n      if (this.globalRegistryRecord.userIDs == userID) {\n        this.globalRegistryRecord.userIDs.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Add a contact to the Graph Connector.\n   * @param  {string}   guid          GUID of the new contact.\n   * @param  {string}   firstName     First name of the new contact.\n   * @param  {string}   lastname      Last name of the new contact.\n   */\n  addContact(guid, firstName, lastName) {\n\n    // TODO: what if two contacts have the same GUID?\n    // TODO: reject invalid GUIDs\n\n    this.contacts.push(new GraphConnectorContactData(guid, firstName, lastName));\n  }\n\n  /**\n   * Remove a contact from the Graph Connector.\n   * @param  {string}     guid      GUID of the user to be removed.\n   */\n  removeContact(guid) {\n    // remove from contacts\n    for (let i = 0; i < this.contacts.length; i++) {\n      if (this.contacts[i].guid == guid) {\n        this.contacts.splice(i, 1);\n      }\n    }\n\n    // re-calculate BF1hop\n    this.calculateBloomFilter1Hop();\n  }\n\n  /**\n   * Calculates the Bloom filter containing all non-private contacts.\n   */\n  calculateBloomFilter1Hop() {\n    let bf = new BloomFilter(\n      431328,   // number of bits to allocate. With 30000 entries, we have a false positive rate of 0.1 %.\n      10        // number of hash functions.\n    );\n    for (let i = 0; i < this.contacts.length; i++) {\n      if (!this.contacts[i].privateContact) {\n        bf.add(this.contacts[i].guid);\n      }\n    }\n    this.contactsBloomFilter1Hop = bf;\n    this.lastCalculationBloomFilter1Hop = new Date().toISOString();\n  }\n\n  /**\n   * Gets contacts by name.\n   * @param  {string}   name    First or last name to look for in the contact list.\n   * @returns  {array}   matchingContacts       Contacts matching the given name. The format is: Contacts<GraphConnectorContactData>.\n   */\n  getContact(name) {\n    // TODO: optimize, e.g., find misspelled people\n    let rtnArray = [];\n    for (let i = 0; i < this.contacts.length; i++) {\n      if (this.contacts[i].firstName == name || this.contacts[i].lastName == name) {\n        rtnArray.push(this.contacts[i]);\n      }\n    }\n    return rtnArray;\n  }\n\n  /**\n   * Checks, if the given GUID is known and returns a list of contacs that are direct connections as well as a list of contacts that (most likely) know the given contact.\n   * @param  {string}     guid      GUID of the contact to look for.\n   * @returns  {array}    relatedContacts     List of related direct contacts and of related friends-of-friends contacts.The format is: RelatedContacts<Direct<GraphConnectorContactData>,FoF<GraphConnectorContactData>>.\n   */\n  checkGUID(guid) {\n    let directContactsArray = [];\n    let fofContactsArray = [];\n    for (let i = 0; i < this.contacts.length; i++) {\n      if (this.contacts[i].guid == guid) {\n        directContactsArray.push(this.contacts[i]);\n      }\n      let bf1hop = this.contacts[i].contactsBloomFilter1Hop;\n      if (bf1hop !== undefined) {\n        if (bf1hop.test(guid)) {\n          fofContactsArray.push(this.contacts[i]);\n        }\n      }\n    }\n    let rtnArray = [];\n    rtnArray.push(directContactsArray, fofContactsArray);\n    return rtnArray;\n  }\n\n  // TODO: exportGraphData(?){}\n  // TODO: importGraphData(?){}\n\n}\n\nexport default GraphConnector;\n"],"sourceRoot":"/source/"}