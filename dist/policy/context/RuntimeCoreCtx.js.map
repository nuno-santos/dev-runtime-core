{"version":3,"sources":["policy/context/RuntimeCoreCtx.js"],"names":["_CommonCtx2","require","_Condition","_utils","_PersistenceManager","_Rule","_UserPolicy","_SubscriptionCondition","RuntimeCoreCtx","idModule","runtimeRegistry","_classCallCheck3","default","this","_this2","_possibleConstructorReturn3","_getPrototypeOf2","call","activeUserPolicy","undefined","serviceProviderPolicies","userPolicies","message","_this","_promise2","resolve","reject","console","log","body","result","isToVerify","_isToVerify","isIncomingMessage","_isIncomingMessage","isToCypher","_isToCypherModule","decrypt","then","policies","serviceProviderPolicy","getServiceProviderPolicy","userPolicy","policyEngine","pdp","applyPolicies","pep","enforcePolicies","defaultBehavior","auth","isSubscription","type","isFromRemoteSM","from","registerSubscriber","doMutualAuthentication","error","isToSetID","_isToSetID","_getIdentity","identity","encrypt","_policies","decryptMessage","msg","to","split","subsIndex","indexOf","isDataObjectSubscription","pop","dataObjectURL","length","subscriber","encryptMessage","identities","getIdentities","emails","i","push","getUserEmailFromURL","hyperties","hypertiesList","hypertiesNames","hypertyName","objectName","isIncoming","policy","toHyperty","getHypertyName","fromHyperty","splitFrom","runtimeURL","schemasToIgnore","fromSchema","url","splitURL","getIdentityOfHyperty","source","divideURL","getURL","splitTo","toSchema","isCreate","isFromHyperty","isToHyperty","isToDataObject","isDataObjectURL","isHandshake","_PersistenceManager2","get","groups","rulesPE","rules","j","condition","attribute","_SubscriptionCondition2","operator","params","_Condition2","_Rule2","authorise","priority","scope","target","_UserPolicy2","key","actions","combiningAlgorithm","set","_dataObjectScheme","_subscription"],"mappings":"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","file":"policy/context/RuntimeCoreCtx.js","sourcesContent":["import CommonCtx from './CommonCtx';\nimport Condition from '../conditions/Condition';\nimport {divideURL, getUserEmailFromURL, isDataObjectURL} from '../../utils/utils';\nimport persistenceManager from 'service-framework/dist/PersistenceManager';\nimport Rule from '../Rule';\nimport UserPolicy from '../policies/UserPolicy';\nimport SubscriptionCondition from '../conditions/SubscriptionCondition';\n\nclass RuntimeCoreCtx extends CommonCtx {\n\n  constructor(idModule, runtimeRegistry) {\n    super();\n    this.idModule = idModule;\n    this.runtimeRegistry = runtimeRegistry;\n    this.activeUserPolicy = undefined;\n    this.serviceProviderPolicies = {};\n    this.userPolicies = {};\n  }\n\n  get dataObjectScheme() {\n    return this._dataObjectScheme;\n  }\n\n  get subscription() {\n    return this._subscription;\n  }\n\n  set dataObjectScheme(params) {\n    let from = params.message.from;\n    if (isDataObjectURL(from)) {\n      this._dataObjectScheme = divideURL(from).type;\n    } else {\n      this._dataObjectScheme = undefined;\n    }\n  }\n\n  set subscription(params) {\n    this._subscription = params.message.body.subscriber;\n  }\n\n  authorise(message) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n      console.log('--- Policy Engine ---');\n      console.log(message);\n      message.body = message.body || {};\n      let result;\n      let isToVerify = _this._isToVerify(message);\n      let isIncomingMessage = _this._isIncomingMessage(message);\n      let isToCypher = _this._isToCypherModule(message);\n      if (isToVerify) {\n        if (isIncomingMessage) {\n          if (isToCypher) {\n            _this.decrypt(message).then(message => {\n              let policies = {\n                serviceProviderPolicy: _this.getServiceProviderPolicy(message, isIncomingMessage),\n                userPolicy: _this.activeUserPolicy\n              };\n              result = _this.policyEngine.pdp.applyPolicies(message, policies);\n              _this.policyEngine.pep.enforcePolicies(message, policies, result);\n              if (result === 'Not Applicable') {\n                result = _this.defaultBehavior;\n                message.body.auth = false;\n              }\n              if (result) {\n                let isSubscription = message.type === 'subscribe';\n                let isFromRemoteSM = _this.isFromRemoteSM(message.from);\n                if (isSubscription & isFromRemoteSM) {\n                  _this.registerSubscriber(message);\n                  _this.doMutualAuthentication(message);\n                }\n                message.body.auth = (message.body.auth === undefined) ? true : message.body.auth;\n                resolve(message);\n              } else {\n                reject('Message blocked');\n              }\n            }, (error) => { reject(error); });\n\n          } else {\n            let policies = {\n              serviceProviderPolicy: _this.getServiceProviderPolicy(message, isIncomingMessage),\n              userPolicy: _this.activeUserPolicy\n            };\n            result = _this.policyEngine.pdp.applyPolicies(message, policies);\n            _this.policyEngine.pep.enforcePolicies(message, policies, result);\n            if (result === 'Not Applicable') {\n              result = _this.defaultBehavior;\n              message.body.auth = false;\n            }\n            if (result) {\n              let isSubscription = message.type === 'subscribe';\n              let isFromRemoteSM = _this.isFromRemoteSM(message.from);\n              if (isSubscription & isFromRemoteSM) {\n                _this.registerSubscriber(message);\n                _this.doMutualAuthentication(message);\n              }\n              message.body.auth = (message.body.auth === undefined) ? true : message.body.auth;\n              resolve(message);\n            } else {\n              reject('Message blocked');\n            }\n          }\n        } else {\n          let isToSetID = _this._isToSetID(message);\n          if (isToSetID) {\n            _this._getIdentity(message).then(identity => {\n              message.body.identity = identity;\n              let policies = {\n                serviceProviderPolicy: _this.getServiceProviderPolicy(message, isIncomingMessage),\n                userPolicy: _this.activeUserPolicy\n              };\n              result = _this.policyEngine.pdp.applyPolicies(message, policies);\n              _this.policyEngine.pep.enforcePolicies(message, policies, result);\n              if (result === 'Not Applicable') {\n                result = _this.defaultBehavior;\n                message.body.auth = false;\n              }\n              if (result) {\n                message.body.auth = (message.body.auth === undefined) ? true : message.body.auth;\n                if (isToCypher) {\n                  _this.encrypt(message).then(message => {\n                    resolve(message);\n                  }, (error) => { reject(error); });\n                } else {\n                  resolve(message);\n                }\n              } else {\n                reject('Message blocked');\n              }\n            }, (error) => { reject(error); });\n          } else {\n            let policies = {\n              serviceProviderPolicy: _this.getServiceProviderPolicy(message, isIncomingMessage),\n              userPolicy: _this.activeUserPolicy\n            };\n            result = _this.policyEngine.pdp.applyPolicies(message, policies);\n            _this.policyEngine.pep.enforcePolicies(message, policies, result);\n            if (result === 'Not Applicable') {\n              result = _this.defaultBehavior;\n              message.body.auth = false;\n            }\n            if (result) {\n              message.body.auth = (message.body.auth === undefined) ? true : message.body.auth;\n              resolve(message);\n            } else {\n              reject('Message blocked');\n            }\n          }\n        }\n      } else {\n        result = _this.defaultBehavior;\n        message.body.auth = false;\n        if (result) {\n          resolve(message);\n        } else {\n          reject('Message blocked');\n        }\n      }\n    });\n  }\n\n  decrypt(message) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n      _this.idModule.decryptMessage(message).then(function(msg) {\n        resolve(msg);\n      }, (error) => {\n        reject(error);\n      });\n    });\n  }\n\n  doMutualAuthentication(message) {\n    let to = message.to.split('/');\n    let subsIndex = to.indexOf('subscription');\n    let isDataObjectSubscription = subsIndex !== -1;\n    let isFromRemoteSM = this.isFromRemoteSM(message.from);\n    if (isDataObjectSubscription & isFromRemoteSM) {\n      to.pop();\n      let dataObjectURL = to[0] + '//' + to[2] + '/' + to[3];\n      if (to.length > 4) {\n        dataObjectURL = to[0] + '//' + to[2] + '/' + to[3] + '/' + to[4];\n      }\n      this.idModule.doMutualAuthentication(dataObjectURL, message.body.subscriber);\n    }\n  }\n\n  encrypt(message) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n      _this.idModule.encryptMessage(message).then((msg) => {\n        resolve(msg);\n      }, (error) => {\n        reject(error);\n      });\n    });\n  }\n\n  getMyEmails() {\n    let identities = this.idModule.getIdentities();\n    let emails = [];\n\n    for (let i in identities) {\n      emails.push(getUserEmailFromURL(identities[i].identity));\n    }\n\n    return emails;\n  }\n\n  getMyHyperties() {\n    let hyperties = this.runtimeRegistry.hypertiesList;\n    let hypertiesNames = [];\n\n    for (let i in hyperties) {\n      let hypertyName = hyperties[i].objectName;\n      if (hypertiesNames.indexOf(hypertyName) === -1) {\n        hypertiesNames.push(hypertyName);\n      }\n    }\n\n    return hypertiesNames;\n  }\n\n  getServiceProviderPolicy(message, isIncoming) {\n    let policy;\n\n    if (isIncoming) {\n      let toHyperty = this.runtimeRegistry.getHypertyName(message.to);\n      policy = this.serviceProviderPolicies[toHyperty];\n    } else {\n      let fromHyperty = this.runtimeRegistry.getHypertyName(message.from);\n      policy = this.serviceProviderPolicies[fromHyperty];\n    }\n    return policy;\n  }\n\n  isFromRemoteSM(from) {\n    let splitFrom = from.split('://');\n    return splitFrom[0] === 'runtime' && from !== this.runtimeRegistry.runtimeURL + '/sm';\n  }\n\n  _isToSetID(message) {\n    let schemasToIgnore = ['domain-idp', 'runtime', 'domain'];\n    let splitFrom = (message.from).split('://');\n    let fromSchema = splitFrom[0];\n\n    return schemasToIgnore.indexOf(fromSchema) === -1;\n  }\n\n  _isIncomingMessage(message) {\n    return (message.body.identity) ? true : false;\n  }\n\n  getURL(url) {\n    let splitURL = url.split('/');\n    return splitURL[0] + '//' + splitURL[2] + '/' + splitURL[3];\n  }\n\n  _getIdentity(message) {\n    if (message.type === 'update') {\n      return this.idModule.getIdentityOfHyperty(message.body.source);\n    }\n\n    if (message.type === 'response' && message.body.source !== undefined) {\n      return this.idModule.getIdentityOfHyperty(message.body.source);\n    }\n\n    if (divideURL(message.from).type === 'hyperty') {\n      return this.idModule.getIdentityOfHyperty(message.from);\n    } else {\n      return this.idModule.getIdentityOfHyperty(this.getURL(message.from));\n    }\n  }\n\n  _isToVerify(message) {\n    let schemasToIgnore = ['domain-idp', 'hyperty-runtime', 'runtime', 'domain'];\n    let splitFrom = (message.from).split('://');\n    let fromSchema = splitFrom[0];\n    let splitTo = (message.to).split('://');\n    let toSchema =  splitTo[0];\n    if (fromSchema === message.from || toSchema === message.to) {\n      return false;\n    }\n    return schemasToIgnore.indexOf(fromSchema) === -1 || schemasToIgnore.indexOf(toSchema) === -1;\n  }\n\n  //TODO use schemasToIgnore instead\n  _isToCypherModule(message) {\n    let isCreate = message.type === 'create';\n    let isFromHyperty = divideURL(message.from).type === 'hyperty';\n    let isToHyperty = divideURL(message.to).type === 'hyperty';\n    let isToDataObject = isDataObjectURL(message.to);\n    let isHandshake = message.type === 'handshake';\n\n    return (isCreate && isFromHyperty && isToHyperty) || (isCreate && isFromHyperty && isToDataObject) || isHandshake;\n  }\n\n  loadActivePolicy() {\n    this.activeUserPolicy = persistenceManager.get('rethink:activePolicy');\n  }\n\n  loadGroups() {\n    let groups = persistenceManager.get('rethink:groups');\n    if (groups != undefined) {\n      this.groups = groups;\n    }\n  }\n\n  loadSPPolicies() {\n    let policies = persistenceManager.get('rethink:spPolicies');\n    if (policies !== undefined) {\n      this.serviceProviderPolicies = policies;\n    }\n  }\n\n  loadUserPolicies() {\n    let policies = persistenceManager.get('rethink:userPolicies');\n\n    if (policies !== undefined) {\n      for (let i in policies) {\n        let rulesPE = [];\n        let rules = policies[i].rules;\n        for (let j in rules) {\n          let condition;\n          if (rules[j].condition.attribute === 'subscription') {\n            condition = new SubscriptionCondition(rules[j].condition.attribute, rules[j].condition.operator, rules[j].condition.params);\n          } else {\n            condition = new Condition(rules[j].condition.attribute, rules[j].condition.operator, rules[j].condition.params);\n          }\n          rulesPE.push(new Rule(rules[j].authorise, condition, rules[j].priority, rules[j].scope, rules[j].target));\n        }\n        this.userPolicies[i] = new UserPolicy(policies[i].key, rulesPE, policies[i].actions, policies[i].combiningAlgorithm);\n      }\n    }\n  }\n\n  registerSubscriber(message) {\n    let to = message.to.split('/');\n    let subsIndex = to.indexOf('subscription');\n    let isDataObjectSubscription = subsIndex !== -1;\n    let isFromRemoteSM = this.isFromRemoteSM(message.from);\n\n    if (isDataObjectSubscription & isFromRemoteSM) {\n      to.pop();\n      let dataObjectURL = to[0] + '//' + to[2] + '/' + to[3];\n      if (to.length > 4) {\n        dataObjectURL = to[0] + '//' + to[2] + '/' + to[3] + '/' + to[4];\n      }\n      this.runtimeRegistry.registerSubscriber(dataObjectURL, message.body.subscriber);\n    }\n  }\n\n  _getLastComponentOfURL(url) {\n    let split = url.split('/');\n    return split[split.length - 1];\n  }\n\n  saveActivePolicy() {\n    persistenceManager.set('rethink:activePolicy', 0, this.activeUserPolicy);\n  }\n\n  saveGroups() {\n    persistenceManager.set('rethink:groups', 0, this.groups);\n  }\n\n  savePolicies(source) {\n    switch(source) {\n      case 'USER':\n        persistenceManager.set('rethink:userPolicies', 0, this.userPolicies);\n        break;\n      case 'SERVICE_PROVIDER':\n        persistenceManager.set('rethink:spPolicies', 0, this.serviceProviderPolicies);\n        break;\n    }\n  }\n\n}\n\nexport default RuntimeCoreCtx;\n"],"sourceRoot":"/source/"}