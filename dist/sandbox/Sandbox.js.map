{"version":3,"sources":["sandbox/Sandbox.js"],"names":["_SandboxRegistry","require","_MiniBus2","SandboxType","exports","APP","NORMAL","Sandbox","_classCallCheck3","default","this","_this2","_possibleConstructorReturn3","_getPrototypeOf2","call","componentSourceCode","componentURL","configuration","_this","_promise2","resolve","reject","deployMessage","type","from","_SandboxRegistry2","ExternalDeployAddress","to","InternalDeployAddress","body","url","sourceCode","config","postMessage","reply","code","desc","removeMessage"],"mappings":"83BAsBAA,iBAAAC,QAAA,yFACAC,UAAAD,QAAA,8DAGWE,YAAAC,QAAAD,aAAeE,IAAK,MAAOC,OAAQ,UAMxCC,oBAEJ,QAAAA,MAAc,EAAAC,iBAAAC,SAAAC,KAAAH,EAAA,IAAAI,IAAA,EAAAC,4BAAAH,SAAAC,MAAA,EAAAG,iBAAAJ,SAAAF,GAAAO,KAAAJ,MAAA,OAAAC,wGAkBEI,EAAqBC,EAAcC,GAEjD,GAAIC,GAAQR,IAIZ,OAAO,IAAAS,WAAAV,QAAY,SAACW,EAASC,GAE3B,GAAIC,IACFC,KAAM,SAAUC,KAAMC,kBAAAhB,QAAgBiB,sBAAuBC,GAAIF,kBAAAhB,QAAgBmB,sBACjFC,MAAQC,IAAKd,EAAce,WAAYhB,EAAqBiB,OAAQf,GAItEC,GAAMe,YAAYX,EAAe,SAACY,GACR,MAApBA,EAAML,KAAKM,KAEbf,EAAQ,YAERC,EAAOa,EAAML,KAAKO,kDAWVpB,GACd,GAAIE,GAAQR,IAEZ,OAAO,IAAAS,WAAAV,QAAY,SAACW,EAASC,GAE3B,GAAIgB,IACFd,KAAM,SAAUC,KAAMC,kBAAAhB,QAAgBiB,sBAAuBC,GAAIF,kBAAAhB,QAAgBmB,sBACjFC,MAAQC,IAAKd,GAIfE,GAAMe,YAAYI,EAAe,SAACH,GACR,MAApBA,EAAML,KAAKM,KAEbf,EAAQ,cAERC,EAAOa,EAAML,KAAKO,oDAOb7B","file":"sandbox/Sandbox.js","sourcesContent":["/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\nimport SandboxRegistry from '../sandbox/SandboxRegistry';\nimport MiniBus from '../bus/MiniBus';\n// import MessageFactory from '../../resources/MessageFactory';\n\nexport let SandboxType = {APP: 'app', NORMAL: 'normal'};\n\n/**\n * @author micaelpedrosa@gmail.com\n * Base class to implement external sandbox component\n */\nclass Sandbox extends MiniBus {\n\n  constructor() {\n\n    super();\n\n    let _this = this;\n\n    // Add Message Factory\n    // let messageFactory = new MessageFactory();\n    // _this.messageFactory = messageFactory;\n  }\n\n  /**\n   * Deploy an instance of the component into the sandbox.\n   * @param  {string} componentSourceCode Component source code (Hyperty, ProtoStub, etc)\n   * @param  {URL} componentURL Hyperty, ProtoStub, or any other component address.\n   * @param  {Config} configuration Config parameters of the component\n   * @return {Promise<string>} return deployed if successful, or any other string with an error\n   */\n  deployComponent(componentSourceCode, componentURL, configuration) {\n\n    let _this = this;\n\n    // let messageFactory = _this.messageFactory;\n\n    return new Promise((resolve, reject) => {\n      //FLOW-OUT: deploy message for the internal SandboxRegistry -> _onDeploy\n      let deployMessage = {\n        type: 'create', from: SandboxRegistry.ExternalDeployAddress, to: SandboxRegistry.InternalDeployAddress,\n        body: { url: componentURL, sourceCode: componentSourceCode, config: configuration }\n      };\n\n      //send message into the sandbox internals and wait for reply\n      _this.postMessage(deployMessage, (reply) => {\n        if (reply.body.code === 200) {\n          //is this response complaint with the spec?\n          resolve('deployed');\n        } else {\n          reject(reply.body.desc);\n        }\n      });\n    });\n  }\n\n  /**\n   * Remove the instance of a previously deployed component.\n   * @param  {URL} componentURL Hyperty, ProtoStub, or any other component address.\n   * @return {Promise<string>} return undeployed if successful, or any other string with an error\n   */\n  removeComponent(componentURL) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n      //FLOW-OUT: un-deploy message for the internal SandboxRegistry -> _onRemove\n      let removeMessage = {\n        type: 'delete', from: SandboxRegistry.ExternalDeployAddress, to: SandboxRegistry.InternalDeployAddress,\n        body: { url: componentURL }\n      };\n\n      //send message into the sandbox internals and wait for reply\n      _this.postMessage(removeMessage, (reply) => {\n        if (reply.body.code === 200) {\n          //is this response complaint with the spec?\n          resolve('undeployed');\n        } else {\n          reject(reply.body.desc);\n        }\n      });\n    });\n  }\n}\n\nexport default Sandbox;\n"],"sourceRoot":"/source/"}