{"version":3,"sources":["identity/Crypto.js"],"names":["Crypto","_classCallCheck3","default","this","value","btoa","Uint8Array","JSON","parse","atob","pubKey","data","_this","_promise2","resolve","reject","_importRSAencryptKey","then","publicKey","crypto","subtle","encrypt","name","encrypted","catch","err","console","log","privKey","_importRSAdecryptKey","privateKey","decrypt","decrypted","decryptedData","_importRSAsignKey","sign","_utf8Encode","signature","_importRSAverifyKey","verify","isvalid","key","iv","_importAESkey","aesKey","decodedData","_utf8Decode","_importHMACkey","hmacKey","error","keyPair","generateKey","modulusLength","publicExponent","hash","exportKey","public","private","array","getRandomValues","date","Date","now","dateEncoded","finalDate","slice","length","i","seed","_digest","digestedKey","hashHMAC","keypart0","keypart1","push","keypart2","keypart3","importKey","pms","toRandom","fromRandom","finalKey","_i","_i2","arrayBuffer","digest","s","TextEncoder","encode","TextDecoder","decode"],"mappings":"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","file":"identity/Crypto.js","sourcesContent":["/**\n* Class with the cryptographic functions for the authentication protocol\n*\n*/\nclass Crypto {\n\n  constructor() {\n    let _this = this;\n\n  }\n\n  /**\n  * encode a byteArray value in base 64 encode\n  * @param   {byteArray}    value    byteArray value\n  * @return  {string}   encoded value\n  */\n  encode(value) {\n    return btoa(value);\n  }\n\n  /**\n  * decode a base64 value in a new Uint8Array\n  * @param   {string}    value    value encoded in base 64\n  * @return  {byteArray} decodedValue\n  */\n  decode(value) {\n    return new Uint8Array(JSON.parse('[' + atob(value) + ']'));\n  }\n\n  encryptRSA(pubKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importRSAencryptKey(new Uint8Array(pubKey)).then(function(publicKey) {\n\n        crypto.subtle.encrypt(\n            {\n              name: 'RSA-OAEP'\n            },\n            publicKey, //from generateKey or importKey above\n            data //ArrayBuffer of data you want to encrypt\n        )\n        .then(function(encrypted) {\n          //returns an ArrayBuffer containing the encrypted data\n          //console.log('crypto-encryptRSA', new Uint8Array(encrypted));\n          resolve(new Uint8Array(encrypted));\n\n        }).catch(function(err) {\n          console.log('crypto-encryptRSA', err);\n          reject(err);\n        });\n\n      });\n\n    });\n\n  }\n\n  decryptRSA(privKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importRSAdecryptKey(privKey).then(function(privateKey) {\n\n        crypto.subtle.decrypt(\n            {\n              name: 'RSA-OAEP'\n            },\n            privateKey, //from generateKey or importKey above\n            data //ArrayBuffer of the data\n        )\n        .then(function(decrypted) {\n\n          let decryptedData = new Uint8Array(decrypted);\n\n          //console.log('crypto-decryptRSA', decryptedData);\n          resolve(decryptedData);\n\n        }).catch(function(err) {\n          console.log('crypto-decryptRSA', err);\n          reject(err);\n        });\n      });\n\n    });\n  }\n\n  signRSA(privKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importRSAsignKey(privKey).then(function(privateKey) {\n\n        crypto.subtle.sign(\n            {\n              name: 'RSASSA-PKCS1-v1_5'\n            },\n            privateKey, //from generateKey or importKey above\n            _this._utf8Encode(data) //ArrayBuffer of data you want to sign\n        )\n        .then(function(signature) {\n          //returns an ArrayBuffer containing the signature\n          //console.log('crypto-signRSA', new Uint8Array(signature));\n          resolve(new Uint8Array(signature));\n\n        }).catch(function(err) {\n          console.log('crypto-signRSA', err);\n          reject(err);\n        });\n\n      });\n\n    });\n  }\n\n  verifyRSA(pubKey, data, signature) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importRSAverifyKey(pubKey).then(function(publicKey) {\n\n        crypto.subtle.verify(\n            {\n              name: 'RSASSA-PKCS1-v1_5'\n            },\n            publicKey, //from generateKey or importKey above\n            signature, //ArrayBuffer of the signature\n            _this._utf8Encode(data) //ArrayBuffer of the data\n        )\n        .then(function(isvalid) {\n          //returns a boolean on whether the signature is true or not\n          //console.log('crypto-verifyRSA', isvalid);\n          resolve(isvalid);\n\n        }).catch(function(err) {\n          console.log('crypto-verifyRSA', err);\n          reject(err);\n        });\n\n      });\n\n    });\n  }\n\n  encryptAES(key, data, iv) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importAESkey(key).then(function(aesKey) {\n\n        crypto.subtle.encrypt(\n            {\n              name: 'AES-CBC',\n              //Don't re-use initialization vectors!\n              //Always generate a new iv every time your encrypt!\n              iv: iv\n            },\n            aesKey, //from generateKey or importKey above\n            _this._utf8Encode(data) //ArrayBuffer of data you want to encrypt\n        )\n        .then(function(encrypted) {\n          //returns an ArrayBuffer containing the encrypted data\n          //console.log('crypto-encryptAES', new Uint8Array(encrypted));\n          resolve(new Uint8Array(encrypted));\n\n        }).catch(function(err) {\n          console.log('crypto-encryptAES', err);\n          reject(err);\n        });\n\n      });\n\n    });\n  }\n\n  decryptAES(key, data, iv) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importAESkey(key).then(function(aesKey) {\n\n        crypto.subtle.decrypt(\n            {\n              name: 'AES-CBC',\n              iv: iv\n            },\n            aesKey, //from generateKey or importKey above\n            data //ArrayBuffer of the data\n        )\n        .then(function(decrypted) {\n\n          let decodedData = _this._utf8Decode(new Uint8Array(decrypted));\n          //console.log('crypto-decryptAES', decodedData);\n          resolve(decodedData);\n\n        }).catch(function(err) {\n          console.log('crypto-decryptAES', err);\n          reject(err);\n        });\n\n      });\n\n    });\n  }\n\n  /**\n  * creates a hash using the HMAC algorithm\n  * @param  {byteArray}    key       key to be used in the hmac\n  * @param  {string}      data       information to be hashed\n  * @return  {byteArray}   signature  resulting hash\n  */\n  hashHMAC(key, data) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n\n      _this._importHMACkey(key).then(function(hmacKey) {\n\n        crypto.subtle.sign(\n        {\n          name: 'HMAC'\n        },\n        hmacKey, //from generateKey or importKey above\n        _this._utf8Encode(data) //ArrayBuffer of data you want to sign\n        )\n        .then(function(signature) {\n          //console.log('crypto-hashHMAC', signature);\n\n          //returns an ArrayBuffer containing the signature\n          resolve(new Uint8Array(signature));\n\n        }).catch(function(err) {\n          console.log('crypto-hashHMAC', err);\n          reject(err);\n        });\n      });\n    });\n  }\n\n  /**\n  * verifies an hash using the HMAC algorithm\n  * @param  {byteArray}    key       key to be used in the hmac\n  * @param  {string}      data       information to be hashed to compare\n  * @param  {byteArray}  signature   hash to compare with the received data\n  * @return  {boolean}   isvalid     boolean saying if the data corresponds to the hash received\n  */\n  verifyHMAC(key, data, signature) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n\n      _this._importHMACkey(key).then(function(hmacKey) {\n\n        crypto.subtle.verify(\n          {\n            name: 'HMAC'\n          },\n          hmacKey, //from generateKey or importKey above\n          signature, //ArrayBuffer of the signature\n          _this._utf8Encode(data) //ArrayBuffer of the data\n        )\n        .then(function(isvalid) {\n          //returns a boolean on whether the signature is true or not\n          //console.log('crypto-verifyHMAC', isvalid);\n          (isvalid) ? resolve(isvalid) : reject(isvalid);\n\n        }).catch(function(err) {\n          console.error('crypto-verifyHMAC', err);\n          reject(err);\n        });\n\n      });\n    });\n  }\n\n  /**\n  * generates a RSA public/private key pair with a modulus length of 2048 bits\n  * @return  {JSON}   keyPair    json containing the public and private keys\n  */\n  generateRSAKeyPair() {\n    let _this = this;\n    let keyPair = {};\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.generateKey(\n      {\n        name: 'RSA-PSS',\n        modulusLength: 2048, //can be 1024, 2048, or 4096\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n      },\n      true, //whether the key is extractable (i.e. can be used in exportKey)\n      ['sign', 'verify'] //can be any combination of 'sign' and 'verify'\n\n      ).then(function(key) {\n        //returns a keypair object\n        //console.log(key);\n\n        crypto.subtle.exportKey(\n          'spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          key.publicKey //can be a publicKey or privateKey, as long as extractable was true\n        ).then(function(publicKey) {\n          //returns the exported key data\n          keyPair.public  = new Uint8Array(publicKey);\n          return crypto.subtle.exportKey(\n            'pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n            key.privateKey //can be a publicKey or privateKey, as long as extractable was true\n          );\n        }).then(function(privateKey) {\n          keyPair.private  = new Uint8Array(privateKey);\n          //console.log('crypto-generateRSAKeyPair', keyPair);\n\n          resolve(keyPair);\n\n        }).catch(function(err) {\n          console.error(err);\n          reject(err);\n        });\n\n      }).catch(function(err) {\n        console.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n  * Generates a 128 bit random value.\n  * @return {byteArray}  array    random value\n  */\n  generateIV() {\n    let _this = this;\n\n    let array = new  Uint8Array(16);\n    crypto.getRandomValues(array);\n\n    return array;\n  }\n\n  /**\n  * Generates a 256 bit random value. 32 bits are extrated from the machine time,\n  * the remaining are generated randomly\n  * @return {byteArray}  array    random value\n  */\n  generateRandom() {\n    let _this = this;\n\n    let array = new  Uint8Array(32);\n    crypto.getRandomValues(array);\n\n    let date = Date.now();\n    let dateEncoded = _this._utf8Encode(date);\n\n    //extract the least significant 4 bytes in the date\n    let finalDate = dateEncoded.slice(dateEncoded.length - 4, dateEncoded.length);\n\n    // add in the first 4 bytes of the array the bytes extracted previously;\n    for (let i = 0; i < 4; i++) { array[i] = finalDate[i]; }\n    return array;\n  }\n\n  /**\n  * generates a premaster secret (PMS) of 48 bytes (384 bits) randomly\n  * @return {byteArray}  array    premaster secret key\n  */\n  generatePMS() {\n    let _this = this;\n\n    let array = new Uint8Array(48);\n    crypto.getRandomValues(array);\n    return array;\n  }\n\n  /**\n  * generates a masterKey secret (PMS) of 48 bytes (384 bits) using the premaster secret and\n  * two randoms\n  * @return {byteArray}  array    master secret key with 48 bytes\n  */\n  generateMasterSecret(hmacKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      let key = new Uint8Array(48);\n      let seed = data;\n\n      _this._digest(hmacKey).then((digestedKey) => {\n\n        _this.hashHMAC(digestedKey, seed).then(function(keypart0) {\n\n          //copy the first 32 bytes into the key\n          for (let i = 0; i < 32; i++) { key[i] = keypart0[i]; }\n          return _this.hashHMAC(digestedKey, seed + keypart0);\n\n        }).then(function(keypart1) {\n\n          //copy the first 16 bytes to the key remaining 16 bytes\n          for (let i = 0; i < 16; i++) { key[i + 32] = keypart1[i]; }\n          //console.log('crypto-generateMasterSecret', key);\n          resolve(key);\n\n        }).catch(function(err) {\n          console.log('crypto-generateMasterSecret', err);\n          reject(err);\n        });\n      });\n\n    });\n  }\n\n  /**\n  * generates both users MAC and encryption keys. generate as output an array\n  * with 4 byteArray each with 32 bytes\n  * @param  {byteArray}        secret       secret to be used in the HMAC function\n  * @param  {String}           data         information to be used as seed\n  * @return {Array<byteArray>} key          array with the information to generate keys\n  */\n  generateKeys(hmacKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      let key = [];\n      let seed = data;\n\n      // iterate 4 times to obtain a 1024 key size\n      _this.hashHMAC(hmacKey, seed).then(function(keypart0) {\n        key.push(keypart0);\n        return _this.hashHMAC(hmacKey, seed + keypart0);\n\n      }).then(function(keypart1) {\n        key.push(keypart1);\n        return _this.hashHMAC(hmacKey, seed + keypart1);\n\n      }).then(function(keypart2) {\n        key.push(keypart2);\n        return _this.hashHMAC(hmacKey, seed + keypart2);\n\n      }).then(function(keypart3) {\n        key.push(keypart3);\n\n        //console.log('crypto-generateKeys', key);\n        resolve(key);\n\n      }).catch(function(err) {\n        //console.log('crypto-generateKeys', err);\n        reject(err);\n      });\n\n      //console.log(hmacKey, data);\n    });\n  }\n\n  _importRSAsignKey(privKey) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          privKey,\n          {   //these are the algorithm options\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['sign'] //'verify' for public key import, 'sign' for private key imports\n      )\n      .then(function(privateKey) {\n        //returns a publicKey (or privateKey if you are importing a private key)\n        //console.log('crypto-_importRSAsignKey', privateKey);\n        resolve(privateKey);\n\n      }).catch(function(err) {\n        console.error('crypto-_importRSAsignKey', err);\n        reject(err);\n      });\n    });\n  }\n\n  _importRSAverifyKey(pubKey) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          pubKey,\n          {   //these are the algorithm options\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['verify'] //'verify' for public key import, 'sign' for private key imports\n      )\n      .then(function(publicKey) {\n        //returns a publicKey (or privateKey if you are importing a private key)\n        //console.log('crypto-_importRSAverifyKey', publicKey);\n        resolve(publicKey);\n\n      }).catch(function(err) {\n        console.error('crypto-_importRSAverifyKey', err);\n        reject(err);\n      });\n    });\n  }\n\n  _importRSAencryptKey(pubKey) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          pubKey,\n          {   //these are the algorithm options\n            name: 'RSA-OAEP',\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['encrypt'] //'encrypt' or 'wrapKey' for public key import or\n                      //'decrypt' or 'unwrapKey' for private key imports\n      )\n      .then(function(publicKey) {\n        //returns a publicKey (or privateKey if you are importing a private key)\n        //console.log('crypto-_importRSAencryptKey', publicKey);\n        resolve(publicKey);\n\n      }).catch(function(err) {\n        console.error('crypto-_importRSAencryptKey', err);\n        reject(err);\n      });\n    });\n  }\n\n  _importRSAdecryptKey(privKey) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          privKey,\n          {   //these are the algorithm options\n            name: 'RSA-OAEP',\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['decrypt'] //'encrypt' or 'wrapKey' for public key import or\n                      //'decrypt' or 'unwrapKey' for private key imports\n      )\n      .then(function(privateKey) {\n        //returns a publicKey (or privateKey if you are importing a private key)\n        //console.log('crypto-_importRSAdecryptKey', privateKey);\n        resolve(privateKey);\n\n      }).catch(function(err) {\n        console.error('crypto-_importRSAdecryptKey', err);\n        reject(err);\n      });\n    });\n  }\n\n  concatPMSwithRandoms(pms, toRandom, fromRandom) {\n    let _this = this;\n\n    let finalKey = new Uint8Array(pms.length + toRandom.length + fromRandom.length);\n\n    // add PremasterKey\n    for (let i = 0; i < pms.length; i++) {\n      finalKey[i] = pms[i];\n    }\n\n    //add to random\n    for (let i = 0; i < toRandom.length; i++) {\n      finalKey[i + pms.length] = pms[i];\n    }\n\n    //add from random\n    for (let i = 0; i < fromRandom.length; i++) {\n      finalKey[i + pms.length + toRandom.length] = pms[i];\n    }\n\n    return finalKey;\n  }\n\n  _generate256bitKey() {\n    let array = new  Uint8Array(32);\n    crypto.getRandomValues(array);\n\n    return array;\n  }\n\n  /**\n  * imports the secret to the HMAC function\n  * @param  {byteArray}   arrayBuffer     bytes to import as key\n  * @return {JSON}       key              key ready to be used in the HMAC cryptographic function\n  */\n  _importHMACkey(arrayBuffer) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      _this._digest(arrayBuffer).then((key) => {\n\n        crypto.subtle.importKey(\n        'raw', //can be 'jwk' or 'raw'\n        key,\n        {   //this is the algorithm options\n          name: 'HMAC',\n          hash: {name: 'SHA-256'}, //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          length: 256 //optional, if you want your key length to differ from the hash function's block length\n        },\n        true, //whether the key is extractable (i.e. can be used in exportKey)\n        ['sign', 'verify'] //can be any combination of 'sign' and 'verify'\n        ).then(function(key) {\n          //returns the symmetric key\n          //console.log('crypto-_importHMACkey', key);\n          resolve(key);\n        })\n        .catch(function(err) {\n          reject(err);\n        });\n      });\n    });\n  }\n\n  _digest(value) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.digest(\n          {\n            name: 'SHA-256'\n          },\n          value //The data you want to hash as an ArrayBuffer\n      )\n      .then(function(hash) {\n        //returns the hash as an ArrayBuffer\n        //console.log('crypto-digest', new Uint8Array(hash));\n        resolve(new Uint8Array(hash));\n      })\n      .catch(function(err) {\n        console.error(err);\n        reject(err);\n      });\n\n    });\n  }\n\n  _importAESkey(arrayBuffer) {\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'raw', //can be 'jwk' or 'raw'\n          arrayBuffer,\n          {   //this is the algorithm options\n            name: 'AES-CBC'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['encrypt', 'decrypt'] //can be 'encrypt', 'decrypt', 'wrapKey', or 'unwrapKey'\n      )\n      .then(function(key) {\n        //returns the symmetric key\n        //console.log('crypto-importAESkey', key);\n        resolve(key);\n      })\n      .catch(function(err) {\n        console.error('crypto-importAESkey', err);\n        reject(err);\n      });\n    });\n  }\n\n  _utf8Encode(s) {\n    return new TextEncoder('utf-8').encode(s);\n  }\n\n  _utf8Decode(s) {\n    return new TextDecoder('utf-8').decode(s);\n  }\n}\n\nexport default Crypto;\n"],"sourceRoot":"/source/"}