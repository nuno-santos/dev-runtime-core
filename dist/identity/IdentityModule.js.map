{"version":3,"sources":["identity/IdentityModule.js"],"names":["_utils","require","_Identity","_Crypto","_GuiFake","IdentityModule","runtimeURL","_classCallCheck3","default","this","_this","Error","_runtimeURL","_idmURL","_guiURL","_domain","divideURL","domain","identities","newIdentity","_Identity2","identity","crypto","_Crypto2","dataObjectsIdentity","chatKeys","dataObjectSessionKeys","isToUseEncryption","_promise2","resolve","reject","message","type","to","from","body","value","id","_messageBus","postMessage","addResponseListener","msg","removeResponseListener","code","selectedIdentity","console","log","userURL","index","hypertyURL","splitURL","split","_getHypertyFromDataObject","then","returnedHypertyURL","registry","getHypertyOwner","messageInfo","emailFormat","users","converter","getUserEmailFromURL","push","currentIdentity","splice","idpDomain","identifier","scope","undefined","getIdentityAssertion","err","origin","usernameHint","window","publicKey","userkeyPair","generateRSAKeyPair","keyPair","btoa","public","generateAssertion","url","catch","error","randomNumber","Math","floor","random","identityBundle","assertion","idp","userProfile","avatar","cn","username","contents","_resolveDomain","resource","method","params","res","result","loginUrl","win","open","cordova","addEventListener","e","exec","close","pollTimer","setInterval","closed","clearInterval","document","URL","indexOf","location","assertionParsed","JSON","parse","atob","idToken","tokenIDJSON","getUserURLFromEmail","email","addIdentity","infoToken","userProfileBundle","name","picture","locale","isHandShakeType","splitedToURL","dataObjectURL","length","isToDataObject","isDataObjectURL","isFromHyperty","isToHyperty","_registry","_newChatCrypto","handshakePhase","authenticated","iv","generateIV","encryptAES","keys","hypertyFromSessionKey","encryptedValue","filteredMessage","_filterMessageToHash","hypertyFrom","hashHMAC","hypertyFromHashKey","hash","encode","_stringify2","_doHandShakePhase","dataObjectKey","isHypertyReporter","getReporterURLSynchonous","sessionKey","generateRandom","isToEncrypt","newValue","decode","data","decryptAES","hypertyToSessionKey","decryptedData","verifyHMAC","hypertyToHashKey","assertedIdentity","parsedValue","decryptedValue","sender","receiver","reporterURL","callback","ignore","resolved","startSessionKeyExchange","_sendReporterSessionKey","handshakeType","fromRandom","startHandShakeMsg","handshakeHistory","senderHello","initialMessage","toRandom","senderHelloMsg","receiverHello","validateAssertion","receiverPublicKey","nonce","premasterSecret","generatePMS","hypertyTo","userID","premasterKey","concatKey","concatPMSwithRandoms","generateMasterSecret","masterKey","generateKeys","Uint8Array","messageStructure","encryptedData","symetricEncryption","encryptRSA","assymetricEncryption","messageToHash","signRSA","privateKey","signature","receiverHelloMsg","senderCertificate","receivedValue","encryptedPMS","senderPublicKey","decryptRSA","pms","receivedmsgToHash","verifyRSA","signValidationResult","hashReceived","verifiedHash","receiverFinishedMessage","valueIVandHash","receiverAcknowledgeMsg","hashResult","hashedMessage","finalValue","receivedvalueIVandHash","receivedHash","receivedEncryptedValue","sessionKeyBundle","reporterSessionKeyMsg","valueToEncrypt","valueWithHash","splitedURL","finalURL","storedReporterURL","subscriberHyperty","getDataObjectSubscriberHyperty","discoverDataObjectPerURL","dataObject","reporter","userInfo","getIdentity","newChatCrypto","hyperty","private","messageBus","guiFake","_GuiFake2"],"mappings":"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","file":"identity/IdentityModule.js","sourcesContent":["\nimport {divideURL, getUserURLFromEmail, getUserEmailFromURL, isDataObjectURL} from '../utils/utils.js';\nimport Identity from './Identity';\nimport Crypto from './Crypto';\nimport GuiFake from './GuiFake';\n\n/**\n*\n* The Identity Module (Id Module) is the component responsible for handling the\n* user identity and the association of this identity with the Hyperty instances,\n* in order to make Hyperty instances identifiable. The identity in the reTHINK project\n* is not fixed to a unique Identity Service Provider, but obtained through several\n* different Identity sources. With this approach, the Id Module provides to the user the\n* option to choose the preferred method for authentication.\n* This module will thus able to support multiple Identity acquisition methods,\n* such as OpenID connect 1.0, Kerberos System, or authentication through smart cards.\n* For example, a user with a Google account can use the Google as an Identity Provider to provide Identity Tokens,\n*  which can be used by the Identity Module to associate it with a Hyperty instance.\n*\n* The Identity Module uses a node package, the HelloJS, which is a client-side JavaScript API for authentication\n* that facilitates the requests for the OpenID connect protocol. This method allows for some abstraction\n* when making requests for different Identity Providers, such as OpenID connect used by Google, Facebook, Microsoft, for example.\n*\n* When a request for a user identity is made using the method loginWithRP(identifier, scope),\n* this method will analyse the Identity Provider chosen to obtain an identity and will use the HelloJS node package\n* with the selected Identity Provider and identity scope. After the HelloJS request for an Access Token\n* to the Identity Providers, the user will be prompted to authenticate towards the Identity Provider.\n* Upon receiving the Access Token, this token is validated with a RESTful web service request to an endpoint\n* on the Identity Provider Authorization Server, and after the validation is done,\n* an ID token is obtained with the information according to the scope required.\n* This ID token is then preserved in this module that can obtained through the getIdentities()\n* and is passed as return value of the loginWithRP function. The methods generateAssertion and validateAssertion have not yet been developed.\n*\n*/\nclass IdentityModule {\n\n  /**\n  * This is the constructor to initialise the Identity Module it does not require any input.\n  */\n  constructor(runtimeURL) {\n    let _this = this;\n\n    if (!runtimeURL) throw new Error('runtimeURL is missing.');\n\n    _this._runtimeURL = runtimeURL;\n    _this._idmURL = _this._runtimeURL + '/idm';\n    _this._guiURL = _this._runtimeURL + '/identity-gui';\n\n    _this._domain = divideURL(_this._runtimeURL).domain;\n\n    //to store items with this format: {identity: identityURL, token: tokenID}\n    _this.identities = [];\n    let newIdentity = new Identity('guid','HUMAN');\n    _this.identity = newIdentity;\n    _this.crypto = new Crypto();\n\n    //stores the association of the dataObject and the Hyperty registered within\n    _this.dataObjectsIdentity = {};\n\n    // hashTable to store all the crypto information between two hyperties\n    _this.chatKeys = {};\n\n    // hashTable to store the symmetric keys to be used in the chat group\n    _this.dataObjectSessionKeys = {};\n\n    //failsafe to enable/disable all the criptographic functions\n    _this.isToUseEncryption = true;\n\n    // verification of nodeJS, and in case it is nodeJS then disable encryption\n    // TODO improve later, this exists because the crypto lib uses browser cryptographic methods\n    //_this.isToUseEncryption = (window) ? true : false;\n\n  }\n\n  identityRequestToGUI(identities) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n\n      let message = {type:'create', to: _this._guiURL, from: _this._idmURL, body: {value: identities}};\n\n      let id = _this._messageBus.postMessage(message);\n\n      //add listener without timout\n      _this._messageBus.addResponseListener(_this._idmURL, id, msg => {\n        _this._messageBus.removeResponseListener(_this._idmURL, id);\n\n        if (msg.body.code === 200) {\n          let selectedIdentity = msg.body.value;\n\n          console.log('selectedIdentity: ', selectedIdentity.identity);\n          resolve(selectedIdentity);\n        } else {\n          reject('error on requesting an identity to the GUI');\n        }\n      });\n    });\n  }\n\n  /**\n  * return the messageBus in this Registry\n  * @param {MessageBus}           messageBus\n  */\n  get messageBus() {\n    let _this = this;\n    return _this._messageBus;\n  }\n\n  /**\n  * Set the messageBus in this Registry\n  * @param {MessageBus}           messageBus\n  */\n  set messageBus(messageBus) {\n    let _this = this;\n    _this._messageBus = messageBus;\n\n    //TODO remove later with the proper GUI message listener\n    let guiFake = new GuiFake(_this._guiURL, _this._messageBus);\n    _this.guiFake = guiFake;\n  }\n\n  /**\n  * return the registry in this idModule\n  * @param {registry}           registry\n  */\n  get registry() {\n    let _this = this;\n    return _this._registry;\n  }\n\n  /**\n  * Set the registry in this idModule\n  * @param {registry}     reg\n  */\n  set registry(registry) {\n    let _this = this;\n    _this._registry = registry;\n  }\n\n  /**\n  * Function to return all the identities registered within a session by a user.\n  * These identities are returned in an array containing a JSON package for each user identity.\n  * @return {Array<Identities>}         Identities\n  */\n  getIdentities() {\n    let _this = this;\n    return _this.identities;\n  }\n\n  /**\n  * gets all the information from a given userURL\n  * @param  {String}  userURL     user url\n  * @return {JSON}    identity    identity bundle from the userURL\n  */\n  getIdentity(userURL) {\n    let _this = this;\n\n    for (let index in _this.identities) {\n\n      let identity = _this.identities[index];\n      if (identity.identity === userURL) {\n        return identity;\n      }\n    }\n\n    throw 'identity not found';\n  }\n\n  getIdentityOfHyperty(hypertyURL) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      let splitURL = hypertyURL.split('://');\n      if (splitURL[0] !== 'hyperty') {\n        _this._getHypertyFromDataObject(hypertyURL).then((returnedHypertyURL) => {\n          let userURL = _this.registry.getHypertyOwner(returnedHypertyURL);\n          if (userURL) {\n\n            for (let index in _this.identities) {\n              let identity = _this.identities[index];\n              if (identity.identity === userURL) {\n                return resolve(identity.messageInfo);\n              }\n            }\n          } else {\n            return reject('no identity was found ');\n          }\n        });\n      } else {\n        let userURL = _this.registry.getHypertyOwner(hypertyURL);\n        if (userURL) {\n\n          for (let index in _this.identities) {\n            let identity = _this.identities[index];\n            if (identity.identity === userURL) {\n              return resolve(identity.messageInfo);\n            }\n          }\n        } else {\n          return reject('no identity was found.');\n        }\n      }\n    });\n  }\n\n  /**\n  * Function to return all the users URLs registered within a session\n  * These users URLs are returned in an array of strings.\n  * @param  {Boolean}  emailFormat (Optional)   boolean to indicate to return in email format\n  * @return {Array<String>}         users\n  */\n  getUsersIDs(emailFormat) {\n    let _this = this;\n    let users = [];\n\n    //if request comes with the emailFormat option, then convert url to email format\n    let converter = (emailFormat) ? getUserEmailFromURL : (value) => {return value;};\n\n    for (let index in _this.identities) {\n      let identity = _this.identities[index];\n      users.push(converter(identity.identity));\n    }\n    return users;\n  }\n\n  /**\n  * Function to return the selected Identity within a session\n  * @return {Identity}        identity         identity\n  */\n  getCurrentIdentity() {\n    let _this = this;\n    return _this.currentIdentity;\n  }\n\n  /**\n  * Function to set the current Identity with a given Identity\n  * @param {Identity}        identity         identity\n  */\n  setCurrentIdentity(identity) {\n    let _this = this;\n    _this.currentIdentity = identity;\n  }\n\n  /**\n  * Function to remove the an identity from the Identities array\n  * @param {String}    userURL      userURL\n  */\n  deleteIdentity(userURL) {\n    let _this = this;\n\n    for (let identity in _this.identities) {\n      if (_this.identities[identity].identity === userURL) {\n        _this.identities.splice(identity, 1);\n      }\n    }\n  }\n\n  /**\n  * Function that resolve and create the domainURL in case it is provided one. If not, resolve the default domainURL\n  * @param {String}     idpDomain     idpDomain (Optional)\n  */\n  _resolveDomain(idpDomain) {\n    if (!idpDomain) {\n      return 'domain-idp://google.com';\n    } else {\n      return 'domain-idp://' + idpDomain;\n    }\n  }\n\n  /**\n  * Function to login a user within the session, it will start the process to obtain an Identity from a user, including the request for an identity Assertion. The function returns a promise with the token received by the idpProxy.\n  *\n  * @param  {Identifier}      identifier      identifier\n  * @param  {Scope}           scope           scope\n  * @return {Promise}         Promise         IDToken containing the user information\n  */\n  loginWithRP(identifier, scope) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      //TODO remove this verification and refactor this part\n      _this.currentIdentity = undefined;\n      _this.getIdentityAssertion('identifier', 'origin', 'hint', identifier).then(function(value) {\n        console.log('loginWithRP');\n        resolve(value);\n      }, function(err) {\n        console.log('loginWithRP err');\n        reject(err);\n      });\n    });\n  }\n\n  /**\n  * Function that fetch an identityAssertion from a user.\n  *\n  * @return {IdAssertion}              IdAssertion\n  */\n  getIdentityAssertion(identifier, origin, usernameHint, idpDomain) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n\n      if (_this.currentIdentity !== undefined) {\n        //TODO verify whether the token is still valid or not.\n        // should be needed to make further requests, to obtain a valid token\n        return resolve(_this.currentIdentity);\n      } else {\n\n        //CHECK whether is browser environment or nodejs\n        //if it is browser, then create a fake identity\n\n        try {\n          if (window) {\n\n            let publicKey;\n            let userkeyPair;\n\n            //generates the RSA key pair\n            _this.crypto.generateRSAKeyPair().then(function(keyPair) {\n\n              publicKey = btoa(keyPair.public);\n              userkeyPair = keyPair;\n              return _this.generateAssertion(publicKey, origin, '', userkeyPair, idpDomain);\n\n            }).then(function(url) {\n              return _this.generateAssertion(publicKey, origin, url, userkeyPair, idpDomain);\n\n            }).then(function(value) {\n              if (value) {\n                resolve(value);\n              } else {\n                reject('Error on obtaining Identity');\n              }\n            }).catch(function(err) {\n              console.log(err);\n              reject(err);\n            });\n          }\n        } catch (error) {\n          console.log('getIdentityAssertion for nodejs');\n          let randomNumber = Math.floor((Math.random() * 10000) + 1);\n          let identityBundle = {\n            assertion: 'assertion',\n            idp:'nodejs',\n            userProfile: {\n              avatar: 'https://lh3.googleusercontent.com/-WaCrjVMMV-Q/AAAAAAAAAAI/AAAAAAAAAAs/8OlVqCpSB9c/photo.jpg',\n              cn: 'test nodejs',\n              username: 'nodejs-' + randomNumber + '@nodejs.com',\n              userURL: 'user://nodejs.com/nodejs-' + randomNumber\n            }};\n          _this.currentIdentity = identityBundle;\n          _this.identities.push(identityBundle);\n          return resolve(identityBundle);\n        }\n      }\n    });\n  }\n\n  /**\n  * Requests the IdpProxy from a given Domain for an identityAssertion\n  *\n  * @param  {DOMString} contents     contents\n  * @param  {DOMString} origin       origin\n  * @param  {DOMString} usernameHint usernameHint\n  * @param  {JSON}      keyPair       user keyPair\n  * @return {IdAssertion}              IdAssertion\n  */\n  generateAssertion(contents, origin, usernameHint, keyPair, idpDomain) {\n    let _this = this;\n    let domain = _this._resolveDomain(idpDomain);\n    let message;\n\n    console.log('generateAssertion');\n\n    return new Promise(function(resolve,reject) {\n\n      message = {type:'execute', to: domain, from: _this._idmURL, body: {resource: 'identity', method: 'generateAssertion', params: {contents: contents, origin: origin, usernameHint: usernameHint}}};\n\n      _this._messageBus.postMessage(message, (res) => {\n        let result = res.body.value;\n\n        if (result.loginUrl) {\n\n          let win = window.open(result.loginUrl, 'openIDrequest', 'width=800, height=600');\n          if (window.cordova) {\n            win.addEventListener('loadstart', function(e) {\n              let url = e.url;\n              let code = /\\&code=(.+)$/.exec(url);\n              let error = /\\&error=(.+)$/.exec(url);\n\n              if (code || error) {\n                win.close();\n                resolve(url);\n              }\n            });\n          } else {\n            let pollTimer = setInterval(function() {\n              try {\n                if (win.closed) {\n                  reject('Some error occured when trying to get identity.');\n                  clearInterval(pollTimer);\n                }\n\n                if (win.document.URL.indexOf('id_token') !== -1 || win.document.URL.indexOf(location.origin) !== -1) {\n                  window.clearInterval(pollTimer);\n                  let url =   win.document.URL;\n\n                  win.close();\n                  resolve(url);\n                }\n              } catch (e) {\n                //console.log(e);\n              }\n            }, 500);\n          }\n        } else if (result) {\n\n          let assertionParsed = JSON.parse(atob(result.assertion));\n          let idToken;\n\n          //TODO remove the verification and remove the tokenIDJSON from the google idpProxy;\n          if (assertionParsed.tokenIDJSON) {\n            idToken = assertionParsed.tokenIDJSON;\n          } else {\n            idToken = assertionParsed;\n          }\n\n          if (idToken) {\n            result.identity = getUserURLFromEmail(idToken.email);\n\n            _this.identity.addIdentity(result);\n\n            // check if exists any infoToken in the result received\n            let infoToken = (result.infoToken) ? result.infoToken : {};\n            let userProfileBundle = {username: idToken.email, cn: idToken.name, avatar: infoToken.picture, locale: infoToken.locale, userURL: getUserURLFromEmail(idToken.email)};\n\n            //creation of a new JSON with the identity to send via messages\n            let newIdentity = {userProfile: userProfileBundle, idp: result.idp.domain, assertion: result.assertion};\n            result.messageInfo = newIdentity;\n            result.keyPair = keyPair;\n\n            _this.currentIdentity = newIdentity;\n            _this.identities.push(result);\n            resolve(newIdentity);\n\n          }\n        } else {\n          reject('error on obtaining identity information');\n        }\n\n      });\n    });\n  }\n\n  /**\n  * OTHER USER'S IDENTITY\n  */\n\n  /**\n  * Requests the IdpProxy from a given Domain to validate an IdentityAssertion\n  * Returns a promise with the result from the validation.\n  * @param  {DOMString} assertion\n  * @param  {DOMString} origin       origin\n  * @return {Promise}         Promise         promise with the result from the validation\n  */\n  validateAssertion(assertion, origin, idpDomain) {\n    let _this = this;\n\n    let domain = _this._resolveDomain(idpDomain);\n\n    let message = {type:'EXECUTE', to: domain, from: _this._idmURL, body: {resource: 'identity', method: 'validateAssertion',\n            params: {assertion: assertion, origin: origin}}};\n\n    return new Promise(function(resolve, reject) {\n      _this._messageBus.postMessage(message, (result) => {\n        if (result.body.code === 200) {\n          resolve(result.body.value);\n        } else {\n          reject('error', result.body.code);\n        }\n      });\n    });\n  }\n\n  encryptMessage(message) {\n    let _this = this;\n\n    console.log('encrypt message ');\n\n    return new Promise(function(resolve, reject) {\n      let isHandShakeType = message.type === 'handshake';\n\n      //if is not to apply encryption, then returns resolve\n      if (!_this.isToUseEncryption && !isHandShakeType) {\n        console.log('encryption disabled');\n        return resolve(message);\n      }\n\n      //TODO remove this logic and move it to a util function\n      let splitedToURL = message.to.split('/');\n      let dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n      if (splitedToURL.length > 6) {\n        dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n      }\n\n      let isToDataObject = isDataObjectURL(dataObjectURL);\n      let isFromHyperty = divideURL(message.from).type === 'hyperty';\n      let isToHyperty = divideURL(message.to).type === 'hyperty';\n\n      if (isFromHyperty && isToHyperty) {\n        let userURL = _this._registry.getHypertyOwner(message.from);\n        if (userURL) {\n\n          // check if exists any keys between two users\n          let chatKeys = _this.chatKeys[message.from + '<->' + message.to];\n          if (!chatKeys) {\n            chatKeys = _this._newChatCrypto(message, userURL);\n            console.log('createChatKey encrypt', message.from + message.to);\n            _this.chatKeys[message.from + '<->' + message.to] = chatKeys;\n            message.body.handshakePhase = 'startHandShake';\n          }\n\n          if (chatKeys.authenticated && !isHandShakeType) {\n\n            let iv = _this.crypto.generateIV();\n            _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, message.body.value, iv).then(encryptedValue => {\n\n              let filteredMessage = _this._filterMessageToHash(message, message.body.value + iv, chatKeys.hypertyFrom.messageInfo);\n\n              _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage).then(hash => {\n                //console.log('result of hash ', hash);\n                let value = {iv: _this.crypto.encode(iv), value: _this.crypto.encode(encryptedValue), hash: _this.crypto.encode(hash)};\n                message.body.value = btoa(JSON.stringify(value));\n\n                resolve(message);\n              });\n            });\n\n            // if is a handshake message, just resolve it\n          } else if (isHandShakeType) {\n            resolve(message);\n\n            // else, starts a new handshake protocol\n          } else {\n            _this._doHandShakePhase(message, chatKeys).then(function(value) {\n              _this.chatKeys[message.from + '<->' + message.to] = value.chatKeys;\n\n              _this._messageBus.postMessage(value.message);\n              reject('encrypt handshake protocol phase ');\n            });\n          }\n        }\n\n      //if from hyperty to a dataObjectURL\n      } else if (isFromHyperty && isToDataObject) {\n        console.log('dataObject value to encrypt: ', message.body.value);\n\n        let dataObjectKey = _this.dataObjectSessionKeys[dataObjectURL];\n\n        //if no key exists, create a new one if is the reporter of dataObject\n        if (!dataObjectKey) {\n          let isHypertyReporter = _this.registry.getReporterURLSynchonous(dataObjectURL);\n\n          // if the hyperty is the reporter of the dataObject then generates a session key\n          if (isHypertyReporter && isHypertyReporter === message.from) {\n\n            let sessionKey = _this.crypto.generateRandom();\n            _this.dataObjectSessionKeys[dataObjectURL] = {sessionKey: sessionKey, isToEncrypt: true};\n\n            dataObjectKey = _this.dataObjectSessionKeys[dataObjectURL];\n          }\n        }\n\n        //check if there is already a session key for the chat room\n        if (dataObjectKey) {\n\n          // and if is to apply encryption, encrypt the messages\n          if (dataObjectKey.isToEncrypt) {\n            let iv = _this.crypto.generateIV();\n\n            _this.crypto.encryptAES(dataObjectKey.sessionKey, _this.crypto.encode(JSON.stringify(message.body.value)), iv).then(encryptedValue => {\n\n              let filteredMessage = _this._filterMessageToHash(message, message.body.value + iv, dataObjectKey.sessionKey);\n\n              _this.crypto.hashHMAC(dataObjectKey.sessionKey, filteredMessage).then(hash => {\n                //console.log('hash ', hash);\n\n                let newValue = btoa(JSON.stringify({value: _this.crypto.encode(encryptedValue), iv: _this.crypto.encode(iv), hash: _this.crypto.encode(hash)}));\n\n                message.body.value = newValue;\n                resolve(message);\n              });\n            });\n\n          // if not, just send the message\n          } else {\n            resolve(message);\n          }\n\n          // start the generation of a new session Key\n        } else {\n          reject('failed to decrypt message');\n        }\n      }\n    });\n  }\n\n  decryptMessage(message) {\n    let _this = this;\n\n    console.log('decrypt message ');\n\n    return new Promise(function(resolve, reject) {\n      let isHandShakeType = message.type === 'handshake';\n\n      //if is not to apply encryption, then returns resolve\n      if (!_this.isToUseEncryption && !isHandShakeType) {\n        console.log('decryption disabled');\n        return resolve(message);\n      }\n\n      //TODO remove this logic and move it to a util function\n\n      let splitedToURL = message.to.split('/');\n      let dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n      if (splitedToURL.length > 6) {\n        dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n      }\n\n      let isToDataObject = isDataObjectURL(dataObjectURL);\n      let isFromHyperty = divideURL(message.from).type === 'hyperty';\n      let isToHyperty = divideURL(message.to).type === 'hyperty';\n\n      //is is hyperty to hyperty communication\n      if (isFromHyperty && isToHyperty) {\n        //console.log('decrypt hyperty to hyperty');\n        let userURL = _this._registry.getHypertyOwner(message.to);\n        if (userURL) {\n\n          let chatKeys = _this.chatKeys[message.to + '<->' + message.from];\n          if (!chatKeys) {\n            chatKeys = _this._newChatCrypto(message, userURL, 'decrypt');\n            _this.chatKeys[message.to + '<->' + message.from] = chatKeys;\n          }\n\n          if (chatKeys.authenticated && !isHandShakeType) {\n            let value = JSON.parse(atob(message.body.value));\n            let iv = _this.crypto.decode(value.iv);\n            let data = _this.crypto.decode(value.value);\n            let hash = _this.crypto.decode(value.hash);\n            _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv).then(decryptedData => {\n              console.log('decrypted value ', decryptedData);\n              message.body.value = decryptedData;\n\n              let filteredMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n              _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hash).then(result => {\n                //console.log('result of hash verification! ', result);\n                message.body.assertedIdentity = true;\n                resolve(message);\n              });\n            });\n\n          } else if (isHandShakeType) {\n            _this._doHandShakePhase(message, chatKeys).then(function(value) {\n\n              //if it was started by doMutualAuthentication then ends the protocol\n              if (value === 'handShakeEnd') {\n                reject('decrypt handshake protocol phase ');\n\n              // if was started by a message, then resend that message\n              } else {\n                _this.chatKeys[message.to + '<->' + message.from] = value.chatKeys;\n                _this._messageBus.postMessage(value.message);\n                reject('decrypt handshake protocol phase ');\n              }\n            });\n          } else {\n            reject('wrong message do decrypt');\n          }\n        } else {\n          reject('error on decrypt message');\n        }\n\n        //if from hyperty to a dataObjectURL\n      } else if (isFromHyperty && isToDataObject) {\n        console.log('dataObject value to decrypt: ', message.body);\n\n        let dataObjectKey = _this.dataObjectSessionKeys[dataObjectURL];\n\n        if (dataObjectKey) {\n\n          //check if is to apply encryption\n          if (dataObjectKey.isToEncrypt) {\n            let parsedValue = JSON.parse(atob(message.body.value));\n            let iv = _this.crypto.decode(parsedValue.iv);\n            let encryptedValue = _this.crypto.decode(parsedValue.value);\n            let hash = _this.crypto.decode(parsedValue.hash);\n\n            _this.crypto.decryptAES(dataObjectKey.sessionKey, encryptedValue, iv).then(decryptedValue => {\n              let parsedValue = JSON.parse(atob(decryptedValue));\n              console.log('decrypted Value,', parsedValue);\n              message.body.value = parsedValue;\n\n              let filteredMessage = _this._filterMessageToHash(message, parsedValue + iv);\n\n              _this.crypto.verifyHMAC(dataObjectKey.sessionKey, filteredMessage, hash).then(result => {\n                //console.log('result of hash verification! ', result);\n\n                message.body.assertedIdentity = true;\n                resolve(message);\n              });\n            });\n\n          //if not, just return the message\n          } else {\n            message.body.assertedIdentity = true;\n            resolve(message);\n          }\n\n        } else {\n          message.body.assertedIdentity = true;\n          resolve(message);\n\n          //reject('no sessionKey for chat room found');\n        }\n\n      } else {\n        reject('wrong message to decrypt');\n      }\n\n    });\n  }\n\n  doMutualAuthentication(sender, receiver) {\n    console.log('doMutualAuthentication: ', sender, receiver);\n    let _this = this;\n    let dataObjectURL;\n\n    // check if the sender is a dataObject and if so stores that value\n    let reporterURL = _this.registry.getReporterURLSynchonous(sender);\n    if (reporterURL) {\n      dataObjectURL = sender;\n      sender = reporterURL;\n    }\n\n    let msg = {\n      to: receiver,\n      from: sender,\n      callback: undefined,\n      body: {handshakePhase: 'startHandShake', ignore: 'ignoreMessage'}\n    };\n\n    return new Promise(function(resolve, reject) {\n\n      if (!sender || !receiver) {\n        return reject('sender or receiver missing on doMutualAuthentication');\n      }\n\n      let chatKeys = _this.chatKeys[sender + '<->' + receiver];\n      let userURL = _this._registry.getHypertyOwner(sender);\n\n      if (userURL) {\n\n        if (!chatKeys) {\n          // callback to resolve when finish the mutual authentication\n          let resolved = function(value) {\n            console.log('callback value:', value);\n            resolve(value);\n          };\n          msg.callback = resolved;\n          msg.dataObjectURL = dataObjectURL;\n\n          chatKeys = _this._newChatCrypto(msg, userURL);\n          _this.chatKeys[sender + '<->' + receiver] = chatKeys;\n        }\n\n        if (chatKeys.authenticated) {\n\n          let startSessionKeyExchange = {\n            to: sender,\n            from: receiver\n          };\n          chatKeys.dataObjectURL = dataObjectURL;\n          _this._sendReporterSessionKey(startSessionKeyExchange, chatKeys).then(value => {\n\n            _this._messageBus.postMessage(value.message);\n            resolve('exchange of chat sessionKey initiated');\n          });\n        } else {\n\n          _this._doHandShakePhase(msg, chatKeys);\n        }\n      } else {\n        reject('error on doMutualAuthentication');\n      }\n    });\n\n  }\n\n  _doHandShakePhase(message, chatKeys) {\n    let _this = this;\n\n    //console.log('handshakeType');\n\n    return new Promise(function(resolve,reject) {\n\n      let handshakeType = message.body.handshakePhase;\n      let iv;\n      let hash;\n      let value = {};\n      let filteredMessage;\n      switch (handshakeType) {\n\n        case 'startHandShake':\n          chatKeys.keys.fromRandom = _this.crypto.generateRandom();\n\n          let startHandShakeMsg = {\n            type: 'handshake',\n            to: message.to,\n            from: message.from,\n            body: {\n              handshakePhase: 'senderHello',\n              value: _this.crypto.encode(chatKeys.keys.fromRandom)\n            }\n          };\n          chatKeys.handshakeHistory.senderHello = _this._filterMessageToHash(startHandShakeMsg, undefined, chatKeys.hypertyFrom.messageInfo);\n\n          // check if was the encrypt function or the mutual authentication that request the\n          // start of the handShakePhase.\n          if (chatKeys.initialMessage) {resolve({message: startHandShakeMsg, chatKeys: chatKeys});\n          } else {\n            _this.chatKeys[message.from + '<->' + message.to] = chatKeys;\n            _this._messageBus.postMessage(startHandShakeMsg);\n          }\n\n        break;\n        case 'senderHello':\n\n          console.log('senderHello');\n          chatKeys.handshakeHistory.senderHello = _this._filterMessageToHash(message);\n          chatKeys.keys.fromRandom = _this.crypto.decode(message.body.value);\n          chatKeys.keys.toRandom = _this.crypto.generateRandom();\n\n          let senderHelloMsg = {\n            type: 'handshake',\n            to: message.from,\n            from: message.to,\n            body: {\n              handshakePhase: 'receiverHello',\n              value: _this.crypto.encode(chatKeys.keys.toRandom)\n            }\n          };\n          chatKeys.handshakeHistory.receiverHello = _this._filterMessageToHash(senderHelloMsg, undefined, chatKeys.hypertyFrom.messageInfo);\n          resolve({message: senderHelloMsg, chatKeys: chatKeys});\n\n        break;\n        case 'receiverHello':\n\n          console.log('receiverHello');\n          chatKeys.handshakeHistory.receiverHello = _this._filterMessageToHash(message);\n\n          _this.validateAssertion(message.body.identity.assertion).then((value) => {\n\n            let receiverPublicKey = _this.crypto.decode(value.contents.nonce);\n            let premasterSecret = _this.crypto.generatePMS();\n            let toRandom = message.body.value;\n            chatKeys.hypertyTo.assertion = message.body.identity.assertion;\n            chatKeys.hypertyTo.publicKey = receiverPublicKey;\n            chatKeys.hypertyTo.userID    = value.contents.email;\n            chatKeys.keys.toRandom  = _this.crypto.decode(toRandom);\n            chatKeys.keys.premasterKey = premasterSecret;\n\n            let concatKey = _this.crypto.concatPMSwithRandoms(premasterSecret, chatKeys.keys.toRandom, chatKeys.keys.fromRandom);\n\n            return _this.crypto.generateMasterSecret(concatKey, 'messageHistoric' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            //generate the master key\n          }).then((masterKey) => {\n            chatKeys.keys.masterKey = masterKey;\n\n            return _this.crypto.generateKeys(masterKey, 'key expansion' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            //generate the symmetric and hash keys\n          }).then((keys) => {\n\n            chatKeys.keys.hypertyToSessionKey = new Uint8Array(keys[0]);\n            chatKeys.keys.hypertyFromSessionKey = new Uint8Array(keys[1]);\n            chatKeys.keys.hypertyToHashKey = new Uint8Array(keys[2]);\n            chatKeys.keys.hypertyFromHashKey = new Uint8Array(keys[3]);\n            iv = _this.crypto.generateIV();\n            value.iv = _this.crypto.encode(iv);\n\n            let messageStructure = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'senderCertificate'\n              }\n            };\n\n            // hash the value and the iv\n            filteredMessage = _this._filterMessageToHash(messageStructure, 'ok' + iv, chatKeys.hypertyFrom.messageInfo);\n            return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage);\n          }).then((hash) => {\n            value.hash = _this.crypto.encode(hash);\n\n            //encrypt the data\n            return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok', iv);\n          }).then((encryptedData) => {\n            value.symetricEncryption = _this.crypto.encode(encryptedData);\n\n            return _this.crypto.encryptRSA(chatKeys.hypertyTo.publicKey, chatKeys.keys.premasterKey);\n\n          }).then((encryptedValue) => {\n\n            value.assymetricEncryption = _this.crypto.encode(encryptedValue);\n\n            let messageStructure = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'senderCertificate'\n              }\n            };\n\n            let messageToHash = _this._filterMessageToHash(messageStructure, chatKeys.keys.premasterKey, chatKeys.hypertyFrom.messageInfo);\n\n            return _this.crypto.signRSA(chatKeys.hypertyFrom.privateKey, JSON.stringify(chatKeys.handshakeHistory) + JSON.stringify(messageToHash));\n\n          }).then(signature => {\n\n            value.signature = _this.crypto.encode(signature);\n\n            let receiverHelloMsg = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'senderCertificate',\n                value: btoa(JSON.stringify(value))\n              }\n            };\n            chatKeys.handshakeHistory.senderCertificate = _this._filterMessageToHash(receiverHelloMsg, 'ok' + iv, chatKeys.hypertyFrom.messageInfo);\n\n            resolve({message: receiverHelloMsg, chatKeys: chatKeys});\n\n          }, error => reject(error));\n\n        break;\n        case 'senderCertificate':\n\n          console.log('senderCertificate');\n          let receivedValue = JSON.parse(atob(message.body.value));\n\n          _this.validateAssertion(message.body.identity.assertion).then((value) => {\n            let encryptedPMS = _this.crypto.decode(receivedValue.assymetricEncryption);\n            let senderPublicKey = _this.crypto.decode(value.contents.nonce);\n            chatKeys.hypertyTo.assertion = message.body.identity.assertion;\n            chatKeys.hypertyTo.publicKey = senderPublicKey;\n            chatKeys.hypertyTo.userID    = value.contents.email;\n\n            return _this.crypto.decryptRSA(chatKeys.hypertyFrom.privateKey, encryptedPMS);\n\n          }, (error) => {\n            console.log(error);\n            reject('Error during authentication of identity');\n\n            //obtain the PremasterKey using the private key\n          }).then(pms => {\n\n            chatKeys.keys.premasterKey = new Uint8Array(pms);\n\n            let signature = _this.crypto.decode(receivedValue.signature);\n\n            let receivedmsgToHash = _this._filterMessageToHash(message, chatKeys.keys.premasterKey);\n\n            return _this.crypto.verifyRSA(chatKeys.hypertyTo.publicKey, JSON.stringify(chatKeys.handshakeHistory) + JSON.stringify(receivedmsgToHash), signature);\n\n            // validates the signature received\n          }).then(signValidationResult => {\n\n            console.log('signature validation result ', signValidationResult);\n            let concatKey = _this.crypto.concatPMSwithRandoms(chatKeys.keys.premasterKey, chatKeys.keys.toRandom, chatKeys.keys.fromRandom);\n\n            return _this.crypto.generateMasterSecret(concatKey, 'messageHistoric' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            // generates the master keys from the Premaster key and the randoms\n          }).then(masterKey => {\n            chatKeys.keys.masterKey = masterKey;\n\n            return _this.crypto.generateKeys(masterKey, 'key expansion' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            // generates the symmetric keys to be used in the symmetric encryption\n          }).then(keys => {\n            chatKeys.keys.hypertyFromSessionKey = new Uint8Array(keys[0]);\n            chatKeys.keys.hypertyToSessionKey = new Uint8Array(keys[1]);\n            chatKeys.keys.hypertyFromHashKey = new Uint8Array(keys[2]);\n            chatKeys.keys.hypertyToHashKey = new Uint8Array(keys[3]);\n            iv = _this.crypto.decode(receivedValue.iv);\n            let data = _this.crypto.decode(receivedValue.symetricEncryption);\n\n            return _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv);\n\n          }).then(decryptedData => {\n            //console.log('decryptedData', decryptedData);\n\n            chatKeys.handshakeHistory.senderCertificate = _this._filterMessageToHash(message, decryptedData + iv);\n\n            let hashReceived = _this.crypto.decode(receivedValue.hash);\n\n            filteredMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n            return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hashReceived);\n\n          }).then(verifiedHash  => {\n\n            //console.log('result of hash verification ', verifiedHash);\n            let receiverFinishedMessage = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'receiverFinishedMessage'\n              }\n            };\n            iv = _this.crypto.generateIV();\n            value.iv = _this.crypto.encode(iv);\n\n            filteredMessage = _this._filterMessageToHash(receiverFinishedMessage, 'ok!' + iv, chatKeys.hypertyFrom.messageInfo);\n\n            return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, receiverFinishedMessage);\n          }).then(hash => {\n\n            value.hash = _this.crypto.encode(hash);\n            return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok!', iv);\n\n          }).then(encryptedValue => {\n            value.value = _this.crypto.encode(encryptedValue);\n            let receiverFinishedMessage = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'receiverFinishedMessage',\n                value: btoa(JSON.stringify(value))\n              }\n            };\n\n            chatKeys.handshakeHistory.receiverFinishedMessage = _this._filterMessageToHash(receiverFinishedMessage, 'ok!' + iv, chatKeys.hypertyFrom.messageInfo);\n            chatKeys.authenticated = true;\n            resolve({message: receiverFinishedMessage, chatKeys: chatKeys});\n          });\n\n        break;\n        case 'receiverFinishedMessage':\n\n          console.log('receiverFinishedMessage');\n          chatKeys.authenticated = true;\n\n          value = JSON.parse(atob(message.body.value));\n\n          iv = _this.crypto.decode(value.iv);\n          let data = _this.crypto.decode(value.value);\n          hash = _this.crypto.decode(value.hash);\n\n          _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv).then(decryptedData => {\n            console.log('decryptedData', decryptedData);\n            chatKeys.handshakeHistory.receiverFinishedMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n            let filteredMessage = _this._filterMessageToHash(message, data + iv);\n            _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hash).then(result => {\n              console.log('hash result', result);\n\n              // check if there was an initial message that was blocked and send it\n              if (chatKeys.initialMessage) {\n                let initialMessage = {\n                  type: 'create',\n                  to: message.from,\n                  from: message.to,\n                  body: {\n                    value: chatKeys.initialMessage.body.value\n                  }\n                };\n\n                resolve({message: initialMessage, chatKeys: chatKeys});\n\n                //sends the sessionKey to the subscriber hyperty\n              } else {\n                _this._sendReporterSessionKey(message, chatKeys).then(value => {\n                  resolve(value);\n                });\n              }\n            });\n          });\n\n        break;\n        case 'reporterSessionKey':\n\n          console.log('reporterSessionKey');\n\n          let valueIVandHash = JSON.parse(atob(message.body.value));\n          hash = _this.crypto.decode(valueIVandHash.hash);\n          iv = _this.crypto.decode(valueIVandHash.iv);\n          let encryptedValue = _this.crypto.decode(valueIVandHash.value);\n          let parsedValue;\n          let sessionKey;\n          let dataObjectURL;\n          let receiverAcknowledgeMsg;\n\n          _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, encryptedValue, iv).then(decryptedValue => {\n\n            parsedValue = JSON.parse(decryptedValue);\n            sessionKey = _this.crypto.decode(parsedValue.value);\n            dataObjectURL = parsedValue.dataObjectURL;\n\n            let messageToHash = _this._filterMessageToHash(message, decryptedValue + iv);\n\n            return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, messageToHash, hash);\n\n          }).then(hashResult => {\n\n            //console.log('hash successfully validated ', hashResult);\n\n            _this.dataObjectSessionKeys[dataObjectURL] =  {sessionKey: sessionKey, isToEncrypt: true};\n\n            iv = _this.crypto.generateIV();\n            value.iv = _this.crypto.encode(iv);\n\n            return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok!!', iv);\n          }).then(encryptedValue => {\n\n            receiverAcknowledgeMsg = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'receiverAcknowledge'\n              }\n            };\n\n            value.value = _this.crypto.encode(encryptedValue);\n            let messageToHash = _this._filterMessageToHash(receiverAcknowledgeMsg, 'ok!!' + iv, chatKeys.hypertyFrom.messageInfo);\n\n            return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, messageToHash);\n          }).then(hashedMessage => {\n            let finalValue = btoa(JSON.stringify({value: value.value, hash: _this.crypto.encode(hashedMessage), iv: value.iv}));\n\n            receiverAcknowledgeMsg.body.value = finalValue;\n            resolve({message: receiverAcknowledgeMsg, chatKeys: chatKeys});\n          });\n\n        break;\n        case 'receiverAcknowledge':\n\n          console.log('receiverAcknowledge');\n\n          let receivedvalueIVandHash = JSON.parse(atob(message.body.value));\n          let receivedHash = _this.crypto.decode(receivedvalueIVandHash.hash);\n          iv = _this.crypto.decode(receivedvalueIVandHash.iv);\n          let receivedEncryptedValue = _this.crypto.decode(receivedvalueIVandHash.value);\n\n          _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, receivedEncryptedValue, iv).then(decryptedValue => {\n\n            let filteredMessage = _this._filterMessageToHash(message, decryptedValue + iv);\n            return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, receivedHash);\n          }).then(hashResult => {\n            //console.log('hashResult ', hashResult);\n\n            let callback = chatKeys.callback;\n\n            if (callback) {\n              callback('handShakeEnd');\n            }\n            resolve('handShakeEnd');\n          });\n\n        break;\n        default:\n          reject(message);\n      }\n    });\n  }\n\n  _sendReporterSessionKey(message, chatKeys) {\n    let _this = this;\n    let sessionKeyBundle = _this.dataObjectSessionKeys[chatKeys.dataObjectURL];\n    let reporterSessionKeyMsg;\n    let valueToEncrypt;\n    let sessionKey;\n    let iv;\n    let value = {};\n\n    return new Promise(function(resolve, reject) {\n\n      //if there is not yet a session Key, generates a new one\n      if (!sessionKeyBundle) {\n        sessionKey = _this.crypto.generateRandom();\n        _this.dataObjectSessionKeys[chatKeys.dataObjectURL] = {sessionKey: sessionKey, isToEncrypt: true};\n      } else {\n        sessionKey = sessionKeyBundle.sessionKey;\n      }\n\n      valueToEncrypt = JSON.stringify({value: _this.crypto.encode(sessionKey), dataObjectURL: chatKeys.dataObjectURL});\n\n      iv = _this.crypto.generateIV();\n      value.iv = _this.crypto.encode(iv);\n      _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, valueToEncrypt, iv).then(encryptedValue => {\n\n        reporterSessionKeyMsg = {\n          type: 'handshake',\n          to: message.from,\n          from: message.to,\n          body: {\n            handshakePhase: 'reporterSessionKey',\n            value: _this.crypto.encode(encryptedValue)\n          }\n        };\n\n        let filteredMessage = _this._filterMessageToHash(reporterSessionKeyMsg, valueToEncrypt + iv, chatKeys.hypertyFrom.messageInfo);\n\n        return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage);\n      }).then(hashedMessage => {\n\n        let valueWithHash = btoa(JSON.stringify({value: reporterSessionKeyMsg.body.value, hash: _this.crypto.encode(hashedMessage), iv: value.iv}));\n\n        reporterSessionKeyMsg.body.value = valueWithHash;\n        resolve({message: reporterSessionKeyMsg, chatKeys: chatKeys});\n      });\n    });\n  }\n\n  /**\n  * returns the reporter associated to the dataObject URL\n  * @param   {String}   dataObjectURL         dataObject url\n  * @return   {String}  reporter              dataObject url reporter\n  */\n  _getHypertyFromDataObject(dataObjectURL) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      //TODO remove this logic and move it to a util function\n\n      let splitedURL = dataObjectURL.split('/');\n      let finalURL = splitedURL[0] + '//' + splitedURL[2] + '/' + splitedURL[3];\n      if (splitedURL.length > 6) {\n        finalURL = splitedURL[0] + '//' + splitedURL[2] + '/' + splitedURL[3] + '/' + splitedURL[4];\n      }\n\n      // check if is the creator of the hyperty\n      let reporterURL = _this.registry.getReporterURLSynchonous(finalURL);\n\n      if (reporterURL) {\n        resolve(reporterURL);\n      } else {\n        // check if there is already an association from an hypertyURL to the dataObject\n        let storedReporterURL = _this.dataObjectsIdentity[finalURL];\n\n        if (storedReporterURL) {\n          resolve(storedReporterURL);\n        } else {\n          // check if there is any hyperty that subscribed the dataObjectURL\n          let subscriberHyperty = _this.registry.getDataObjectSubscriberHyperty(dataObjectURL);\n\n          if (subscriberHyperty) {\n            resolve(subscriberHyperty);\n          } else {\n\n            // search in domain registry for the hyperty associated to the dataObject\n            // search in case is a subscriber who wants to know the reporter\n            _this.registry.discoverDataObjectPerURL(finalURL, splitedURL[2]).then(dataObject => {\n              _this.dataObjectsIdentity[finalURL] = dataObject.reporter;\n              resolve(dataObject.reporter);\n            }, err => {\n              reject(err);\n            });\n          }\n        }\n      }\n    });\n  }\n\n  /**\n  * filter the messages to hash, by removing some fields not generated by the runtime core\n  * @param {Message}  message                     message\n  * @param {String}  decryptedValue (Optional)    value from body.value in case it originally comes encrypted\n  * @param {JSON}  identity(Optional)    add the hyperty identity associated in case is not added to the initial message\n  * @return {Message}  new message filtered\n  */\n  _filterMessageToHash(message, decryptedValue, identity) {\n\n    return {\n      type: message.type,\n      from: message.from,\n      to:   message.to,\n      body: {\n        identity: identity || message.body.identity,\n        value: decryptedValue || message.body.value,\n        handshakePhase: message.body.handshakePhase\n      }\n    };\n  }\n\n  /**\n  * generates the initial structure for the keys between two users\n  * @param {JSON}    message              initial message that triggers the mutual authentication\n  * @param {String}  userURL              userURL\n  * @param {boolean} receiver(Optional)  indicates if is the sender or the receiver that creates a new chat crypto\n  * @return {JSON} newChatCrypto  new JSON structure for the chat crypto\n  */\n  _newChatCrypto(message, userURL, receiver) {\n    let _this = this;\n\n    //check whether is the sender or the receiver to create a new chatCrypto\n    //to mantain consistency on the keys if the receiver create a new chatCrypto,\n    //then invert the fields\n    let from = (receiver) ? message.to : message.from;\n    let to = (receiver) ? message.from : message.to;\n\n    let userInfo = _this.getIdentity(userURL);\n\n    let newChatCrypto =\n    {\n      hypertyFrom:\n      {\n        hyperty: from,\n        userID: userInfo.messageInfo.userProfile.username,\n        privateKey: userInfo.keyPair.private,\n        publicKey: userInfo.keyPair.public,\n        assertion: userInfo.assertion,\n        messageInfo: userInfo.messageInfo\n      },\n      hypertyTo:\n      {\n        hyperty: to,\n        userID: undefined,\n        publicKey: undefined,\n        assertion: undefined\n      },\n      keys:\n      {\n        hypertyToSessionKey: undefined,\n        hypertyFromSessionKey: undefined,\n        hypertyToHashKey: undefined,\n        hypertyFromHashKey: undefined,\n        toRandom: undefined,\n        fromRandom: undefined,\n        premasterKey: undefined,\n        masterKey: undefined\n      },\n      handshakeHistory: {\n        senderHello: undefined,\n        receiverHello: undefined,\n        senderCertificate: undefined,\n        receiverFinishedMessage: undefined\n      },\n      initialMessage: (message.body.ignore) ? undefined : message,\n      callback: message.callback,\n      authenticated: false,\n      dataObjectURL: message.dataObjectURL\n    };\n\n    return newChatCrypto;\n  }\n}\n\nexport default IdentityModule;\n"],"sourceRoot":"/source/"}